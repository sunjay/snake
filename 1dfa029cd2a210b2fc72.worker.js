/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends2 = __webpack_require__(1);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(17);
	
	var applyMiddleware = _require.applyMiddleware;
	var createStore = _require.createStore;
	
	var thunk = __webpack_require__(31).default;
	
	var appReducer = __webpack_require__(32);
	
	var _require2 = __webpack_require__(88);
	
	var ACTION_ENABLE_AI = _require2.ACTION_ENABLE_AI;
	var ACTION_UPDATE = _require2.ACTION_UPDATE;
	var enableAI = _require2.enableAI;
	var snakeDirection = _require2.snakeDirection;
	var updatePlannedPath = _require2.updatePlannedPath;
	var shiftPlannedPath = _require2.shiftPlannedPath;
	var clearPlannedPath = _require2.clearPlannedPath;
	
	
	var planner = __webpack_require__(109);
	
	var send = function send(action) {
	  return postMessage((0, _extends3.default)({}, action, {
	    source: 'ai'
	  }));
	};
	
	var store = createStore(appReducer, applyMiddleware(thunk));
	
	self.addEventListener('message', function (_ref) {
	  var action = _ref.data;
	
	  store.dispatch(action);
	
	  var state = store.getState();
	  var useAI = state.settings.useAI;
	  var plan = state.ai.plan;
	  var plannedTarget = state.ai.target;
	  var game = state.game;
	  var isRunning = game.status.isRunning;
	  var head = game.snake.head();
	
	  if (action.type === ACTION_ENABLE_AI) {
	    send(enableAI(useAI));
	
	    store.dispatch(clearPlannedPath());
	    send(clearPlannedPath());
	  }
	
	  if (action.type === ACTION_UPDATE && isRunning && useAI) {
	    // Assumption: we will always hit the point in the plan
	    // i.e. we can never accidentally skip an update and the AI will always
	    // plan for squares we will actually hit
	    sendDirectionUpdate(head, plan);
	
	    //TODO: Right now this happens on every update, but in reality
	    // what should happen is that the AI should constantly be working
	    // to calculate the path only pausing to process messages and update
	    if (!game.goal.equals(plannedTarget)) {
	      updateAIPath(game);
	    }
	  }
	});
	
	/**
	 * If the snake is at the next point on the planned path,
	 * this will send a direction update for the next direction
	 * and then shift the planned path
	 */
	function sendDirectionUpdate(head, plan) {
	  if (!plan.hasPlan()) {
	    return;
	  }
	
	  var _plan$firstTurn = plan.firstTurn();
	
	  var x = _plan$firstTurn.x;
	  var y = _plan$firstTurn.y;
	  var direction = _plan$firstTurn.direction;
	
	
	  if (head.equals({ x: x, y: y })) {
	    // We just fire and forget here with no hope of acknowledgement
	    store.dispatch(snakeDirection(direction));
	    send(snakeDirection(direction));
	
	    // This needs to be updated on both ends and will not be acknowledged
	    store.dispatch(shiftPlannedPath());
	    send(shiftPlannedPath());
	  }
	}
	
	/**
	 * Updates the planned path if necessary and sends that update
	 */
	function updateAIPath(game) {
	  console.time('astar');
	  var path = planner.planPathAStar(game);
	  console.timeEnd('astar');
	
	  // This needs to be updated on both ends and will not be acknowledged
	  store.dispatch(updatePlannedPath(path.toJSON(), game.goal.toJSON()));
	  send(updatePlannedPath(path.toJSON(), game.goal.toJSON()));
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Object$assign = __webpack_require__(2)["default"];
	
	exports["default"] = _Object$assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};
	
	exports.__esModule = true;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(3), __esModule: true };

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	module.exports = __webpack_require__(7).Object.assign;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(5);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(10)});

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(6)
	  , core      = __webpack_require__(7)
	  , ctx       = __webpack_require__(8)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ },
/* 6 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 7 */
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(9);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.1 Object.assign(target, source, ...)
	var $        = __webpack_require__(11)
	  , toObject = __webpack_require__(12)
	  , IObject  = __webpack_require__(14);
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = __webpack_require__(16)(function(){
	  var a = Object.assign
	    , A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , $$    = arguments
	    , $$len = $$.length
	    , index = 1
	    , getKeys    = $.getKeys
	    , getSymbols = $.getSymbols
	    , isEnum     = $.isEnum;
	  while($$len > index){
	    var S      = IObject($$[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  }
	  return T;
	} : Object.assign;

/***/ },
/* 11 */
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(13);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 13 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(15);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 15 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(19);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(26);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(28);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(29);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(30);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(27);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))

/***/ },
/* 18 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(20);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(24);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(21),
	    isHostObject = __webpack_require__(22),
	    isObjectLike = __webpack_require__(23);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 21 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	module.exports = getPrototype;


/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 23 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(25)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(19);
	
	var _isPlainObject = __webpack_require__(20);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(27);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))

/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(30);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 31 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch;
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _require = __webpack_require__(17);
	
	var combineReducers = _require.combineReducers;
	
	
	var game = __webpack_require__(33);
	var ai = __webpack_require__(89);
	var settings = __webpack_require__(107);
	
	var app = combineReducers({
	  game: game,
	  ai: ai,
	  settings: settings
	});
	
	module.exports = app;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _defineProperty2 = __webpack_require__(34);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _keys = __webpack_require__(37);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _createReducer;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(41);
	
	var createReducer = _require.createReducer;
	
	
	var Vector = __webpack_require__(42);
	var Direction = __webpack_require__(79);
	var SnakeGame = __webpack_require__(80);
	
	var _require2 = __webpack_require__(88);
	
	var ACTION_RESET = _require2.ACTION_RESET;
	var ACTION_DIRECTION = _require2.ACTION_DIRECTION;
	var ACTION_UPDATE = _require2.ACTION_UPDATE;
	
	
	var initialState = SnakeGame.fromDimensions({ rows: 30, cols: 30 });
	var game = createReducer(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, ACTION_RESET, function (state) {
	  return initialState.placeRandomGoal();
	}), (0, _defineProperty3.default)(_createReducer, ACTION_DIRECTION, function (state, _ref) {
	  var name = _ref.name;
	
	  var direction = Direction.toDirection(name);
	  return state.update('snake', function (snake) {
	    return snake.setDirection(direction);
	  }).update('status', function (status) {
	    if (status.isReady) {
	      return status.setRunning();
	    }
	    return status;
	  });
	}), (0, _defineProperty3.default)(_createReducer, ACTION_UPDATE, function (state, _ref2) {
	  var _ref2$goal = _ref2.goal;
	  var goal = _ref2$goal === undefined ? {} : _ref2$goal;
	
	  if (state.status.isRunning) {
	    state = state.update('snake', function (snake) {
	      return snake.shift();
	    });
	    if (state.isGoal(state.snake.head())) {
	      state = state.update('snake', function (snake) {
	        return snake.grow();
	      }).placeRandomGoal();
	    }
	  }
	
	  // since null is a valid goal value, goal is only not set if an empty object is provided
	  if (!goal || (0, _keys2.default)(goal).length > 0) {
	    state = state.set('goal', new Vector(goal));
	  }
	
	  return state.update('status', function (status) {
	    if (state.snake.isWithinSelf()) {
	      return status.setLost('bumped into yourself');
	    } else if (state.isOutOfBounds(state.snake.head())) {
	      return status.setLost('out of bounds');
	    } else if (state.isFull) {
	      return status.setWon();
	    }
	    return status;
	  });
	}), _createReducer));
	
	module.exports = game;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(35);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	
	  return obj;
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(36), __esModule: true };

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(11);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(38), __esModule: true };

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(39);
	module.exports = __webpack_require__(7).Object.keys;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(12);
	
	__webpack_require__(40)('keys', function($keys){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(5)
	  , core    = __webpack_require__(7)
	  , fails   = __webpack_require__(16);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createReducer = createReducer;
	function createReducer(initialState) {
	  var actionHandlers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  return function () {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
	    var action = arguments[1];
	
	    var handler = actionHandlers[action.type];
	    if (handler) {
	      return handler(state, action);
	    }
	    return state;
	  };
	}

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _getPrototypeOf = __webpack_require__(43);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(46);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(47);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(48);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(71);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(78);
	
	var Record = _require.Record;
	
	
	var VectorRecord = Record({
	  x: undefined,
	  y: undefined
	});
	
	var Vector = function (_VectorRecord) {
	  (0, _inherits3.default)(Vector, _VectorRecord);
	
	  function Vector() {
	    (0, _classCallCheck3.default)(this, Vector);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Vector).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Vector, [{
	    key: "equals",
	    value: function equals(_ref) {
	      var x = _ref.x;
	      var y = _ref.y;
	
	      return this.x === x && this.y === y;
	    }
	  }, {
	    key: "add",
	    value: function add(_ref2) {
	      var x = _ref2.x;
	      var y = _ref2.y;
	
	      return new Vector({
	        x: this.x + x,
	        y: this.y + y
	      });
	    }
	  }, {
	    key: "sub",
	    value: function sub(_ref3) {
	      var x = _ref3.x;
	      var y = _ref3.y;
	
	      return new Vector({
	        x: this.x - x,
	        y: this.y - y
	      });
	    }
	  }, {
	    key: "div",
	    value: function div(value) {
	      return new Vector({
	        x: this.x / value,
	        y: this.y / value
	      });
	    }
	  }, {
	    key: "dot",
	    value: function dot(_ref4) {
	      var x = _ref4.x;
	      var y = _ref4.y;
	
	      return this.x * x + this.y * y;
	    }
	  }, {
	    key: "normalize",
	    value: function normalize() {
	      return this.div(this.magnitude);
	    }
	  }, {
	    key: "negate",
	    value: function negate() {
	      return new Vector({
	        x: -this.x,
	        y: -this.y
	      });
	    }
	  }, {
	    key: "squaredDistanceTo",
	    value: function squaredDistanceTo(_ref5) {
	      var x = _ref5.x;
	      var y = _ref5.y;
	
	      return Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2);
	    }
	  }, {
	    key: "hash",
	    value: function hash() {
	      return this.x + "," + this.y;
	    }
	  }, {
	    key: "magnitude",
	    get: function get() {
	      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
	    }
	  }]);
	  return Vector;
	}(VectorRecord);
	
	module.exports = Vector;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(44), __esModule: true };

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(45);
	module.exports = __webpack_require__(7).Object.getPrototypeOf;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(12);
	
	__webpack_require__(40)('getPrototypeOf', function($getPrototypeOf){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 46 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(35);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(49);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Symbol = __webpack_require__(50)["default"];
	
	exports["default"] = function (obj) {
	  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
	};
	
	exports.__esModule = true;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(51), __esModule: true };

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(52);
	__webpack_require__(70);
	module.exports = __webpack_require__(7).Symbol;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $              = __webpack_require__(11)
	  , global         = __webpack_require__(6)
	  , has            = __webpack_require__(53)
	  , DESCRIPTORS    = __webpack_require__(54)
	  , $export        = __webpack_require__(5)
	  , redefine       = __webpack_require__(55)
	  , $fails         = __webpack_require__(16)
	  , shared         = __webpack_require__(58)
	  , setToStringTag = __webpack_require__(59)
	  , uid            = __webpack_require__(61)
	  , wks            = __webpack_require__(60)
	  , keyOf          = __webpack_require__(62)
	  , $names         = __webpack_require__(64)
	  , enumKeys       = __webpack_require__(65)
	  , isArray        = __webpack_require__(66)
	  , anObject       = __webpack_require__(67)
	  , toIObject      = __webpack_require__(63)
	  , createDesc     = __webpack_require__(57)
	  , getDesc        = $.getDesc
	  , setDesc        = $.setDesc
	  , _create        = $.create
	  , getNames       = $names.get
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , HIDDEN         = wks('_hidden')
	  , isEnum         = $.isEnum
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , useNative      = typeof $Symbol == 'function'
	  , ObjectProto    = Object.prototype;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(setDesc({}, 'a', {
	    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = getDesc(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  setDesc(it, key, D);
	  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	} : setDesc;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol.prototype);
	  sym._k = tag;
	  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};
	
	var isSymbol = function(it){
	  return typeof it == 'symbol';
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toIObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	  var args = [it]
	    , i    = 1
	    , $$   = arguments
	    , replacer, $replacer;
	  while($$.length > i)args.push($$[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var buggyJSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});
	
	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  redefine($Symbol.prototype, 'toString', function toString(){
	    return this._k;
	  });
	
	  isSymbol = function(it){
	    return it instanceof $Symbol;
	  };
	
	  $.create     = $create;
	  $.isEnum     = $propertyIsEnumerable;
	  $.getDesc    = $getOwnPropertyDescriptor;
	  $.setDesc    = $defineProperty;
	  $.setDescs   = $defineProperties;
	  $.getNames   = $names.get = $getOwnPropertyNames;
	  $.getSymbols = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(69)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}
	
	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	  'species,split,toPrimitive,toStringTag,unscopables'
	).split(','), function(it){
	  var sym = wks(it);
	  symbolStatics[it] = useNative ? sym : wrap(sym);
	});
	
	setter = true;
	
	$export($export.G + $export.W, {Symbol: $Symbol});
	
	$export($export.S, 'Symbol', symbolStatics);
	
	$export($export.S + $export.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
	
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 53 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(16)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(56);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(11)
	  , createDesc = __webpack_require__(57);
	module.exports = __webpack_require__(54) ? function(object, key, value){
	  return $.setDesc(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(6)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(11).setDesc
	  , has = __webpack_require__(53)
	  , TAG = __webpack_require__(60)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var store  = __webpack_require__(58)('wks')
	  , uid    = __webpack_require__(61)
	  , Symbol = __webpack_require__(6).Symbol;
	module.exports = function(name){
	  return store[name] || (store[name] =
	    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
	};

/***/ },
/* 61 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(11)
	  , toIObject = __webpack_require__(63);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(14)
	  , defined = __webpack_require__(13);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(63)
	  , getNames  = __webpack_require__(11).getNames
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return getNames(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.get = function getOwnPropertyNames(it){
	  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
	  return getNames(toIObject(it));
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var $ = __webpack_require__(11);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getSymbols = $.getSymbols;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = $.isEnum
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
	  }
	  return keys;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(15);
	module.exports = Array.isArray || function(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(68);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 70 */
/***/ function(module, exports) {



/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Object$create = __webpack_require__(72)["default"];
	
	var _Object$setPrototypeOf = __webpack_require__(74)["default"];
	
	exports["default"] = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }
	
	  subClass.prototype = _Object$create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};
	
	exports.__esModule = true;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(73), __esModule: true };

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(11);
	module.exports = function create(P, D){
	  return $.create(P, D);
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(75), __esModule: true };

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(76);
	module.exports = __webpack_require__(7).Object.setPrototypeOf;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(5);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(77).set});

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var getDesc  = __webpack_require__(11).getDesc
	  , isObject = __webpack_require__(68)
	  , anObject = __webpack_require__(67);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(8)(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
	
	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }
	
	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }
	
	
	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }
	
	
	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }
	
	
	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }
	
	
	
	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }
	
	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }
	
	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }
	
	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }
	
	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }
	
	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;
	
	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;
	
	
	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';
	
	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;
	
	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};
	
	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };
	
	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }
	
	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }
	
	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}
	
	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }
	
	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }
	
	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }
	
	  function returnTrue() {
	    return true;
	  }
	
	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }
	
	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }
	
	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }
	
	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }
	
	  /* global Symbol */
	
	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;
	
	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	
	  function Iterator(next) {
	      this.next = next;
	    }
	
	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };
	
	
	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;
	
	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };
	
	
	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }
	
	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }
	
	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }
	
	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }
	
	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }
	
	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }
	
	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }
	
	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };
	
	    Seq.prototype.toSeq = function() {
	      return this;
	    };
	
	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };
	
	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };
	
	    // abstract __iterateUncached(fn, reverse)
	
	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };
	
	    // abstract __iteratorUncached(type, reverse)
	
	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };
	
	
	
	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }
	
	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };
	
	
	
	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }
	
	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };
	
	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };
	
	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };
	
	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };
	
	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };
	
	
	
	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }
	
	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };
	
	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };
	
	
	
	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;
	
	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
	  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	
	
	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }
	
	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };
	
	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };
	
	
	
	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }
	
	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };
	
	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };
	
	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };
	
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }
	
	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };
	
	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };
	
	
	
	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }
	
	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	
	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };
	
	
	
	
	  // # pragma Helper functions
	
	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }
	
	  var EMPTY_SEQ;
	
	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }
	
	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }
	
	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }
	
	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }
	
	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }
	
	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }
	
	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }
	
	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }
	
	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }
	
	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }
	
	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }
	
	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }
	
	    var notAssociative = !isAssociative(a);
	
	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }
	
	    var flipped = false;
	
	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }
	
	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });
	
	    return allEqual && a.size === bSize;
	  }
	
	  createClass(Repeat, IndexedSeq);
	
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }
	
	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };
	
	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };
	
	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };
	
	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };
	
	    Repeat.prototype.reverse = function() {
	      return this;
	    };
	
	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };
	
	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };
	
	
	  var EMPTY_REPEAT;
	
	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }
	
	  createClass(Range, IndexedSeq);
	
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }
	
	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };
	
	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };
	
	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };
	
	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };
	
	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };
	
	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };
	
	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };
	
	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };
	
	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };
	
	
	  var EMPTY_RANGE;
	
	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }
	
	
	  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
	  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
	  createClass(SetCollection, Collection);function SetCollection() {}
	
	
	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;
	
	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };
	
	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }
	
	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }
	
	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }
	
	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }
	
	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }
	
	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }
	
	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }
	
	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }
	
	    return hash;
	  }
	
	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;
	
	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());
	
	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }
	
	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }
	
	  var objHashUID = 0;
	
	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }
	
	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};
	
	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }
	
	  createClass(Map, KeyedCollection);
	
	    // @pragma Construction
	
	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };
	
	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };
	
	    // @pragma Access
	
	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };
	
	    // @pragma Modification
	
	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };
	
	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };
	
	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };
	
	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };
	
	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };
	
	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };
	
	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };
	
	    // @pragma Composition
	
	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };
	
	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };
	
	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };
	
	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };
	
	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };
	
	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };
	
	    // @pragma Mutability
	
	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };
	
	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };
	
	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };
	
	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };
	
	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };
	
	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };
	
	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };
	
	
	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }
	
	  Map.isMap = isMap;
	
	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	
	  // #pragma Trie Nodes
	
	
	
	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }
	
	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && entries.length === 1) {
	        return; // undefined
	      }
	
	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new ArrayMapNode(ownerID, newEntries);
	    };
	
	
	
	
	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }
	
	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };
	
	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;
	
	      if (!exists && value === NOT_SET) {
	        return this;
	      }
	
	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
	      if (newNode === node) {
	        return this;
	      }
	
	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }
	
	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }
	
	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };
	
	
	
	
	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }
	
	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };
	
	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];
	
	      if (removed && !node) {
	        return this;
	      }
	
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }
	
	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };
	
	
	
	
	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }
	
	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	
	      var removed = value === NOT_SET;
	
	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };
	
	
	
	
	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }
	
	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };
	
	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	
	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }
	
	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }
	
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };
	
	
	
	  // #pragma Iterators
	
	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }
	
	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }
	
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }
	
	  createClass(MapIterator, Iterator);
	
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }
	
	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };
	
	
	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }
	
	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }
	
	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }
	
	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }
	
	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }
	
	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }
	
	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }
	
	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }
	
	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }
	
	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }
	
	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }
	
	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }
	
	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }
	
	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }
	
	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }
	
	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }
	
	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }
	
	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }
	
	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }
	
	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }
	
	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
	  createClass(List, IndexedCollection);
	
	    // @pragma Construction
	
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }
	
	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };
	
	    // @pragma Access
	
	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };
	
	    // @pragma Modification
	
	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };
	
	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };
	
	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };
	
	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };
	
	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };
	
	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };
	
	    // @pragma Composition
	
	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };
	
	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };
	
	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };
	
	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };
	
	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };
	
	    // @pragma Iteration
	
	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };
	
	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };
	
	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };
	
	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };
	
	
	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }
	
	  List.isList = isList;
	
	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	
	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }
	
	    // TODO: seems like these methods are very similar
	
	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };
	
	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }
	
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }
	
	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };
	
	
	
	  var DONE = {};
	
	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;
	
	    return iterateNodeOrLeaf(list._root, list._level, 0);
	
	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }
	
	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }
	
	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }
	
	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }
	
	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }
	
	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);
	
	    if (index !== index) {
	      return list;
	    }
	
	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }
	
	    index += list._origin;
	
	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }
	
	    if (!didAlter.value) {
	      return list;
	    }
	
	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }
	
	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }
	
	    var newNode;
	
	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }
	
	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }
	
	    SetRef(didAlter);
	
	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }
	
	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }
	
	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }
	
	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }
	
	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }
	
	    var newLevel = list._level;
	    var newRoot = list._root;
	
	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }
	
	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);
	
	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }
	
	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }
	
	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }
	
	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;
	
	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }
	
	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }
	
	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }
	
	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }
	
	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }
	
	  createClass(OrderedMap, Map);
	
	    // @pragma Construction
	
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };
	
	    // @pragma Access
	
	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };
	
	    // @pragma Modification
	
	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };
	
	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };
	
	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };
	
	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };
	
	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };
	
	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };
	
	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };
	
	
	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }
	
	  OrderedMap.isOrderedMap = isOrderedMap;
	
	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	
	
	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }
	
	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }
	
	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }
	
	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }
	
	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };
	
	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };
	
	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };
	
	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };
	
	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };
	
	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };
	
	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };
	
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };
	
	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };
	
	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };
	
	
	
	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };
	
	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };
	
	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };
	
	
	
	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }
	
	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };
	
	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };
	
	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };
	
	
	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;
	
	
	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }
	
	
	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }
	
	
	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }
	
	
	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }
	
	
	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }
	
	
	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }
	
	
	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;
	
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }
	
	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }
	
	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);
	
	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }
	
	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }
	
	    var sliceSeq = makeSequence(iterable);
	
	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
	
	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }
	
	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };
	
	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }
	
	    return sliceSeq;
	  }
	
	
	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }
	
	
	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }
	
	
	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});
	
	    if (iters.length === 0) {
	      return iterable;
	    }
	
	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }
	
	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }
	
	
	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }
	
	
	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }
	
	
	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }
	
	
	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }
	
	
	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }
	
	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }
	
	
	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }
	
	
	  // #pragma Helper Functions
	
	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }
	
	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }
	
	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }
	
	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }
	
	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }
	
	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }
	
	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	
	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }
	
	  createClass(Record, KeyedCollection);
	
	    function Record(defaultValues, name) {
	      var hasInitialized;
	
	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };
	
	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;
	
	      return RecordType;
	    }
	
	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };
	
	    // @pragma Access
	
	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };
	
	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };
	
	    // @pragma Modification
	
	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };
	
	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };
	
	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };
	
	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };
	
	
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	
	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }
	
	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }
	
	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }
	
	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }
	
	  createClass(Set, SetCollection);
	
	    // @pragma Construction
	
	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };
	
	    // @pragma Access
	
	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };
	
	    // @pragma Modification
	
	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };
	
	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };
	
	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };
	
	    // @pragma Composition
	
	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };
	
	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };
	
	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };
	
	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };
	
	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };
	
	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };
	
	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };
	
	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };
	
	
	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }
	
	  Set.isSet = isSet;
	
	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;
	
	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }
	
	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }
	
	  createClass(OrderedSet, Set);
	
	    // @pragma Construction
	
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };
	
	
	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }
	
	  OrderedSet.isOrderedSet = isOrderedSet;
	
	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;
	
	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }
	
	  createClass(Stack, IndexedCollection);
	
	    // @pragma Construction
	
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }
	
	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };
	
	    // @pragma Access
	
	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };
	
	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };
	
	    // @pragma Modification
	
	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };
	
	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };
	
	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };
	
	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };
	
	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };
	
	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    // @pragma Mutability
	
	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };
	
	    // @pragma Iteration
	
	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };
	
	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };
	
	
	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }
	
	  Stack.isStack = isStack;
	
	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }
	
	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }
	
	  Iterable.Iterator = Iterator;
	
	  mixin(Iterable, {
	
	    // ### Conversion to other types
	
	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },
	
	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },
	
	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },
	
	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },
	
	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },
	
	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },
	
	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },
	
	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },
	
	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },
	
	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	
	    // ### Common JavaScript methods and properties
	
	    toString: function() {
	      return '[Iterable]';
	    },
	
	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },
	
	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },
	
	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },
	
	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },
	
	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },
	
	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },
	
	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },
	
	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },
	
	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },
	
	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },
	
	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },
	
	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },
	
	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },
	
	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },
	
	
	    // ### More sequential methods
	
	    butLast: function() {
	      return this.slice(0, -1);
	    },
	
	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },
	
	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },
	
	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },
	
	    equals: function(other) {
	      return deepEqual(this, other);
	    },
	
	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },
	
	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },
	
	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },
	
	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },
	
	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },
	
	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },
	
	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },
	
	    first: function() {
	      return this.find(returnTrue);
	    },
	
	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },
	
	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },
	
	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },
	
	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },
	
	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },
	
	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },
	
	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },
	
	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },
	
	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },
	
	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },
	
	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },
	
	    last: function() {
	      return this.toSeq().reverse().first();
	    },
	
	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },
	
	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },
	
	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },
	
	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },
	
	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },
	
	    rest: function() {
	      return this.slice(1);
	    },
	
	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },
	
	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },
	
	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },
	
	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },
	
	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },
	
	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },
	
	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },
	
	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },
	
	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },
	
	
	    // ### Hashable Object
	
	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }
	
	
	    // ### Internal
	
	    // abstract __iterate(fn, reverse)
	
	    // abstract __iterator(type, reverse)
	  });
	
	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;
	
	  mixin(KeyedIterable, {
	
	    // ### More sequential methods
	
	    flip: function() {
	      return reify(this, flipFactory(this));
	    },
	
	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },
	
	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }
	
	  });
	
	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
	
	
	
	  mixin(IndexedIterable, {
	
	    // ### Conversion to other types
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },
	
	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },
	
	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },
	
	
	    // ### More collection methods
	
	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    first: function() {
	      return this.get(0);
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },
	
	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },
	
	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },
	
	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },
	
	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },
	
	    keySeq: function() {
	      return Range(0, this.size);
	    },
	
	    last: function() {
	      return this.get(-1);
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },
	
	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },
	
	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }
	
	  });
	
	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	
	  mixin(SetIterable, {
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },
	
	    includes: function(value) {
	      return this.has(value);
	    },
	
	
	    // ### More sequential methods
	
	    keySeq: function() {
	      return this.valueSeq();
	    }
	
	  });
	
	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;
	
	
	  // Mixin subclasses
	
	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);
	
	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);
	
	
	  // #pragma Helper functions
	
	  function keyMapper(v, k) {
	    return k;
	  }
	
	  function entryMapper(v, k) {
	    return [k, v];
	  }
	
	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }
	
	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }
	
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }
	
	  function defaultZipper() {
	    return arrCopy(arguments);
	  }
	
	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }
	
	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }
	
	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }
	
	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }
	
	  var Immutable = {
	
	    Iterable: Iterable,
	
	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,
	
	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,
	
	    is: is,
	    fromJS: fromJS
	
	  };
	
	  return Immutable;
	
	}));

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.WEST = exports.EAST = exports.SOUTH = exports.NORTH = undefined;
	
	var _keys = __webpack_require__(37);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _defineProperty2 = __webpack_require__(34);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _ALL;
	
	exports.all = all;
	exports.names = names;
	exports.isOpposite = isOpposite;
	exports.toName = toName;
	exports.toDirection = toDirection;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Vector = __webpack_require__(42);
	
	var NORTH = exports.NORTH = 'N';
	var SOUTH = exports.SOUTH = 'S';
	var EAST = exports.EAST = 'E';
	var WEST = exports.WEST = 'W';
	
	var ALL = (_ALL = {}, (0, _defineProperty3.default)(_ALL, NORTH, new Vector({ x: 0, y: -1 })), (0, _defineProperty3.default)(_ALL, SOUTH, new Vector({ x: 0, y: 1 })), (0, _defineProperty3.default)(_ALL, EAST, new Vector({ x: 1, y: 0 })), (0, _defineProperty3.default)(_ALL, WEST, new Vector({ x: -1, y: 0 })), _ALL);
	
	function all() {
	  return names().map(function (n) {
	    return ALL[n];
	  });
	}
	
	function names() {
	  return (0, _keys2.default)(ALL);
	}
	
	function isOpposite(d1, d2) {
	  return d1.dot(d2) < 0;
	}
	
	function toName(direction) {
	  return names().find(function (name) {
	    return ALL[name].equals(direction);
	  });
	}
	
	function toDirection(name) {
	  return ALL[name];
	}

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(43);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(46);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(47);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(48);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(71);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(78);
	
	var Record = _require.Record;
	
	var Chance = __webpack_require__(81);
	
	var Vector = __webpack_require__(42);
	
	var GameStatus = __webpack_require__(86);
	var Snake = __webpack_require__(87);
	
	var EMPTY = 0;
	var SNAKE = 1;
	var GOAL = 2;
	
	var chance = new Chance();
	
	var SnakeGameRecord = Record({
	  rows: undefined,
	  cols: undefined,
	  goal: undefined,
	  snake: undefined,
	  status: new GameStatus()
	});
	
	var SnakeGame = function (_SnakeGameRecord) {
	  (0, _inherits3.default)(SnakeGame, _SnakeGameRecord);
	
	  function SnakeGame() {
	    (0, _classCallCheck3.default)(this, SnakeGame);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SnakeGame).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(SnakeGame, [{
	    key: 'isTraversable',
	
	
	    /**
	     * Returns if the given tile can be *safely* moved into by the snake
	     * This means that there is no other part of the snake on this tile
	     * and that the position is not out of bounds
	     */
	    value: function isTraversable(_ref) {
	      var x = _ref.x;
	      var y = _ref.y;
	
	      return !this.isOutOfBounds({ x: x, y: y }) && !this.isSnake({ x: x, y: y });
	    }
	  }, {
	    key: 'isSnake',
	    value: function isSnake(_ref2) {
	      var x = _ref2.x;
	      var y = _ref2.y;
	
	      return this.snake.contains({ x: x, y: y });
	    }
	  }, {
	    key: 'isGoal',
	    value: function isGoal(_ref3) {
	      var x = _ref3.x;
	      var y = _ref3.y;
	
	      return this.goal ? this.goal.equals(new Vector({ x: x, y: y })) : false;
	    }
	  }, {
	    key: 'isOutOfBounds',
	    value: function isOutOfBounds(_ref4) {
	      var x = _ref4.x;
	      var y = _ref4.y;
	
	      return x < 0 || y < 0 || x >= this.cols || y >= this.rows;
	    }
	  }, {
	    key: 'placeSnake',
	    value: function placeSnake(_ref5) {
	      var x = _ref5.x;
	      var y = _ref5.y;
	
	      return this.set('snake', Snake.fromStartPosition({ x: x, y: y }));
	    }
	  }, {
	    key: 'placeRandomGoal',
	    value: function placeRandomGoal() {
	      if (this.isFull) {
	        return this.set('goal', null);
	      }
	
	      var goal = void 0;
	      do {
	        goal = new Vector({
	          x: chance.integer({ min: 0, max: this.cols - 1 }),
	          y: chance.integer({ min: 0, max: this.rows - 1 })
	        });
	      } while (this.isSnake(goal));
	
	      return this.placeGoal(goal);
	    }
	  }, {
	    key: 'placeGoal',
	    value: function placeGoal(goal) {
	      return this.set('goal', goal);
	    }
	  }, {
	    key: 'isFull',
	    get: function get() {
	      return this.snake.length >= this.rows * this.cols;
	    }
	  }], [{
	    key: 'fromDimensions',
	    value: function fromDimensions(_ref6) {
	      var rows = _ref6.rows;
	      var cols = _ref6.cols;
	
	      return new SnakeGame({
	        rows: rows,
	        cols: cols
	      }).placeSnake({
	        x: Math.floor(cols / 2),
	        y: Math.floor(rows / 2)
	      });
	    }
	  }]);
	  return SnakeGame;
	}(SnakeGameRecord);
	
	module.exports = SnakeGame;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Buffer) {//  Chance.js 1.0.3
	//  http://chancejs.com
	//  (c) 2013 Victor Quinn
	//  Chance may be freely distributed or modified under the MIT license.
	
	(function () {
	
	    // Constants
	    var MAX_INT = 9007199254740992;
	    var MIN_INT = -MAX_INT;
	    var NUMBERS = '0123456789';
	    var CHARS_LOWER = 'abcdefghijklmnopqrstuvwxyz';
	    var CHARS_UPPER = CHARS_LOWER.toUpperCase();
	    var HEX_POOL  = NUMBERS + "abcdef";
	
	    // Cached array helpers
	    var slice = Array.prototype.slice;
	
	    // Constructor
	    function Chance (seed) {
	        if (!(this instanceof Chance)) {
	            return seed == null ? new Chance() : new Chance(seed);
	        }
	
	        // if user has provided a function, use that as the generator
	        if (typeof seed === 'function') {
	            this.random = seed;
	            return this;
	        }
	
	        if (arguments.length) {
	            // set a starting value of zero so we can add to it
	            this.seed = 0;
	        }
	
	        // otherwise, leave this.seed blank so that MT will receive a blank
	
	        for (var i = 0; i < arguments.length; i++) {
	            var seedling = 0;
	            if (Object.prototype.toString.call(arguments[i]) === '[object String]') {
	                for (var j = 0; j < arguments[i].length; j++) {
	                    // create a numeric hash for each argument, add to seedling
	                    var hash = 0;
	                    for (var k = 0; k < arguments[i].length; k++) {
	                        hash = arguments[i].charCodeAt(k) + (hash << 6) + (hash << 16) - hash;
	                    }
	                    seedling += hash;
	                }
	            } else {
	                seedling = arguments[i];
	            }
	            this.seed += (arguments.length - i) * seedling;
	        }
	
	        // If no generator function was provided, use our MT
	        this.mt = this.mersenne_twister(this.seed);
	        this.bimd5 = this.blueimp_md5();
	        this.random = function () {
	            return this.mt.random(this.seed);
	        };
	
	        return this;
	    }
	
	    Chance.prototype.VERSION = "1.0.3";
	
	    // Random helper functions
	    function initOptions(options, defaults) {
	        options || (options = {});
	
	        if (defaults) {
	            for (var i in defaults) {
	                if (typeof options[i] === 'undefined') {
	                    options[i] = defaults[i];
	                }
	            }
	        }
	
	        return options;
	    }
	
	    function testRange(test, errorMessage) {
	        if (test) {
	            throw new RangeError(errorMessage);
	        }
	    }
	
	    /**
	     * Encode the input string with Base64.
	     */
	    var base64 = function() {
	        throw new Error('No Base64 encoder available.');
	    };
	
	    // Select proper Base64 encoder.
	    (function determineBase64Encoder() {
	        if (typeof btoa === 'function') {
	            base64 = btoa;
	        } else if (typeof Buffer === 'function') {
	            base64 = function(input) {
	                return new Buffer(input).toString('base64');
	            };
	        }
	    })();
	
	    // -- Basics --
	
	    /**
	     *  Return a random bool, either true or false
	     *
	     *  @param {Object} [options={ likelihood: 50 }] alter the likelihood of
	     *    receiving a true or false value back.
	     *  @throws {RangeError} if the likelihood is out of bounds
	     *  @returns {Bool} either true or false
	     */
	    Chance.prototype.bool = function (options) {
	        // likelihood of success (true)
	        options = initOptions(options, {likelihood : 50});
	
	        // Note, we could get some minor perf optimizations by checking range
	        // prior to initializing defaults, but that makes code a bit messier
	        // and the check more complicated as we have to check existence of
	        // the object then existence of the key before checking constraints.
	        // Since the options initialization should be minor computationally,
	        // decision made for code cleanliness intentionally. This is mentioned
	        // here as it's the first occurrence, will not be mentioned again.
	        testRange(
	            options.likelihood < 0 || options.likelihood > 100,
	            "Chance: Likelihood accepts values from 0 to 100."
	        );
	
	        return this.random() * 100 < options.likelihood;
	    };
	
	    /**
	     *  Return a random character.
	     *
	     *  @param {Object} [options={}] can specify a character pool, only alpha,
	     *    only symbols, and casing (lower or upper)
	     *  @returns {String} a single random character
	     *  @throws {RangeError} Can only specify alpha or symbols, not both
	     */
	    Chance.prototype.character = function (options) {
	        options = initOptions(options);
	        testRange(
	            options.alpha && options.symbols,
	            "Chance: Cannot specify both alpha and symbols."
	        );
	
	        var symbols = "!@#$%^&*()[]",
	            letters, pool;
	
	        if (options.casing === 'lower') {
	            letters = CHARS_LOWER;
	        } else if (options.casing === 'upper') {
	            letters = CHARS_UPPER;
	        } else {
	            letters = CHARS_LOWER + CHARS_UPPER;
	        }
	
	        if (options.pool) {
	            pool = options.pool;
	        } else if (options.alpha) {
	            pool = letters;
	        } else if (options.symbols) {
	            pool = symbols;
	        } else {
	            pool = letters + NUMBERS + symbols;
	        }
	
	        return pool.charAt(this.natural({max: (pool.length - 1)}));
	    };
	
	    // Note, wanted to use "float" or "double" but those are both JS reserved words.
	
	    // Note, fixed means N OR LESS digits after the decimal. This because
	    // It could be 14.9000 but in JavaScript, when this is cast as a number,
	    // the trailing zeroes are dropped. Left to the consumer if trailing zeroes are
	    // needed
	    /**
	     *  Return a random floating point number
	     *
	     *  @param {Object} [options={}] can specify a fixed precision, min, max
	     *  @returns {Number} a single floating point number
	     *  @throws {RangeError} Can only specify fixed or precision, not both. Also
	     *    min cannot be greater than max
	     */
	    Chance.prototype.floating = function (options) {
	        options = initOptions(options, {fixed : 4});
	        testRange(
	            options.fixed && options.precision,
	            "Chance: Cannot specify both fixed and precision."
	        );
	
	        var num;
	        var fixed = Math.pow(10, options.fixed);
	
	        var max = MAX_INT / fixed;
	        var min = -max;
	
	        testRange(
	            options.min && options.fixed && options.min < min,
	            "Chance: Min specified is out of range with fixed. Min should be, at least, " + min
	        );
	        testRange(
	            options.max && options.fixed && options.max > max,
	            "Chance: Max specified is out of range with fixed. Max should be, at most, " + max
	        );
	
	        options = initOptions(options, { min : min, max : max });
	
	        // Todo - Make this work!
	        // options.precision = (typeof options.precision !== "undefined") ? options.precision : false;
	
	        num = this.integer({min: options.min * fixed, max: options.max * fixed});
	        var num_fixed = (num / fixed).toFixed(options.fixed);
	
	        return parseFloat(num_fixed);
	    };
	
	    /**
	     *  Return a random integer
	     *
	     *  NOTE the max and min are INCLUDED in the range. So:
	     *  chance.integer({min: 1, max: 3});
	     *  would return either 1, 2, or 3.
	     *
	     *  @param {Object} [options={}] can specify a min and/or max
	     *  @returns {Number} a single random integer number
	     *  @throws {RangeError} min cannot be greater than max
	     */
	    Chance.prototype.integer = function (options) {
	        // 9007199254740992 (2^53) is the max integer number in JavaScript
	        // See: http://vq.io/132sa2j
	        options = initOptions(options, {min: MIN_INT, max: MAX_INT});
	        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");
	
	        return Math.floor(this.random() * (options.max - options.min + 1) + options.min);
	    };
	
	    /**
	     *  Return a random natural
	     *
	     *  NOTE the max and min are INCLUDED in the range. So:
	     *  chance.natural({min: 1, max: 3});
	     *  would return either 1, 2, or 3.
	     *
	     *  @param {Object} [options={}] can specify a min and/or max
	     *  @returns {Number} a single random integer number
	     *  @throws {RangeError} min cannot be greater than max
	     */
	    Chance.prototype.natural = function (options) {
	        options = initOptions(options, {min: 0, max: MAX_INT});
	        testRange(options.min < 0, "Chance: Min cannot be less than zero.");
	        return this.integer(options);
	    };
	
	    /**
	     *  Return a random string
	     *
	     *  @param {Object} [options={}] can specify a length
	     *  @returns {String} a string of random length
	     *  @throws {RangeError} length cannot be less than zero
	     */
	    Chance.prototype.string = function (options) {
	        options = initOptions(options, { length: this.natural({min: 5, max: 20}) });
	        testRange(options.length < 0, "Chance: Length cannot be less than zero.");
	        var length = options.length,
	            text = this.n(this.character, length, options);
	
	        return text.join("");
	    };
	
	    // -- End Basics --
	
	    // -- Helpers --
	
	    Chance.prototype.capitalize = function (word) {
	        return word.charAt(0).toUpperCase() + word.substr(1);
	    };
	
	    Chance.prototype.mixin = function (obj) {
	        for (var func_name in obj) {
	            Chance.prototype[func_name] = obj[func_name];
	        }
	        return this;
	    };
	
	    /**
	     *  Given a function that generates something random and a number of items to generate,
	     *    return an array of items where none repeat.
	     *
	     *  @param {Function} fn the function that generates something random
	     *  @param {Number} num number of terms to generate
	     *  @param {Object} options any options to pass on to the generator function
	     *  @returns {Array} an array of length `num` with every item generated by `fn` and unique
	     *
	     *  There can be more parameters after these. All additional parameters are provided to the given function
	     */
	    Chance.prototype.unique = function(fn, num, options) {
	        testRange(
	            typeof fn !== "function",
	            "Chance: The first argument must be a function."
	        );
	
	        var comparator = function(arr, val) { return arr.indexOf(val) !== -1; };
	
	        if (options) {
	            comparator = options.comparator || comparator;
	        }
	
	        var arr = [], count = 0, result, MAX_DUPLICATES = num * 50, params = slice.call(arguments, 2);
	
	        while (arr.length < num) {
	            var clonedParams = JSON.parse(JSON.stringify(params));
	            result = fn.apply(this, clonedParams);
	            if (!comparator(arr, result)) {
	                arr.push(result);
	                // reset count when unique found
	                count = 0;
	            }
	
	            if (++count > MAX_DUPLICATES) {
	                throw new RangeError("Chance: num is likely too large for sample set");
	            }
	        }
	        return arr;
	    };
	
	    /**
	     *  Gives an array of n random terms
	     *
	     *  @param {Function} fn the function that generates something random
	     *  @param {Number} n number of terms to generate
	     *  @returns {Array} an array of length `n` with items generated by `fn`
	     *
	     *  There can be more parameters after these. All additional parameters are provided to the given function
	     */
	    Chance.prototype.n = function(fn, n) {
	        testRange(
	            typeof fn !== "function",
	            "Chance: The first argument must be a function."
	        );
	
	        if (typeof n === 'undefined') {
	            n = 1;
	        }
	        var i = n, arr = [], params = slice.call(arguments, 2);
	
	        // Providing a negative count should result in a noop.
	        i = Math.max( 0, i );
	
	        for (null; i--; null) {
	            arr.push(fn.apply(this, params));
	        }
	
	        return arr;
	    };
	
	    // H/T to SO for this one: http://vq.io/OtUrZ5
	    Chance.prototype.pad = function (number, width, pad) {
	        // Default pad to 0 if none provided
	        pad = pad || '0';
	        // Convert number to a string
	        number = number + '';
	        return number.length >= width ? number : new Array(width - number.length + 1).join(pad) + number;
	    };
	
	    // DEPRECATED on 2015-10-01
	    Chance.prototype.pick = function (arr, count) {
	        if (arr.length === 0) {
	            throw new RangeError("Chance: Cannot pick() from an empty array");
	        }
	        if (!count || count === 1) {
	            return arr[this.natural({max: arr.length - 1})];
	        } else {
	            return this.shuffle(arr).slice(0, count);
	        }
	    };
	
	    // Given an array, returns a single random element
	    Chance.prototype.pickone = function (arr) {
	        if (arr.length === 0) {
	          throw new RangeError("Chance: Cannot pickone() from an empty array");
	        }
	        return arr[this.natural({max: arr.length - 1})];
	    };
	
	    // Given an array, returns a random set with 'count' elements
	    Chance.prototype.pickset = function (arr, count) {
	        if (count === 0) {
	            return [];
	        }
	        if (arr.length === 0) {
	            throw new RangeError("Chance: Cannot pickset() from an empty array");
	        }
	        if (count < 0) {
	            throw new RangeError("Chance: count must be positive number");
	        }
	        if (!count || count === 1) {
	            return [ this.pickone(arr) ];
	        } else {
	            return this.shuffle(arr).slice(0, count);
	        }
	    };
	
	    Chance.prototype.shuffle = function (arr) {
	        var old_array = arr.slice(0),
	            new_array = [],
	            j = 0,
	            length = Number(old_array.length);
	
	        for (var i = 0; i < length; i++) {
	            // Pick a random index from the array
	            j = this.natural({max: old_array.length - 1});
	            // Add it to the new array
	            new_array[i] = old_array[j];
	            // Remove that element from the original array
	            old_array.splice(j, 1);
	        }
	
	        return new_array;
	    };
	
	    // Returns a single item from an array with relative weighting of odds
	    Chance.prototype.weighted = function (arr, weights, trim) {
	        if (arr.length !== weights.length) {
	            throw new RangeError("Chance: length of array and weights must match");
	        }
	
	        // scan weights array and sum valid entries
	        var sum = 0;
	        var val;
	        for (var weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
	            val = weights[weightIndex];
	            if (val > 0) {
	                sum += val;
	            }
	        }
	
	        if (sum === 0) {
	            throw new RangeError("Chance: no valid entries in array weights");
	        }
	
	        // select a value within range
	        var selected = this.random() * sum;
	
	        // find array entry corresponding to selected value
	        var total = 0;
	        var lastGoodIdx = -1;
	        var chosenIdx;
	        for (weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
	            val = weights[weightIndex];
	            total += val;
	            if (val > 0) {
	                if (selected <= total) {
	                    chosenIdx = weightIndex;
	                    break;
	                }
	                lastGoodIdx = weightIndex;
	            }
	
	            // handle any possible rounding error comparison to ensure something is picked
	            if (weightIndex === (weights.length - 1)) {
	                chosenIdx = lastGoodIdx;
	            }
	        }
	
	        var chosen = arr[chosenIdx];
	        trim = (typeof trim === 'undefined') ? false : trim;
	        if (trim) {
	            arr.splice(chosenIdx, 1);
	            weights.splice(chosenIdx, 1);
	        }
	
	        return chosen;
	    };
	
	    // -- End Helpers --
	
	    // -- Text --
	
	    Chance.prototype.paragraph = function (options) {
	        options = initOptions(options);
	
	        var sentences = options.sentences || this.natural({min: 3, max: 7}),
	            sentence_array = this.n(this.sentence, sentences);
	
	        return sentence_array.join(' ');
	    };
	
	    // Could get smarter about this than generating random words and
	    // chaining them together. Such as: http://vq.io/1a5ceOh
	    Chance.prototype.sentence = function (options) {
	        options = initOptions(options);
	
	        var words = options.words || this.natural({min: 12, max: 18}),
	            punctuation = options.punctuation,
	            text, word_array = this.n(this.word, words);
	
	        text = word_array.join(' ');
	        
	        // Capitalize first letter of sentence
	        text = this.capitalize(text);
	        
	        // Make sure punctuation has a usable value
	        if (punctuation !== false && !/^[\.\?;!:]$/.test(punctuation)) {
	            punctuation = '.';
	        }
	        
	        // Add punctuation mark
	        if (punctuation) {
	            text += punctuation;
	        }
	
	        return text;
	    };
	
	    Chance.prototype.syllable = function (options) {
	        options = initOptions(options);
	
	        var length = options.length || this.natural({min: 2, max: 3}),
	            consonants = 'bcdfghjklmnprstvwz', // consonants except hard to speak ones
	            vowels = 'aeiou', // vowels
	            all = consonants + vowels, // all
	            text = '',
	            chr;
	
	        // I'm sure there's a more elegant way to do this, but this works
	        // decently well.
	        for (var i = 0; i < length; i++) {
	            if (i === 0) {
	                // First character can be anything
	                chr = this.character({pool: all});
	            } else if (consonants.indexOf(chr) === -1) {
	                // Last character was a vowel, now we want a consonant
	                chr = this.character({pool: consonants});
	            } else {
	                // Last character was a consonant, now we want a vowel
	                chr = this.character({pool: vowels});
	            }
	
	            text += chr;
	        }
	
	        if (options.capitalize) {
	            text = this.capitalize(text);
	        }
	
	        return text;
	    };
	
	    Chance.prototype.word = function (options) {
	        options = initOptions(options);
	
	        testRange(
	            options.syllables && options.length,
	            "Chance: Cannot specify both syllables AND length."
	        );
	
	        var syllables = options.syllables || this.natural({min: 1, max: 3}),
	            text = '';
	
	        if (options.length) {
	            // Either bound word by length
	            do {
	                text += this.syllable();
	            } while (text.length < options.length);
	            text = text.substring(0, options.length);
	        } else {
	            // Or by number of syllables
	            for (var i = 0; i < syllables; i++) {
	                text += this.syllable();
	            }
	        }
	
	        if (options.capitalize) {
	            text = this.capitalize(text);
	        }
	
	        return text;
	    };
	
	    // -- End Text --
	
	    // -- Person --
	
	    Chance.prototype.age = function (options) {
	        options = initOptions(options);
	        var ageRange;
	
	        switch (options.type) {
	            case 'child':
	                ageRange = {min: 1, max: 12};
	                break;
	            case 'teen':
	                ageRange = {min: 13, max: 19};
	                break;
	            case 'adult':
	                ageRange = {min: 18, max: 65};
	                break;
	            case 'senior':
	                ageRange = {min: 65, max: 100};
	                break;
	            case 'all':
	                ageRange = {min: 1, max: 100};
	                break;
	            default:
	                ageRange = {min: 18, max: 65};
	                break;
	        }
	
	        return this.natural(ageRange);
	    };
	
	    Chance.prototype.birthday = function (options) {
	        options = initOptions(options, {
	            year: (new Date().getFullYear() - this.age(options))
	        });
	
	        return this.date(options);
	    };
	
	    // CPF; ID to identify taxpayers in Brazil
	    Chance.prototype.cpf = function () {
	        var n = this.n(this.natural, 9, { max: 9 });
	        var d1 = n[8]*2+n[7]*3+n[6]*4+n[5]*5+n[4]*6+n[3]*7+n[2]*8+n[1]*9+n[0]*10;
	        d1 = 11 - (d1 % 11);
	        if (d1>=10) {
	            d1 = 0;
	        }
	        var d2 = d1*2+n[8]*3+n[7]*4+n[6]*5+n[5]*6+n[4]*7+n[3]*8+n[2]*9+n[1]*10+n[0]*11;
	        d2 = 11 - (d2 % 11);
	        if (d2>=10) {
	            d2 = 0;
	        }
	        return ''+n[0]+n[1]+n[2]+'.'+n[3]+n[4]+n[5]+'.'+n[6]+n[7]+n[8]+'-'+d1+d2;
	    };
	
	    // CNPJ: ID to identify companies in Brazil
	    Chance.prototype.cnpj = function () {
	        var n = this.n(this.natural, 12, { max: 12 });
	        var d1 = n[11]*2+n[10]*3+n[9]*4+n[8]*5+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
	        d1 = 11 - (d1 % 11);
	        if (d1<2) {
	            d1 = 0;
	        }
	        var d2 = d1*2+n[11]*3+n[10]*4+n[9]*5+n[8]*6+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
	        d2 = 11 - (d2 % 11);
	        if (d2<2) {
	            d2 = 0;
	        }
	        return ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/'+n[8]+n[9]+n[10]+n[11]+'-'+d1+d2;
	    };
	
	    Chance.prototype.first = function (options) {
	        options = initOptions(options, {gender: this.gender(), nationality: 'en'});
	        return this.pick(this.get("firstNames")[options.gender.toLowerCase()][options.nationality.toLowerCase()]);
	    };
	
	    Chance.prototype.gender = function () {
	        return this.pick(['Male', 'Female']);
	    };
	
	    Chance.prototype.last = function (options) {
	        options = initOptions(options, {nationality: 'en'});
	        return this.pick(this.get("lastNames")[options.nationality.toLowerCase()]);
	    };
	    
	    Chance.prototype.israelId=function(){
	        var x=this.string({pool: '0123456789',length:8});
	        var y=0;
	        for (var i=0;i<x.length;i++){
	            var thisDigit=  x[i] *  (i/2===parseInt(i/2) ? 1 : 2);
	            thisDigit=this.pad(thisDigit,2).toString();
	            thisDigit=parseInt(thisDigit[0]) + parseInt(thisDigit[1]);
	            y=y+thisDigit;
	        }
	        x=x+(10-parseInt(y.toString().slice(-1))).toString().slice(-1);
	        return x;
	    };
	
	    Chance.prototype.mrz = function (options) {
	        var checkDigit = function (input) {
	            var alpha = "<ABCDEFGHIJKLMNOPQRSTUVWXYXZ".split(''),
	                multipliers = [ 7, 3, 1 ],
	                runningTotal = 0;
	
	            if (typeof input !== 'string') {
	                input = input.toString();
	            }
	
	            input.split('').forEach(function(character, idx) {
	                var pos = alpha.indexOf(character);
	
	                if(pos !== -1) {
	                    character = pos === 0 ? 0 : pos + 9;
	                } else {
	                    character = parseInt(character, 10);
	                }
	                character *= multipliers[idx % multipliers.length];
	                runningTotal += character;
	            });
	            return runningTotal % 10;
	        };
	        var generate = function (opts) {
	            var pad = function (length) {
	                return new Array(length + 1).join('<');
	            };
	            var number = [ 'P<',
	                           opts.issuer,
	                           opts.last.toUpperCase(),
	                           '<<',
	                           opts.first.toUpperCase(),
	                           pad(39 - (opts.last.length + opts.first.length + 2)),
	                           opts.passportNumber,
	                           checkDigit(opts.passportNumber),
	                           opts.nationality,
	                           opts.dob,
	                           checkDigit(opts.dob),
	                           opts.gender,
	                           opts.expiry,
	                           checkDigit(opts.expiry),
	                           pad(14),
	                           checkDigit(pad(14)) ].join('');
	
	            return number +
	                (checkDigit(number.substr(44, 10) +
	                            number.substr(57, 7) +
	                            number.substr(65, 7)));
	        };
	
	        var that = this;
	
	        options = initOptions(options, {
	            first: this.first(),
	            last: this.last(),
	            passportNumber: this.integer({min: 100000000, max: 999999999}),
	            dob: (function () {
	                var date = that.birthday({type: 'adult'});
	                return [date.getFullYear().toString().substr(2),
	                        that.pad(date.getMonth() + 1, 2),
	                        that.pad(date.getDate(), 2)].join('');
	            }()),
	            expiry: (function () {
	                var date = new Date();
	                return [(date.getFullYear() + 5).toString().substr(2),
	                        that.pad(date.getMonth() + 1, 2),
	                        that.pad(date.getDate(), 2)].join('');
	            }()),
	            gender: this.gender() === 'Female' ? 'F': 'M',
	            issuer: 'GBR',
	            nationality: 'GBR'
	        });
	        return generate (options);
	    };
	
	    Chance.prototype.name = function (options) {
	        options = initOptions(options);
	
	        var first = this.first(options),
	            last = this.last(options),
	            name;
	
	        if (options.middle) {
	            name = first + ' ' + this.first(options) + ' ' + last;
	        } else if (options.middle_initial) {
	            name = first + ' ' + this.character({alpha: true, casing: 'upper'}) + '. ' + last;
	        } else {
	            name = first + ' ' + last;
	        }
	
	        if (options.prefix) {
	            name = this.prefix(options) + ' ' + name;
	        }
	
	        if (options.suffix) {
	            name = name + ' ' + this.suffix(options);
	        }
	
	        return name;
	    };
	
	    // Return the list of available name prefixes based on supplied gender.
	    // @todo introduce internationalization
	    Chance.prototype.name_prefixes = function (gender) {
	        gender = gender || "all";
	        gender = gender.toLowerCase();
	
	        var prefixes = [
	            { name: 'Doctor', abbreviation: 'Dr.' }
	        ];
	
	        if (gender === "male" || gender === "all") {
	            prefixes.push({ name: 'Mister', abbreviation: 'Mr.' });
	        }
	
	        if (gender === "female" || gender === "all") {
	            prefixes.push({ name: 'Miss', abbreviation: 'Miss' });
	            prefixes.push({ name: 'Misses', abbreviation: 'Mrs.' });
	        }
	
	        return prefixes;
	    };
	
	    // Alias for name_prefix
	    Chance.prototype.prefix = function (options) {
	        return this.name_prefix(options);
	    };
	
	    Chance.prototype.name_prefix = function (options) {
	        options = initOptions(options, { gender: "all" });
	        return options.full ?
	            this.pick(this.name_prefixes(options.gender)).name :
	            this.pick(this.name_prefixes(options.gender)).abbreviation;
	    };
	
	    Chance.prototype.ssn = function (options) {
	        options = initOptions(options, {ssnFour: false, dashes: true});
	        var ssn_pool = "1234567890",
	            ssn,
	            dash = options.dashes ? '-' : '';
	
	        if(!options.ssnFour) {
	            ssn = this.string({pool: ssn_pool, length: 3}) + dash +
	            this.string({pool: ssn_pool, length: 2}) + dash +
	            this.string({pool: ssn_pool, length: 4});
	        } else {
	            ssn = this.string({pool: ssn_pool, length: 4});
	        }
	        return ssn;
	    };
	
	    // Return the list of available name suffixes
	    // @todo introduce internationalization
	    Chance.prototype.name_suffixes = function () {
	        var suffixes = [
	            { name: 'Doctor of Osteopathic Medicine', abbreviation: 'D.O.' },
	            { name: 'Doctor of Philosophy', abbreviation: 'Ph.D.' },
	            { name: 'Esquire', abbreviation: 'Esq.' },
	            { name: 'Junior', abbreviation: 'Jr.' },
	            { name: 'Juris Doctor', abbreviation: 'J.D.' },
	            { name: 'Master of Arts', abbreviation: 'M.A.' },
	            { name: 'Master of Business Administration', abbreviation: 'M.B.A.' },
	            { name: 'Master of Science', abbreviation: 'M.S.' },
	            { name: 'Medical Doctor', abbreviation: 'M.D.' },
	            { name: 'Senior', abbreviation: 'Sr.' },
	            { name: 'The Third', abbreviation: 'III' },
	            { name: 'The Fourth', abbreviation: 'IV' },
	            { name: 'Bachelor of Engineering', abbreviation: 'B.E' },
	            { name: 'Bachelor of Technology', abbreviation: 'B.TECH' }
	        ];
	        return suffixes;
	    };
	
	    // Alias for name_suffix
	    Chance.prototype.suffix = function (options) {
	        return this.name_suffix(options);
	    };
	
	    Chance.prototype.name_suffix = function (options) {
	        options = initOptions(options);
	        return options.full ?
	            this.pick(this.name_suffixes()).name :
	            this.pick(this.name_suffixes()).abbreviation;
	    };
	
	    Chance.prototype.nationalities = function () {
	        return this.get("nationalities");
	    };
	
	    // Generate random nationality based on json list
	    Chance.prototype.nationality = function () {
	        var nationality = this.pick(this.nationalities());
	        return nationality.name;
	    };
	
	    // -- End Person --
	
	    // -- Mobile --
	    // Android GCM Registration ID
	    Chance.prototype.android_id = function () {
	        return "APA91" + this.string({ pool: "0123456789abcefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_", length: 178 });
	    };
	
	    // Apple Push Token
	    Chance.prototype.apple_token = function () {
	        return this.string({ pool: "abcdef1234567890", length: 64 });
	    };
	
	    // Windows Phone 8 ANID2
	    Chance.prototype.wp8_anid2 = function () {
	        return base64( this.hash( { length : 32 } ) );
	    };
	
	    // Windows Phone 7 ANID
	    Chance.prototype.wp7_anid = function () {
	        return 'A=' + this.guid().replace(/-/g, '').toUpperCase() + '&E=' + this.hash({ length:3 }) + '&W=' + this.integer({ min:0, max:9 });
	    };
	
	    // BlackBerry Device PIN
	    Chance.prototype.bb_pin = function () {
	        return this.hash({ length: 8 });
	    };
	
	    // -- End Mobile --
	
	    // -- Web --
	    Chance.prototype.avatar = function (options) {
	        var url = null;
	        var URL_BASE = '//www.gravatar.com/avatar/';
	        var PROTOCOLS = {
	            http: 'http',
	            https: 'https'
	        };
	        var FILE_TYPES = {
	            bmp: 'bmp',
	            gif: 'gif',
	            jpg: 'jpg',
	            png: 'png'
	        };
	        var FALLBACKS = {
	            '404': '404', // Return 404 if not found
	            mm: 'mm', // Mystery man
	            identicon: 'identicon', // Geometric pattern based on hash
	            monsterid: 'monsterid', // A generated monster icon
	            wavatar: 'wavatar', // A generated face
	            retro: 'retro', // 8-bit icon
	            blank: 'blank' // A transparent png
	        };
	        var RATINGS = {
	            g: 'g',
	            pg: 'pg',
	            r: 'r',
	            x: 'x'
	        };
	        var opts = {
	            protocol: null,
	            email: null,
	            fileExtension: null,
	            size: null,
	            fallback: null,
	            rating: null
	        };
	
	        if (!options) {
	            // Set to a random email
	            opts.email = this.email();
	            options = {};
	        }
	        else if (typeof options === 'string') {
	            opts.email = options;
	            options = {};
	        }
	        else if (typeof options !== 'object') {
	            return null;
	        }
	        else if (options.constructor === 'Array') {
	            return null;
	        }
	
	        opts = initOptions(options, opts);
	
	        if (!opts.email) {
	            // Set to a random email
	            opts.email = this.email();
	        }
	
	        // Safe checking for params
	        opts.protocol = PROTOCOLS[opts.protocol] ? opts.protocol + ':' : '';
	        opts.size = parseInt(opts.size, 0) ? opts.size : '';
	        opts.rating = RATINGS[opts.rating] ? opts.rating : '';
	        opts.fallback = FALLBACKS[opts.fallback] ? opts.fallback : '';
	        opts.fileExtension = FILE_TYPES[opts.fileExtension] ? opts.fileExtension : '';
	
	        url =
	            opts.protocol +
	            URL_BASE +
	            this.bimd5.md5(opts.email) +
	            (opts.fileExtension ? '.' + opts.fileExtension : '') +
	            (opts.size || opts.rating || opts.fallback ? '?' : '') +
	            (opts.size ? '&s=' + opts.size.toString() : '') +
	            (opts.rating ? '&r=' + opts.rating : '') +
	            (opts.fallback ? '&d=' + opts.fallback : '')
	            ;
	
	        return url;
	    };
	
	    /**
	     * #Description:
	     * ===============================================
	     * Generate random color value base on color type:
	     * -> hex
	     * -> rgb
	     * -> rgba
	     * -> 0x
	     * -> named color
	     *
	     * #Examples: 
	     * ===============================================
	     * * Geerate random hex color
	     * chance.color() => '#79c157' / 'rgb(110,52,164)' / '0x67ae0b' / '#e2e2e2' / '#29CFA7'
	     * 
	     * * Generate Hex based color value
	     * chance.color({format: 'hex'})    => '#d67118'
	     *
	     * * Generate simple rgb value
	     * chance.color({format: 'rgb'})    => 'rgb(110,52,164)'
	     *
	     * * Generate Ox based color value
	     * chance.color({format: '0x'})     => '0x67ae0b' 
	     *
	     * * Generate graiscale based value
	     * chance.color({grayscale: true})  => '#e2e2e2'
	     *
	     * * Return valide color name
	     * chance.color({format: 'name'})   => 'red'
	     * 
	     * * Make color uppercase
	     * chance.color({casing: 'upper'})  => '#29CFA7'
	     *
	     * @param  [object] options
	     * @return [string] color value
	     */
	    Chance.prototype.color = function (options) {
	
	        function gray(value, delimiter) {
	            return [value, value, value].join(delimiter || '');
	        }
	
	        function rgb(hasAlpha) {
	
	            var rgbValue    = (hasAlpha)    ? 'rgba' : 'rgb'; 
	            var alphaChanal = (hasAlpha)    ? (',' + this.floating({min:0, max:1})) : "";
	            var colorValue  = (isGrayscale) ? (gray(this.natural({max: 255}), ',')) : (this.natural({max: 255}) + ',' + this.natural({max: 255}) + ',' + this.natural({max: 255}));
	
	            return rgbValue + '(' + colorValue + alphaChanal + ')';
	        }
	
	        function hex(start, end, withHash) {
	
	            var simbol = (withHash) ? "#" : "";
	            var expression  = (isGrayscale ? gray(this.hash({length: start})) : this.hash({length: end})); 
	            return simbol + expression;
	        }
	
	        options = initOptions(options, {
	            format: this.pick(['hex', 'shorthex', 'rgb', 'rgba', '0x', 'name']),
	            grayscale: false,
	            casing: 'lower'
	        });
	
	        var isGrayscale = options.grayscale;
	        var colorValue;
	
	        if (options.format === 'hex') {
	            colorValue =  hex.call(this, 2, 6, true);
	        }
	        else if (options.format === 'shorthex') {
	            colorValue = hex.call(this, 1, 3, true);
	        } 
	        else if (options.format === 'rgb') {
	            colorValue = rgb.call(this, false);
	        } 
	        else if (options.format === 'rgba') {
	            colorValue = rgb.call(this, true);
	        } 
	        else if (options.format === '0x') {
	            colorValue = '0x' + hex.call(this, 2, 6);
	        } 
	        else if(options.format === 'name') {
	            return this.pick(this.get("colorNames"));
	        }
	        else {
	            throw new RangeError('Invalid format provided. Please provide one of "hex", "shorthex", "rgb", "rgba", "0x" or "name".');
	        }
	
	        if (options.casing === 'upper' ) {
	            colorValue = colorValue.toUpperCase();
	        }
	
	        return colorValue;
	    };
	
	    Chance.prototype.domain = function (options) {
	        options = initOptions(options);
	        return this.word() + '.' + (options.tld || this.tld());
	    };
	
	    Chance.prototype.email = function (options) {
	        options = initOptions(options);
	        return this.word({length: options.length}) + '@' + (options.domain || this.domain());
	    };
	
	    Chance.prototype.fbid = function () {
	        return parseInt('10000' + this.natural({max: 100000000000}), 10);
	    };
	
	    Chance.prototype.google_analytics = function () {
	        var account = this.pad(this.natural({max: 999999}), 6);
	        var property = this.pad(this.natural({max: 99}), 2);
	
	        return 'UA-' + account + '-' + property;
	    };
	
	    Chance.prototype.hashtag = function () {
	        return '#' + this.word();
	    };
	
	    Chance.prototype.ip = function () {
	        // Todo: This could return some reserved IPs. See http://vq.io/137dgYy
	        // this should probably be updated to account for that rare as it may be
	        return this.natural({min: 1, max: 254}) + '.' +
	               this.natural({max: 255}) + '.' +
	               this.natural({max: 255}) + '.' +
	               this.natural({min: 1, max: 254});
	    };
	
	    Chance.prototype.ipv6 = function () {
	        var ip_addr = this.n(this.hash, 8, {length: 4});
	
	        return ip_addr.join(":");
	    };
	
	    Chance.prototype.klout = function () {
	        return this.natural({min: 1, max: 99});
	    };
	
	    Chance.prototype.semver = function (options) {
	        options = initOptions(options, { include_prerelease: true });
	
	        var range = this.pickone(["^", "~", "<", ">", "<=", ">=", "="]);
	        if (options.range) {
	            range = options.range;
	        }
	
	        var prerelease = "";
	        if (options.include_prerelease) {
	            prerelease = this.weighted(["", "-dev", "-beta", "-alpha"], [50, 10, 5, 1]);
	        }
	        return range + this.rpg('3d10').join('.') + prerelease;
	    };
	
	    Chance.prototype.tlds = function () {
	        return ['com', 'org', 'edu', 'gov', 'co.uk', 'net', 'io', 'ac', 'ad', 'ae', 'af', 'ag', 'ai', 'al', 'am', 'an', 'ao', 'aq', 'ar', 'as', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'bj', 'bm', 'bn', 'bo', 'bq', 'br', 'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cc', 'cd', 'cf', 'cg', 'ch', 'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'cr', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'ee', 'eg', 'eh', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'in', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky', 'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly', 'ma', 'mc', 'md', 'me', 'mg', 'mh', 'mk', 'ml', 'mm', 'mn', 'mo', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'nc', 'ne', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'ps', 'pt', 'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'ss', 'st', 'su', 'sv', 'sx', 'sy', 'sz', 'tc', 'td', 'tf', 'tg', 'th', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn', 'vu', 'wf', 'ws', 'ye', 'yt', 'za', 'zm', 'zw'];
	    };
	
	    Chance.prototype.tld = function () {
	        return this.pick(this.tlds());
	    };
	
	    Chance.prototype.twitter = function () {
	        return '@' + this.word();
	    };
	
	    Chance.prototype.url = function (options) {
	        options = initOptions(options, { protocol: "http", domain: this.domain(options), domain_prefix: "", path: this.word(), extensions: []});
	
	        var extension = options.extensions.length > 0 ? "." + this.pick(options.extensions) : "";
	        var domain = options.domain_prefix ? options.domain_prefix + "." + options.domain : options.domain;
	
	        return options.protocol + "://" + domain + "/" + options.path + extension;
	    };
	
	    // -- End Web --
	
	    // -- Location --
	
	    Chance.prototype.address = function (options) {
	        options = initOptions(options);
	        return this.natural({min: 5, max: 2000}) + ' ' + this.street(options);
	    };
	
	    Chance.prototype.altitude = function (options) {
	        options = initOptions(options, {fixed: 5, min: 0, max: 8848});
	        return this.floating({
	            min: options.min,
	            max: options.max,
	            fixed: options.fixed
	        });
	    };
	
	    Chance.prototype.areacode = function (options) {
	        options = initOptions(options, {parens : true});
	        // Don't want area codes to start with 1, or have a 9 as the second digit
	        var areacode = this.natural({min: 2, max: 9}).toString() +
	                this.natural({min: 0, max: 8}).toString() +
	                this.natural({min: 0, max: 9}).toString();
	
	        return options.parens ? '(' + areacode + ')' : areacode;
	    };
	
	    Chance.prototype.city = function () {
	        return this.capitalize(this.word({syllables: 3}));
	    };
	
	    Chance.prototype.coordinates = function (options) {
	        return this.latitude(options) + ', ' + this.longitude(options);
	    };
	
	    Chance.prototype.countries = function () {
	        return this.get("countries");
	    };
	
	    Chance.prototype.country = function (options) {
	        options = initOptions(options);
	        var country = this.pick(this.countries());
	        return options.full ? country.name : country.abbreviation;
	    };
	
	    Chance.prototype.depth = function (options) {
	        options = initOptions(options, {fixed: 5, min: -10994, max: 0});
	        return this.floating({
	            min: options.min,
	            max: options.max,
	            fixed: options.fixed
	        });
	    };
	
	    Chance.prototype.geohash = function (options) {
	        options = initOptions(options, { length: 7 });
	        return this.string({ length: options.length, pool: '0123456789bcdefghjkmnpqrstuvwxyz' });
	    };
	
	    Chance.prototype.geojson = function (options) {
	        return this.latitude(options) + ', ' + this.longitude(options) + ', ' + this.altitude(options);
	    };
	
	    Chance.prototype.latitude = function (options) {
	        options = initOptions(options, {fixed: 5, min: -90, max: 90});
	        return this.floating({min: options.min, max: options.max, fixed: options.fixed});
	    };
	
	    Chance.prototype.longitude = function (options) {
	        options = initOptions(options, {fixed: 5, min: -180, max: 180});
	        return this.floating({min: options.min, max: options.max, fixed: options.fixed});
	    };
	
	    Chance.prototype.phone = function (options) {
	        var self = this,
	            numPick,
	            ukNum = function (parts) {
	                var section = [];
	                //fills the section part of the phone number with random numbers.
	                parts.sections.forEach(function(n) {
	                    section.push(self.string({ pool: '0123456789', length: n}));
	                });
	                return parts.area + section.join(' ');
	            };
	        options = initOptions(options, {
	            formatted: true,
	            country: 'us',
	            mobile: false
	        });
	        if (!options.formatted) {
	            options.parens = false;
	        }
	        var phone;
	        switch (options.country) {
	            case 'fr':
	                if (!options.mobile) {
	                    numPick = this.pick([
	                        // Valid zone and département codes.
	                        '01' + this.pick(['30', '34', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '53', '55', '56', '58', '60', '64', '69', '70', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83']) + self.string({ pool: '0123456789', length: 6}),
	                        '02' + this.pick(['14', '18', '22', '23', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '40', '41', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '56', '57', '61', '62', '69', '72', '76', '77', '78', '85', '90', '96', '97', '98', '99']) + self.string({ pool: '0123456789', length: 6}),
	                        '03' + this.pick(['10', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '39', '44', '45', '51', '52', '54', '55', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90']) + self.string({ pool: '0123456789', length: 6}),
	                        '04' + this.pick(['11', '13', '15', '20', '22', '26', '27', '30', '32', '34', '37', '42', '43', '44', '50', '56', '57', '63', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '88', '89', '90', '91', '92', '93', '94', '95', '97', '98']) + self.string({ pool: '0123456789', length: 6}),
	                        '05' + this.pick(['08', '16', '17', '19', '24', '31', '32', '33', '34', '35', '40', '45', '46', '47', '49', '53', '55', '56', '57', '58', '59', '61', '62', '63', '64', '65', '67', '79', '81', '82', '86', '87', '90', '94']) + self.string({ pool: '0123456789', length: 6}),
	                        '09' + self.string({ pool: '0123456789', length: 8}),
	                    ]);
	                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
	                } else {
	                    numPick = this.pick(['06', '07']) + self.string({ pool: '0123456789', length: 8});
	                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
	                }
	                break;
	            case 'uk':
	                if (!options.mobile) {
	                    numPick = this.pick([
	                        //valid area codes of major cities/counties followed by random numbers in required format.
	                        { area: '01' + this.character({ pool: '234569' }) + '1 ', sections: [3,4] },
	                        { area: '020 ' + this.character({ pool: '378' }), sections: [3,4] },
	                        { area: '023 ' + this.character({ pool: '89' }), sections: [3,4] },
	                        { area: '024 7', sections: [3,4] },
	                        { area: '028 ' + this.pick(['25','28','37','71','82','90','92','95']), sections: [2,4] },
	                        { area: '012' + this.pick(['04','08','54','76','97','98']) + ' ', sections: [5] },
	                        { area: '013' + this.pick(['63','64','84','86']) + ' ', sections: [5] },
	                        { area: '014' + this.pick(['04','20','60','61','80','88']) + ' ', sections: [5] },
	                        { area: '015' + this.pick(['24','27','62','66']) + ' ', sections: [5] },
	                        { area: '016' + this.pick(['06','29','35','47','59','95']) + ' ', sections: [5] },
	                        { area: '017' + this.pick(['26','44','50','68']) + ' ', sections: [5] },
	                        { area: '018' + this.pick(['27','37','84','97']) + ' ', sections: [5] },
	                        { area: '019' + this.pick(['00','05','35','46','49','63','95']) + ' ', sections: [5] }
	                    ]);
	                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '', 'g');
	                } else {
	                    numPick = this.pick([
	                        { area: '07' + this.pick(['4','5','7','8','9']), sections: [2,6] },
	                        { area: '07624 ', sections: [6] }
	                    ]);
	                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '');
	                }
	                break;
	            case 'us':
	                var areacode = this.areacode(options).toString();
	                var exchange = this.natural({ min: 2, max: 9 }).toString() +
	                    this.natural({ min: 0, max: 9 }).toString() +
	                    this.natural({ min: 0, max: 9 }).toString();
	                var subscriber = this.natural({ min: 1000, max: 9999 }).toString(); // this could be random [0-9]{4}
	                phone = options.formatted ? areacode + ' ' + exchange + '-' + subscriber : areacode + exchange + subscriber;
	        }
	        return phone;
	    };
	
	    Chance.prototype.postal = function () {
	        // Postal District
	        var pd = this.character({pool: "XVTSRPNKLMHJGECBA"});
	        // Forward Sortation Area (FSA)
	        var fsa = pd + this.natural({max: 9}) + this.character({alpha: true, casing: "upper"});
	        // Local Delivery Unut (LDU)
	        var ldu = this.natural({max: 9}) + this.character({alpha: true, casing: "upper"}) + this.natural({max: 9});
	
	        return fsa + " " + ldu;
	    };
	
	    Chance.prototype.provinces = function (options) {
	        options = initOptions(options, { country: 'ca' });
	        return this.get("provinces")[options.country.toLowerCase()];
	    };
	
	    Chance.prototype.province = function (options) {
	        return (options && options.full) ?
	            this.pick(this.provinces(options)).name :
	            this.pick(this.provinces(options)).abbreviation;
	    };
	
	    Chance.prototype.state = function (options) {
	        return (options && options.full) ?
	            this.pick(this.states(options)).name :
	            this.pick(this.states(options)).abbreviation;
	    };
	
	    Chance.prototype.states = function (options) {
	        options = initOptions(options, { country: 'us', us_states_and_dc: true } );
	
	        var states;
	
	        switch (options.country.toLowerCase()) {
	            case 'us':
	                var us_states_and_dc = this.get("us_states_and_dc"),
	                    territories = this.get("territories"),
	                    armed_forces = this.get("armed_forces");
	
	                states = [];
	
	                if (options.us_states_and_dc) {
	                    states = states.concat(us_states_and_dc);
	                }
	                if (options.territories) {
	                    states = states.concat(territories);
	                }
	                if (options.armed_forces) {
	                    states = states.concat(armed_forces);
	                }
	                break;
	            case 'it':
	                states = this.get("country_regions")[options.country.toLowerCase()];
	        }
	
	        return states;
	    };
	
	    Chance.prototype.street = function (options) {
	        options = initOptions(options, { country: 'us', syllables: 2 });
	        var     street;
	
	        switch (options.country.toLowerCase()) {
	            case 'us':
	                street = this.word({ syllables: options.syllables });
	                street = this.capitalize(street);
	                street += ' ';
	                street += options.short_suffix ?
	                    this.street_suffix(options).abbreviation :
	                    this.street_suffix(options).name;
	                break;
	            case 'it':
	                street = this.word({ syllables: options.syllables });
	                street = this.capitalize(street);
	                street = (options.short_suffix ?
	                    this.street_suffix(options).abbreviation :
	                    this.street_suffix(options).name) + " " + street;
	                break;
	        }
	        return street;
	    };
	
	    Chance.prototype.street_suffix = function (options) {
	        options = initOptions(options, { country: 'us' });
	        return this.pick(this.street_suffixes(options));
	    };
	
	    Chance.prototype.street_suffixes = function (options) {
	        options = initOptions(options, { country: 'us' });
	        // These are the most common suffixes.
	        return this.get("street_suffixes")[options.country.toLowerCase()];
	    };
	
	    // Note: only returning US zip codes, internationalization will be a whole
	    // other beast to tackle at some point.
	    Chance.prototype.zip = function (options) {
	        var zip = this.n(this.natural, 5, {max: 9});
	
	        if (options && options.plusfour === true) {
	            zip.push('-');
	            zip = zip.concat(this.n(this.natural, 4, {max: 9}));
	        }
	
	        return zip.join("");
	    };
	
	    // -- End Location --
	
	    // -- Time
	
	    Chance.prototype.ampm = function () {
	        return this.bool() ? 'am' : 'pm';
	    };
	
	    Chance.prototype.date = function (options) {
	        var date_string, date;
	
	        // If interval is specified we ignore preset
	        if(options && (options.min || options.max)) {
	            options = initOptions(options, {
	                american: true,
	                string: false
	            });
	            var min = typeof options.min !== "undefined" ? options.min.getTime() : 1;
	            // 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. http://es5.github.io/#x15.9.1.1
	            var max = typeof options.max !== "undefined" ? options.max.getTime() : 8640000000000000;
	
	            date = new Date(this.natural({min: min, max: max}));
	        } else {
	            var m = this.month({raw: true});
	            var daysInMonth = m.days;
	
	            if(options && options.month) {
	                // Mod 12 to allow months outside range of 0-11 (not encouraged, but also not prevented).
	                daysInMonth = this.get('months')[((options.month % 12) + 12) % 12].days;
	            }
	
	            options = initOptions(options, {
	                year: parseInt(this.year(), 10),
	                // Necessary to subtract 1 because Date() 0-indexes month but not day or year
	                // for some reason.
	                month: m.numeric - 1,
	                day: this.natural({min: 1, max: daysInMonth}),
	                hour: this.hour(),
	                minute: this.minute(),
	                second: this.second(),
	                millisecond: this.millisecond(),
	                american: true,
	                string: false
	            });
	
	            date = new Date(options.year, options.month, options.day, options.hour, options.minute, options.second, options.millisecond);
	        }
	
	        if (options.american) {
	            // Adding 1 to the month is necessary because Date() 0-indexes
	            // months but not day for some odd reason.
	            date_string = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
	        } else {
	            date_string = date.getDate() + '/' + (date.getMonth() + 1) + '/' + date.getFullYear();
	        }
	
	        return options.string ? date_string : date;
	    };
	
	    Chance.prototype.hammertime = function (options) {
	        return this.date(options).getTime();
	    };
	
	    Chance.prototype.hour = function (options) {
	        options = initOptions(options, {
	            min: options && options.twentyfour ? 0 : 1,
	            max: options && options.twentyfour ? 23 : 12
	        });
	
	        testRange(options.min < 0, "Chance: Min cannot be less than 0.");
	        testRange(options.twentyfour && options.max > 23, "Chance: Max cannot be greater than 23 for twentyfour option.");
	        testRange(!options.twentyfour && options.max > 12, "Chance: Max cannot be greater than 12.");
	        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");
	
	        return this.natural({min: options.min, max: options.max});
	    };
	
	    Chance.prototype.millisecond = function () {
	        return this.natural({max: 999});
	    };
	
	    Chance.prototype.minute = Chance.prototype.second = function (options) {
	        options = initOptions(options, {min: 0, max: 59});
	
	        testRange(options.min < 0, "Chance: Min cannot be less than 0.");
	        testRange(options.max > 59, "Chance: Max cannot be greater than 59.");
	        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");
	
	        return this.natural({min: options.min, max: options.max});
	    };
	
	    Chance.prototype.month = function (options) {
	        options = initOptions(options, {min: 1, max: 12});
	
	        testRange(options.min < 1, "Chance: Min cannot be less than 1.");
	        testRange(options.max > 12, "Chance: Max cannot be greater than 12.");
	        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");
	
	        var month = this.pick(this.months().slice(options.min - 1, options.max));
	        return options.raw ? month : month.name;
	    };
	
	    Chance.prototype.months = function () {
	        return this.get("months");
	    };
	
	    Chance.prototype.second = function () {
	        return this.natural({max: 59});
	    };
	
	    Chance.prototype.timestamp = function () {
	        return this.natural({min: 1, max: parseInt(new Date().getTime() / 1000, 10)});
	    };
	
	    Chance.prototype.weekday = function (options) {
	        options = initOptions(options, {weekday_only: false});
	        var weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
	        if (!options.weekday_only) {
	            weekdays.push("Saturday");
	            weekdays.push("Sunday");
	        }
	        return this.pickone(weekdays);
	    };
	
	    Chance.prototype.year = function (options) {
	        // Default to current year as min if none specified
	        options = initOptions(options, {min: new Date().getFullYear()});
	
	        // Default to one century after current year as max if none specified
	        options.max = (typeof options.max !== "undefined") ? options.max : options.min + 100;
	
	        return this.natural(options).toString();
	    };
	
	    // -- End Time
	
	    // -- Finance --
	
	    Chance.prototype.cc = function (options) {
	        options = initOptions(options);
	
	        var type, number, to_generate;
	
	        type = (options.type) ?
	                    this.cc_type({ name: options.type, raw: true }) :
	                    this.cc_type({ raw: true });
	
	        number = type.prefix.split("");
	        to_generate = type.length - type.prefix.length - 1;
	
	        // Generates n - 1 digits
	        number = number.concat(this.n(this.integer, to_generate, {min: 0, max: 9}));
	
	        // Generates the last digit according to Luhn algorithm
	        number.push(this.luhn_calculate(number.join("")));
	
	        return number.join("");
	    };
	
	    Chance.prototype.cc_types = function () {
	        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
	        return this.get("cc_types");
	    };
	
	    Chance.prototype.cc_type = function (options) {
	        options = initOptions(options);
	        var types = this.cc_types(),
	            type = null;
	
	        if (options.name) {
	            for (var i = 0; i < types.length; i++) {
	                // Accept either name or short_name to specify card type
	                if (types[i].name === options.name || types[i].short_name === options.name) {
	                    type = types[i];
	                    break;
	                }
	            }
	            if (type === null) {
	                throw new RangeError("Credit card type '" + options.name + "'' is not supported");
	            }
	        } else {
	            type = this.pick(types);
	        }
	
	        return options.raw ? type : type.name;
	    };
	
	    //return all world currency by ISO 4217
	    Chance.prototype.currency_types = function () {
	        return this.get("currency_types");
	    };
	
	    //return random world currency by ISO 4217
	    Chance.prototype.currency = function () {
	        return this.pick(this.currency_types());
	    };
	
	    //Return random correct currency exchange pair (e.g. EUR/USD) or array of currency code
	    Chance.prototype.currency_pair = function (returnAsString) {
	        var currencies = this.unique(this.currency, 2, {
	            comparator: function(arr, val) {
	
	                return arr.reduce(function(acc, item) {
	                    // If a match has been found, short circuit check and just return
	                    return acc || (item.code === val.code);
	                }, false);
	            }
	        });
	
	        if (returnAsString) {
	            return currencies[0].code + '/' + currencies[1].code;
	        } else {
	            return currencies;
	        }
	    };
	
	    Chance.prototype.dollar = function (options) {
	        // By default, a somewhat more sane max for dollar than all available numbers
	        options = initOptions(options, {max : 10000, min : 0});
	
	        var dollar = this.floating({min: options.min, max: options.max, fixed: 2}).toString(),
	            cents = dollar.split('.')[1];
	
	        if (cents === undefined) {
	            dollar += '.00';
	        } else if (cents.length < 2) {
	            dollar = dollar + '0';
	        }
	
	        if (dollar < 0) {
	            return '-$' + dollar.replace('-', '');
	        } else {
	            return '$' + dollar;
	        }
	    };
	
	    Chance.prototype.euro = function (options) {
	        return Number(this.dollar(options).replace("$", "")).toLocaleString() + "€";
	    };
	
	    Chance.prototype.exp = function (options) {
	        options = initOptions(options);
	        var exp = {};
	
	        exp.year = this.exp_year();
	
	        // If the year is this year, need to ensure month is greater than the
	        // current month or this expiration will not be valid
	        if (exp.year === (new Date().getFullYear()).toString()) {
	            exp.month = this.exp_month({future: true});
	        } else {
	            exp.month = this.exp_month();
	        }
	
	        return options.raw ? exp : exp.month + '/' + exp.year;
	    };
	
	    Chance.prototype.exp_month = function (options) {
	        options = initOptions(options);
	        var month, month_int,
	            // Date object months are 0 indexed
	            curMonth = new Date().getMonth() + 1;
	
	        if (options.future && (curMonth !== 12)) {
	            do {
	                month = this.month({raw: true}).numeric;
	                month_int = parseInt(month, 10);
	            } while (month_int <= curMonth);
	        } else {
	            month = this.month({raw: true}).numeric;
	        }
	
	        return month;
	    };
	
	    Chance.prototype.exp_year = function () {
	        var curMonth = new Date().getMonth() + 1,
	            curYear = new Date().getFullYear();
	
	        return this.year({min: ((curMonth === 12) ? (curYear + 1) : curYear), max: (curYear + 10)});
	    };
	
	    Chance.prototype.vat = function (options) {
	        options = initOptions(options, { country: 'it' });
	        switch (options.country.toLowerCase()) {
	            case 'it':
	                return this.it_vat();
	        }
	    };
	
	    // -- End Finance
	
	    // -- Regional
	
	    Chance.prototype.it_vat = function () {
	        var it_vat = this.natural({min: 1, max: 1800000});
	
	        it_vat = this.pad(it_vat, 7) + this.pad(this.pick(this.provinces({ country: 'it' })).code, 3);
	        return it_vat + this.luhn_calculate(it_vat);
	    };
	
	    /*
	     * this generator is written following the official algorithm
	     * all data can be passed explicitely or randomized by calling chance.cf() without options
	     * the code does not check that the input data is valid (it goes beyond the scope of the generator)
	     *
	     * @param  [Object] options = { first: first name,
	     *                              last: last name,
	     *                              gender: female|male,
	                                    birthday: JavaScript date object,
	                                    city: string(4), 1 letter + 3 numbers
	                                   }
	     * @return [string] codice fiscale
	     *
	    */
	    Chance.prototype.cf = function (options) {
	        options = options || {};
	        var gender = !!options.gender ? options.gender : this.gender(),
	            first = !!options.first ? options.first : this.first( { gender: gender, nationality: 'it'} ),
	            last = !!options.last ? options.last : this.last( { nationality: 'it'} ),
	            birthday = !!options.birthday ? options.birthday : this.birthday(),
	            city = !!options.city ? options.city : this.pickone(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'L', 'M', 'Z']) + this.pad(this.natural({max:999}), 3),
	            cf = [],
	            name_generator = function(name, isLast) {
	                var temp,
	                    return_value = [];
	
	                if (name.length < 3) {
	                    return_value = name.split("").concat("XXX".split("")).splice(0,3);
	                }
	                else {
	                    temp = name.toUpperCase().split('').map(function(c){
	                        return ("BCDFGHJKLMNPRSTVWZ".indexOf(c) !== -1) ? c : undefined;
	                    }).join('');
	                    if (temp.length > 3) {
	                        if (isLast) {
	                            temp = temp.substr(0,3);
	                        } else {                        
	                            temp = temp[0] + temp.substr(2,2);
	                        }
	                    }
	                    if (temp.length < 3) {
	                        return_value = temp;
	                        temp = name.toUpperCase().split('').map(function(c){
	                            return ("AEIOU".indexOf(c) !== -1) ? c : undefined;
	                        }).join('').substr(0, 3 - return_value.length);
	                    }
	                    return_value = return_value + temp;
	                }
	
	                return return_value;
	            },
	            date_generator = function(birthday, gender, that) {
	                var lettermonths = ['A', 'B', 'C', 'D', 'E', 'H', 'L', 'M', 'P', 'R', 'S', 'T'];
	
	                return  birthday.getFullYear().toString().substr(2) + 
	                        lettermonths[birthday.getMonth()] +
	                        that.pad(birthday.getDate() + ((gender.toLowerCase() === "female") ? 40 : 0), 2);
	            },
	            checkdigit_generator = function(cf) {
	                var range1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	                    range2 = "ABCDEFGHIJABCDEFGHIJKLMNOPQRSTUVWXYZ",
	                    evens  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	                    odds   = "BAKPLCQDREVOSFTGUHMINJWZYX",
	                    digit  = 0;
	
	
	                for(var i = 0; i < 15; i++) {
	                    if (i % 2 !== 0) {
	                        digit += evens.indexOf(range2[range1.indexOf(cf[i])]);
	                    }
	                    else {
	                        digit +=  odds.indexOf(range2[range1.indexOf(cf[i])]);
	                    }
	                }
	                return evens[digit % 26];
	            };
	
	        cf = cf.concat(name_generator(last, true), name_generator(first), date_generator(birthday, gender, this), city.toUpperCase().split("")).join("");
	        cf += checkdigit_generator(cf.toUpperCase(), this);
	
	        return cf.toUpperCase();
	    };
	
	    Chance.prototype.pl_pesel = function () {
	        var number = this.natural({min: 1, max: 9999999999});
	        var arr = this.pad(number, 10).split('');
	        for (var i = 0; i < arr.length; i++) {
	            arr[i] = parseInt(arr[i]);
	        }
	
	        var controlNumber = (1 * arr[0] + 3 * arr[1] + 7 * arr[2] + 9 * arr[3] + 1 * arr[4] + 3 * arr[5] + 7 * arr[6] + 9 * arr[7] + 1 * arr[8] + 3 * arr[9]) % 10;
	        if(controlNumber !== 0) {
	            controlNumber = 10 - controlNumber;
	        }
	
	        return arr.join('') + controlNumber;
	    };
	
	    Chance.prototype.pl_nip = function () {
	        var number = this.natural({min: 1, max: 999999999});
	        var arr = this.pad(number, 9).split('');
	        for (var i = 0; i < arr.length; i++) {
	            arr[i] = parseInt(arr[i]);
	        }
	
	        var controlNumber = (6 * arr[0] + 5 * arr[1] + 7 * arr[2] + 2 * arr[3] + 3 * arr[4] + 4 * arr[5] + 5 * arr[6] + 6 * arr[7] + 7 * arr[8]) % 11;
	        if(controlNumber === 10) {
	            return this.pl_nip();
	        }
	
	        return arr.join('') + controlNumber;
	    };
	
	    Chance.prototype.pl_regon = function () {
	        var number = this.natural({min: 1, max: 99999999});
	        var arr = this.pad(number, 8).split('');
	        for (var i = 0; i < arr.length; i++) {
	            arr[i] = parseInt(arr[i]);
	        }
	
	        var controlNumber = (8 * arr[0] + 9 * arr[1] + 2 * arr[2] + 3 * arr[3] + 4 * arr[4] + 5 * arr[5] + 6 * arr[6] + 7 * arr[7]) % 11;
	        if(controlNumber === 10) {
	            controlNumber = 0;
	        }
	
	        return arr.join('') + controlNumber;
	    };
	
	    // -- End Regional
	
	    // -- Miscellaneous --
	
	    // Dice - For all the board game geeks out there, myself included ;)
	    function diceFn (range) {
	        return function () {
	            return this.natural(range);
	        };
	    }
	    Chance.prototype.d4 = diceFn({min: 1, max: 4});
	    Chance.prototype.d6 = diceFn({min: 1, max: 6});
	    Chance.prototype.d8 = diceFn({min: 1, max: 8});
	    Chance.prototype.d10 = diceFn({min: 1, max: 10});
	    Chance.prototype.d12 = diceFn({min: 1, max: 12});
	    Chance.prototype.d20 = diceFn({min: 1, max: 20});
	    Chance.prototype.d30 = diceFn({min: 1, max: 30});
	    Chance.prototype.d100 = diceFn({min: 1, max: 100});
	
	    Chance.prototype.rpg = function (thrown, options) {
	        options = initOptions(options);
	        if (!thrown) {
	            throw new RangeError("A type of die roll must be included");
	        } else {
	            var bits = thrown.toLowerCase().split("d"),
	                rolls = [];
	
	            if (bits.length !== 2 || !parseInt(bits[0], 10) || !parseInt(bits[1], 10)) {
	                throw new Error("Invalid format provided. Please provide #d# where the first # is the number of dice to roll, the second # is the max of each die");
	            }
	            for (var i = bits[0]; i > 0; i--) {
	                rolls[i - 1] = this.natural({min: 1, max: bits[1]});
	            }
	            return (typeof options.sum !== 'undefined' && options.sum) ? rolls.reduce(function (p, c) { return p + c; }) : rolls;
	        }
	    };
	
	    // Guid
	    Chance.prototype.guid = function (options) {
	        options = initOptions(options, { version: 5 });
	
	        var guid_pool = "abcdef1234567890",
	            variant_pool = "ab89",
	            guid = this.string({ pool: guid_pool, length: 8 }) + '-' +
	                   this.string({ pool: guid_pool, length: 4 }) + '-' +
	                   // The Version
	                   options.version +
	                   this.string({ pool: guid_pool, length: 3 }) + '-' +
	                   // The Variant
	                   this.string({ pool: variant_pool, length: 1 }) +
	                   this.string({ pool: guid_pool, length: 3 }) + '-' +
	                   this.string({ pool: guid_pool, length: 12 });
	        return guid;
	    };
	
	    // Hash
	    Chance.prototype.hash = function (options) {
	        options = initOptions(options, {length : 40, casing: 'lower'});
	        var pool = options.casing === 'upper' ? HEX_POOL.toUpperCase() : HEX_POOL;
	        return this.string({pool: pool, length: options.length});
	    };
	
	    Chance.prototype.luhn_check = function (num) {
	        var str = num.toString();
	        var checkDigit = +str.substring(str.length - 1);
	        return checkDigit === this.luhn_calculate(+str.substring(0, str.length - 1));
	    };
	
	    Chance.prototype.luhn_calculate = function (num) {
	        var digits = num.toString().split("").reverse();
	        var sum = 0;
	        var digit;
	
	        for (var i = 0, l = digits.length; l > i; ++i) {
	            digit = +digits[i];
	            if (i % 2 === 0) {
	                digit *= 2;
	                if (digit > 9) {
	                    digit -= 9;
	                }
	            }
	            sum += digit;
	        }
	        return (sum * 9) % 10;
	    };
	
	    // MD5 Hash
	    Chance.prototype.md5 = function(options) {
	        var opts = { str: '', key: null, raw: false };
	
	        if (!options) {
	            opts.str = this.string();
	            options = {};
	        }
	        else if (typeof options === 'string') {
	            opts.str = options;
	            options = {};
	        }
	        else if (typeof options !== 'object') {
	            return null;
	        }
	        else if(options.constructor === 'Array') {
	            return null;
	        }
	
	        opts = initOptions(options, opts);
	
	        if(!opts.str){
	            throw new Error('A parameter is required to return an md5 hash.');
	        }
	
	        return this.bimd5.md5(opts.str, opts.key, opts.raw);
	    };
	
	    /**
	     * #Description:
	     * =====================================================
	     * Generate random file name with extention
	     *
	     * The argument provide extention type 
	     * -> raster 
	     * -> vector
	     * -> 3d
	     * -> document
	     *
	     * If noting is provided the function return random file name with random 
	     * extention type of any kind
	     *
	     * The user can validate the file name length range 
	     * If noting provided the generated file name is radom
	     *
	     * #Extention Pool :
	     * * Currently the supported extentions are 
	     *  -> some of the most popular raster image extentions
	     *  -> some of the most popular vector image extentions
	     *  -> some of the most popular 3d image extentions
	     *  -> some of the most popular document extentions
	     * 
	     * #Examples :
	     * =====================================================
	     *
	     * Return random file name with random extention. The file extention
	     * is provided by a predifined collection of extentions. More abouth the extention
	     * pool can be fond in #Extention Pool section
	     * 
	     * chance.file()                        
	     * => dsfsdhjf.xml
	     *
	     * In order to generate a file name with sspecific length, specify the 
	     * length property and integer value. The extention is going to be random
	     *  
	     * chance.file({length : 10})           
	     * => asrtineqos.pdf
	     *
	     * In order to geerate file with extention form some of the predifined groups
	     * of the extention pool just specify the extenton pool category in fileType property
	     *  
	     * chance.file({fileType : 'raster'})   
	     * => dshgssds.psd
	     *
	     * You can provide specific extention for your files
	     * chance.file({extention : 'html'})    
	     * => djfsd.html
	     *
	     * Or you could pass custom collection of extentons bt array or by object
	     * chance.file({extentions : [...]})    
	     * => dhgsdsd.psd
	     *  
	     * chance.file({extentions : { key : [...], key : [...]}})
	     * => djsfksdjsd.xml
	     * 
	     * @param  [collection] options 
	     * @return [string]
	     * 
	     */
	    Chance.prototype.file = function(options) {
	        
	        var fileOptions = options || {};
	        var poolCollectionKey = "fileExtension";
	        var typeRange   = Object.keys(this.get("fileExtension"));//['raster', 'vector', '3d', 'document'];
	        var fileName;
	        var fileExtention;
	
	        // Generate random file name 
	        fileName = this.word({length : fileOptions.length});
	
	        // Generate file by specific extention provided by the user
	        if(fileOptions.extention) {
	
	            fileExtention = fileOptions.extention;
	            return (fileName + '.' + fileExtention);
	        }
	
	        // Generate file by specific axtention collection
	        if(fileOptions.extentions) {
	
	            if(Array.isArray(fileOptions.extentions)) {
	
	                fileExtention = this.pickone(fileOptions.extentions);
	                return (fileName + '.' + fileExtention);
	            }
	            else if(fileOptions.extentions.constructor === Object) {
	                
	                var extentionObjectCollection = fileOptions.extentions;
	                var keys = Object.keys(extentionObjectCollection);
	
	                fileExtention = this.pickone(extentionObjectCollection[this.pickone(keys)]);
	                return (fileName + '.' + fileExtention);
	            }
	
	            throw new Error("Expect collection of type Array or Object to be passed as an argument ");
	        } 
	
	        // Generate file extention based on specific file type
	        if(fileOptions.fileType) {
	
	            var fileType = fileOptions.fileType;
	            if(typeRange.indexOf(fileType) !== -1) {
	
	                fileExtention = this.pickone(this.get(poolCollectionKey)[fileType]);
	                return (fileName + '.' + fileExtention);
	            }
	
	            throw new Error("Expect file type value to be 'raster', 'vector', '3d' or 'document' ");
	        }
	
	        // Generate random file name if no extenton options are passed
	        fileExtention = this.pickone(this.get(poolCollectionKey)[this.pickone(typeRange)]);
	        return (fileName + '.' + fileExtention);
	    };     
	
	    var data = {
	
	        firstNames: {
	            "male": {
	                "en": ["James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph", "Charles", "Thomas", "Christopher", "Daniel", "Matthew", "George", "Donald", "Anthony", "Paul", "Mark", "Edward", "Steven", "Kenneth", "Andrew", "Brian", "Joshua", "Kevin", "Ronald", "Timothy", "Jason", "Jeffrey", "Frank", "Gary", "Ryan", "Nicholas", "Eric", "Stephen", "Jacob", "Larry", "Jonathan", "Scott", "Raymond", "Justin", "Brandon", "Gregory", "Samuel", "Benjamin", "Patrick", "Jack", "Henry", "Walter", "Dennis", "Jerry", "Alexander", "Peter", "Tyler", "Douglas", "Harold", "Aaron", "Jose", "Adam", "Arthur", "Zachary", "Carl", "Nathan", "Albert", "Kyle", "Lawrence", "Joe", "Willie", "Gerald", "Roger", "Keith", "Jeremy", "Terry", "Harry", "Ralph", "Sean", "Jesse", "Roy", "Louis", "Billy", "Austin", "Bruce", "Eugene", "Christian", "Bryan", "Wayne", "Russell", "Howard", "Fred", "Ethan", "Jordan", "Philip", "Alan", "Juan", "Randy", "Vincent", "Bobby", "Dylan", "Johnny", "Phillip", "Victor", "Clarence", "Ernest", "Martin", "Craig", "Stanley", "Shawn", "Travis", "Bradley", "Leonard", "Earl", "Gabriel", "Jimmy", "Francis", "Todd", "Noah", "Danny", "Dale", "Cody", "Carlos", "Allen", "Frederick", "Logan", "Curtis", "Alex", "Joel", "Luis", "Norman", "Marvin", "Glenn", "Tony", "Nathaniel", "Rodney", "Melvin", "Alfred", "Steve", "Cameron", "Chad", "Edwin", "Caleb", "Evan", "Antonio", "Lee", "Herbert", "Jeffery", "Isaac", "Derek", "Ricky", "Marcus", "Theodore", "Elijah", "Luke", "Jesus", "Eddie", "Troy", "Mike", "Dustin", "Ray", "Adrian", "Bernard", "Leroy", "Angel", "Randall", "Wesley", "Ian", "Jared", "Mason", "Hunter", "Calvin", "Oscar", "Clifford", "Jay", "Shane", "Ronnie", "Barry", "Lucas", "Corey", "Manuel", "Leo", "Tommy", "Warren", "Jackson", "Isaiah", "Connor", "Don", "Dean", "Jon", "Julian", "Miguel", "Bill", "Lloyd", "Charlie", "Mitchell", "Leon", "Jerome", "Darrell", "Jeremiah", "Alvin", "Brett", "Seth", "Floyd", "Jim", "Blake", "Micheal", "Gordon", "Trevor", "Lewis", "Erik", "Edgar", "Vernon", "Devin", "Gavin", "Jayden", "Chris", "Clyde", "Tom", "Derrick", "Mario", "Brent", "Marc", "Herman", "Chase", "Dominic", "Ricardo", "Franklin", "Maurice", "Max", "Aiden", "Owen", "Lester", "Gilbert", "Elmer", "Gene", "Francisco", "Glen", "Cory", "Garrett", "Clayton", "Sam", "Jorge", "Chester", "Alejandro", "Jeff", "Harvey", "Milton", "Cole", "Ivan", "Andre", "Duane", "Landon"],
	                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0163
	                "it": ["Adolfo", "Alberto", "Aldo", "Alessandro", "Alessio", "Alfredo", "Alvaro", "Andrea", "Angelo", "Angiolo", "Antonino", "Antonio", "Attilio", "Benito", "Bernardo", "Bruno", "Carlo", "Cesare", "Christian", "Claudio", "Corrado", "Cosimo", "Cristian", "Cristiano", "Daniele", "Dario", "David", "Davide", "Diego", "Dino", "Domenico", "Duccio", "Edoardo", "Elia", "Elio", "Emanuele", "Emiliano", "Emilio", "Enrico", "Enzo", "Ettore", "Fabio", "Fabrizio", "Federico", "Ferdinando", "Fernando", "Filippo", "Francesco", "Franco", "Gabriele", "Giacomo", "Giampaolo", "Giampiero", "Giancarlo", "Gianfranco", "Gianluca", "Gianmarco", "Gianni", "Gino", "Giorgio", "Giovanni", "Giuliano", "Giulio", "Giuseppe", "Graziano", "Gregorio", "Guido", "Iacopo", "Jacopo", "Lapo", "Leonardo", "Lorenzo", "Luca", "Luciano", "Luigi", "Manuel", "Marcello", "Marco", "Marino", "Mario", "Massimiliano", "Massimo", "Matteo", "Mattia", "Maurizio", "Mauro", "Michele", "Mirko", "Mohamed", "Nello", "Neri", "Niccolò", "Nicola", "Osvaldo", "Otello", "Paolo", "Pier Luigi", "Piero", "Pietro", "Raffaele", "Remo", "Renato", "Renzo", "Riccardo", "Roberto", "Rolando", "Romano", "Salvatore", "Samuele", "Sandro", "Sergio", "Silvano", "Simone", "Stefano", "Thomas", "Tommaso", "Ubaldo", "Ugo", "Umberto", "Valerio", "Valter", "Vasco", "Vincenzo", "Vittorio"]
	            },
	            "female": {
	                "en": ["Mary", "Emma", "Elizabeth", "Minnie", "Margaret", "Ida", "Alice", "Bertha", "Sarah", "Annie", "Clara", "Ella", "Florence", "Cora", "Martha", "Laura", "Nellie", "Grace", "Carrie", "Maude", "Mabel", "Bessie", "Jennie", "Gertrude", "Julia", "Hattie", "Edith", "Mattie", "Rose", "Catherine", "Lillian", "Ada", "Lillie", "Helen", "Jessie", "Louise", "Ethel", "Lula", "Myrtle", "Eva", "Frances", "Lena", "Lucy", "Edna", "Maggie", "Pearl", "Daisy", "Fannie", "Josephine", "Dora", "Rosa", "Katherine", "Agnes", "Marie", "Nora", "May", "Mamie", "Blanche", "Stella", "Ellen", "Nancy", "Effie", "Sallie", "Nettie", "Della", "Lizzie", "Flora", "Susie", "Maud", "Mae", "Etta", "Harriet", "Sadie", "Caroline", "Katie", "Lydia", "Elsie", "Kate", "Susan", "Mollie", "Alma", "Addie", "Georgia", "Eliza", "Lulu", "Nannie", "Lottie", "Amanda", "Belle", "Charlotte", "Rebecca", "Ruth", "Viola", "Olive", "Amelia", "Hannah", "Jane", "Virginia", "Emily", "Matilda", "Irene", "Kathryn", "Esther", "Willie", "Henrietta", "Ollie", "Amy", "Rachel", "Sara", "Estella", "Theresa", "Augusta", "Ora", "Pauline", "Josie", "Lola", "Sophia", "Leona", "Anne", "Mildred", "Ann", "Beulah", "Callie", "Lou", "Delia", "Eleanor", "Barbara", "Iva", "Louisa", "Maria", "Mayme", "Evelyn", "Estelle", "Nina", "Betty", "Marion", "Bettie", "Dorothy", "Luella", "Inez", "Lela", "Rosie", "Allie", "Millie", "Janie", "Cornelia", "Victoria", "Ruby", "Winifred", "Alta", "Celia", "Christine", "Beatrice", "Birdie", "Harriett", "Mable", "Myra", "Sophie", "Tillie", "Isabel", "Sylvia", "Carolyn", "Isabelle", "Leila", "Sally", "Ina", "Essie", "Bertie", "Nell", "Alberta", "Katharine", "Lora", "Rena", "Mina", "Rhoda", "Mathilda", "Abbie", "Eula", "Dollie", "Hettie", "Eunice", "Fanny", "Ola", "Lenora", "Adelaide", "Christina", "Lelia", "Nelle", "Sue", "Johanna", "Lilly", "Lucinda", "Minerva", "Lettie", "Roxie", "Cynthia", "Helena", "Hilda", "Hulda", "Bernice", "Genevieve", "Jean", "Cordelia", "Marian", "Francis", "Jeanette", "Adeline", "Gussie", "Leah", "Lois", "Lura", "Mittie", "Hallie", "Isabella", "Olga", "Phoebe", "Teresa", "Hester", "Lida", "Lina", "Winnie", "Claudia", "Marguerite", "Vera", "Cecelia", "Bess", "Emilie", "John", "Rosetta", "Verna", "Myrtie", "Cecilia", "Elva", "Olivia", "Ophelia", "Georgie", "Elnora", "Violet", "Adele", "Lily", "Linnie", "Loretta", "Madge", "Polly", "Virgie", "Eugenia", "Lucile", "Lucille", "Mabelle", "Rosalie"],
	                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0162
	                "it": ["Ada", "Adriana", "Alessandra", "Alessia", "Alice", "Angela", "Anna", "Anna Maria", "Annalisa", "Annita", "Annunziata", "Antonella", "Arianna", "Asia", "Assunta", "Aurora", "Barbara", "Beatrice", "Benedetta", "Bianca", "Bruna", "Camilla", "Carla", "Carlotta", "Carmela", "Carolina", "Caterina", "Catia", "Cecilia", "Chiara", "Cinzia", "Clara", "Claudia", "Costanza", "Cristina", "Daniela", "Debora", "Diletta", "Dina", "Donatella", "Elena", "Eleonora", "Elisa", "Elisabetta", "Emanuela", "Emma", "Eva", "Federica", "Fernanda", "Fiorella", "Fiorenza", "Flora", "Franca", "Francesca", "Gabriella", "Gaia", "Gemma", "Giada", "Gianna", "Gina", "Ginevra", "Giorgia", "Giovanna", "Giulia", "Giuliana", "Giuseppa", "Giuseppina", "Grazia", "Graziella", "Greta", "Ida", "Ilaria", "Ines", "Iolanda", "Irene", "Irma", "Isabella", "Jessica", "Laura", "Leda", "Letizia", "Licia", "Lidia", "Liliana", "Lina", "Linda", "Lisa", "Livia", "Loretta", "Luana", "Lucia", "Luciana", "Lucrezia", "Luisa", "Manuela", "Mara", "Marcella", "Margherita", "Maria", "Maria Cristina", "Maria Grazia", "Maria Luisa", "Maria Pia", "Maria Teresa", "Marina", "Marisa", "Marta", "Martina", "Marzia", "Matilde", "Melissa", "Michela", "Milena", "Mirella", "Monica", "Natalina", "Nella", "Nicoletta", "Noemi", "Olga", "Paola", "Patrizia", "Piera", "Pierina", "Raffaella", "Rebecca", "Renata", "Rina", "Rita", "Roberta", "Rosa", "Rosanna", "Rossana", "Rossella", "Sabrina", "Sandra", "Sara", "Serena", "Silvana", "Silvia", "Simona", "Simonetta", "Sofia", "Sonia", "Stefania", "Susanna", "Teresa", "Tina", "Tiziana", "Tosca", "Valentina", "Valeria", "Vanda", "Vanessa", "Vanna", "Vera", "Veronica", "Vilma", "Viola", "Virginia", "Vittoria"]
	            }
	        },
	
	        lastNames: {
	            "en": ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King', 'Wright', 'Lopez', 'Hill', 'Scott', 'Green', 'Adams', 'Baker', 'Gonzalez', 'Nelson', 'Carter', 'Mitchell', 'Perez', 'Roberts', 'Turner', 'Phillips', 'Campbell', 'Parker', 'Evans', 'Edwards', 'Collins', 'Stewart', 'Sanchez', 'Morris', 'Rogers', 'Reed', 'Cook', 'Morgan', 'Bell', 'Murphy', 'Bailey', 'Rivera', 'Cooper', 'Richardson', 'Cox', 'Howard', 'Ward', 'Torres', 'Peterson', 'Gray', 'Ramirez', 'James', 'Watson', 'Brooks', 'Kelly', 'Sanders', 'Price', 'Bennett', 'Wood', 'Barnes', 'Ross', 'Henderson', 'Coleman', 'Jenkins', 'Perry', 'Powell', 'Long', 'Patterson', 'Hughes', 'Flores', 'Washington', 'Butler', 'Simmons', 'Foster', 'Gonzales', 'Bryant', 'Alexander', 'Russell', 'Griffin', 'Diaz', 'Hayes', 'Myers', 'Ford', 'Hamilton', 'Graham', 'Sullivan', 'Wallace', 'Woods', 'Cole', 'West', 'Jordan', 'Owens', 'Reynolds', 'Fisher', 'Ellis', 'Harrison', 'Gibson', 'McDonald', 'Cruz', 'Marshall', 'Ortiz', 'Gomez', 'Murray', 'Freeman', 'Wells', 'Webb', 'Simpson', 'Stevens', 'Tucker', 'Porter', 'Hunter', 'Hicks', 'Crawford', 'Henry', 'Boyd', 'Mason', 'Morales', 'Kennedy', 'Warren', 'Dixon', 'Ramos', 'Reyes', 'Burns', 'Gordon', 'Shaw', 'Holmes', 'Rice', 'Robertson', 'Hunt', 'Black', 'Daniels', 'Palmer', 'Mills', 'Nichols', 'Grant', 'Knight', 'Ferguson', 'Rose', 'Stone', 'Hawkins', 'Dunn', 'Perkins', 'Hudson', 'Spencer', 'Gardner', 'Stephens', 'Payne', 'Pierce', 'Berry', 'Matthews', 'Arnold', 'Wagner', 'Willis', 'Ray', 'Watkins', 'Olson', 'Carroll', 'Duncan', 'Snyder', 'Hart', 'Cunningham', 'Bradley', 'Lane', 'Andrews', 'Ruiz', 'Harper', 'Fox', 'Riley', 'Armstrong', 'Carpenter', 'Weaver', 'Greene', 'Lawrence', 'Elliott', 'Chavez', 'Sims', 'Austin', 'Peters', 'Kelley', 'Franklin', 'Lawson', 'Fields', 'Gutierrez', 'Ryan', 'Schmidt', 'Carr', 'Vasquez', 'Castillo', 'Wheeler', 'Chapman', 'Oliver', 'Montgomery', 'Richards', 'Williamson', 'Johnston', 'Banks', 'Meyer', 'Bishop', 'McCoy', 'Howell', 'Alvarez', 'Morrison', 'Hansen', 'Fernandez', 'Garza', 'Harvey', 'Little', 'Burton', 'Stanley', 'Nguyen', 'George', 'Jacobs', 'Reid', 'Kim', 'Fuller', 'Lynch', 'Dean', 'Gilbert', 'Garrett', 'Romero', 'Welch', 'Larson', 'Frazier', 'Burke', 'Hanson', 'Day', 'Mendoza', 'Moreno', 'Bowman', 'Medina', 'Fowler', 'Brewer', 'Hoffman', 'Carlson', 'Silva', 'Pearson', 'Holland', 'Douglas', 'Fleming', 'Jensen', 'Vargas', 'Byrd', 'Davidson', 'Hopkins', 'May', 'Terry', 'Herrera', 'Wade', 'Soto', 'Walters', 'Curtis', 'Neal', 'Caldwell', 'Lowe', 'Jennings', 'Barnett', 'Graves', 'Jimenez', 'Horton', 'Shelton', 'Barrett', 'Obrien', 'Castro', 'Sutton', 'Gregory', 'McKinney', 'Lucas', 'Miles', 'Craig', 'Rodriquez', 'Chambers', 'Holt', 'Lambert', 'Fletcher', 'Watts', 'Bates', 'Hale', 'Rhodes', 'Pena', 'Beck', 'Newman', 'Haynes', 'McDaniel', 'Mendez', 'Bush', 'Vaughn', 'Parks', 'Dawson', 'Santiago', 'Norris', 'Hardy', 'Love', 'Steele', 'Curry', 'Powers', 'Schultz', 'Barker', 'Guzman', 'Page', 'Munoz', 'Ball', 'Keller', 'Chandler', 'Weber', 'Leonard', 'Walsh', 'Lyons', 'Ramsey', 'Wolfe', 'Schneider', 'Mullins', 'Benson', 'Sharp', 'Bowen', 'Daniel', 'Barber', 'Cummings', 'Hines', 'Baldwin', 'Griffith', 'Valdez', 'Hubbard', 'Salazar', 'Reeves', 'Warner', 'Stevenson', 'Burgess', 'Santos', 'Tate', 'Cross', 'Garner', 'Mann', 'Mack', 'Moss', 'Thornton', 'Dennis', 'McGee', 'Farmer', 'Delgado', 'Aguilar', 'Vega', 'Glover', 'Manning', 'Cohen', 'Harmon', 'Rodgers', 'Robbins', 'Newton', 'Todd', 'Blair', 'Higgins', 'Ingram', 'Reese', 'Cannon', 'Strickland', 'Townsend', 'Potter', 'Goodwin', 'Walton', 'Rowe', 'Hampton', 'Ortega', 'Patton', 'Swanson', 'Joseph', 'Francis', 'Goodman', 'Maldonado', 'Yates', 'Becker', 'Erickson', 'Hodges', 'Rios', 'Conner', 'Adkins', 'Webster', 'Norman', 'Malone', 'Hammond', 'Flowers', 'Cobb', 'Moody', 'Quinn', 'Blake', 'Maxwell', 'Pope', 'Floyd', 'Osborne', 'Paul', 'McCarthy', 'Guerrero', 'Lindsey', 'Estrada', 'Sandoval', 'Gibbs', 'Tyler', 'Gross', 'Fitzgerald', 'Stokes', 'Doyle', 'Sherman', 'Saunders', 'Wise', 'Colon', 'Gill', 'Alvarado', 'Greer', 'Padilla', 'Simon', 'Waters', 'Nunez', 'Ballard', 'Schwartz', 'McBride', 'Houston', 'Christensen', 'Klein', 'Pratt', 'Briggs', 'Parsons', 'McLaughlin', 'Zimmerman', 'French', 'Buchanan', 'Moran', 'Copeland', 'Roy', 'Pittman', 'Brady', 'McCormick', 'Holloway', 'Brock', 'Poole', 'Frank', 'Logan', 'Owen', 'Bass', 'Marsh', 'Drake', 'Wong', 'Jefferson', 'Park', 'Morton', 'Abbott', 'Sparks', 'Patrick', 'Norton', 'Huff', 'Clayton', 'Massey', 'Lloyd', 'Figueroa', 'Carson', 'Bowers', 'Roberson', 'Barton', 'Tran', 'Lamb', 'Harrington', 'Casey', 'Boone', 'Cortez', 'Clarke', 'Mathis', 'Singleton', 'Wilkins', 'Cain', 'Bryan', 'Underwood', 'Hogan', 'McKenzie', 'Collier', 'Luna', 'Phelps', 'McGuire', 'Allison', 'Bridges', 'Wilkerson', 'Nash', 'Summers', 'Atkins'],
	                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0164 (first 1000)
	            "it": ["Acciai", "Aglietti", "Agostini", "Agresti", "Ahmed", "Aiazzi", "Albanese", "Alberti", "Alessi", "Alfani", "Alinari", "Alterini", "Amato", "Ammannati", "Ancillotti", "Andrei", "Andreini", "Andreoni", "Angeli", "Anichini", "Antonelli", "Antonini", "Arena", "Ariani", "Arnetoli", "Arrighi", "Baccani", "Baccetti", "Bacci", "Bacherini", "Badii", "Baggiani", "Baglioni", "Bagni", "Bagnoli", "Baldassini", "Baldi", "Baldini", "Ballerini", "Balli", "Ballini", "Balloni", "Bambi", "Banchi", "Bandinelli", "Bandini", "Bani", "Barbetti", "Barbieri", "Barchielli", "Bardazzi", "Bardelli", "Bardi", "Barducci", "Bargellini", "Bargiacchi", "Barni", "Baroncelli", "Baroncini", "Barone", "Baroni", "Baronti", "Bartalesi", "Bartoletti", "Bartoli", "Bartolini", "Bartoloni", "Bartolozzi", "Basagni", "Basile", "Bassi", "Batacchi", "Battaglia", "Battaglini", "Bausi", "Becagli", "Becattini", "Becchi", "Becucci", "Bellandi", "Bellesi", "Belli", "Bellini", "Bellucci", "Bencini", "Benedetti", "Benelli", "Beni", "Benini", "Bensi", "Benucci", "Benvenuti", "Berlincioni", "Bernacchioni", "Bernardi", "Bernardini", "Berni", "Bernini", "Bertelli", "Berti", "Bertini", "Bessi", "Betti", "Bettini", "Biagi", "Biagini", "Biagioni", "Biagiotti", "Biancalani", "Bianchi", "Bianchini", "Bianco", "Biffoli", "Bigazzi", "Bigi", "Biliotti", "Billi", "Binazzi", "Bindi", "Bini", "Biondi", "Bizzarri", "Bocci", "Bogani", "Bolognesi", "Bonaiuti", "Bonanni", "Bonciani", "Boncinelli", "Bondi", "Bonechi", "Bongini", "Boni", "Bonini", "Borchi", "Boretti", "Borghi", "Borghini", "Borgioli", "Borri", "Borselli", "Boschi", "Bottai", "Bracci", "Braccini", "Brandi", "Braschi", "Bravi", "Brazzini", "Breschi", "Brilli", "Brizzi", "Brogelli", "Brogi", "Brogioni", "Brunelli", "Brunetti", "Bruni", "Bruno", "Brunori", "Bruschi", "Bucci", "Bucciarelli", "Buccioni", "Bucelli", "Bulli", "Burberi", "Burchi", "Burgassi", "Burroni", "Bussotti", "Buti", "Caciolli", "Caiani", "Calabrese", "Calamai", "Calamandrei", "Caldini", "Calo'", "Calonaci", "Calosi", "Calvelli", "Cambi", "Camiciottoli", "Cammelli", "Cammilli", "Campolmi", "Cantini", "Capanni", "Capecchi", "Caponi", "Cappelletti", "Cappelli", "Cappellini", "Cappugi", "Capretti", "Caputo", "Carbone", "Carboni", "Cardini", "Carlesi", "Carletti", "Carli", "Caroti", "Carotti", "Carrai", "Carraresi", "Carta", "Caruso", "Casalini", "Casati", "Caselli", "Casini", "Castagnoli", "Castellani", "Castelli", "Castellucci", "Catalano", "Catarzi", "Catelani", "Cavaciocchi", "Cavallaro", "Cavallini", "Cavicchi", "Cavini", "Ceccarelli", "Ceccatelli", "Ceccherelli", "Ceccherini", "Cecchi", "Cecchini", "Cecconi", "Cei", "Cellai", "Celli", "Cellini", "Cencetti", "Ceni", "Cenni", "Cerbai", "Cesari", "Ceseri", "Checcacci", "Checchi", "Checcucci", "Cheli", "Chellini", "Chen", "Cheng", "Cherici", "Cherubini", "Chiaramonti", "Chiarantini", "Chiarelli", "Chiari", "Chiarini", "Chiarugi", "Chiavacci", "Chiesi", "Chimenti", "Chini", "Chirici", "Chiti", "Ciabatti", "Ciampi", "Cianchi", "Cianfanelli", "Cianferoni", "Ciani", "Ciapetti", "Ciappi", "Ciardi", "Ciatti", "Cicali", "Ciccone", "Cinelli", "Cini", "Ciobanu", "Ciolli", "Cioni", "Cipriani", "Cirillo", "Cirri", "Ciucchi", "Ciuffi", "Ciulli", "Ciullini", "Clemente", "Cocchi", "Cognome", "Coli", "Collini", "Colombo", "Colzi", "Comparini", "Conforti", "Consigli", "Conte", "Conti", "Contini", "Coppini", "Coppola", "Corsi", "Corsini", "Corti", "Cortini", "Cosi", "Costa", "Costantini", "Costantino", "Cozzi", "Cresci", "Crescioli", "Cresti", "Crini", "Curradi", "D'Agostino", "D'Alessandro", "D'Amico", "D'Angelo", "Daddi", "Dainelli", "Dallai", "Danti", "Davitti", "De Angelis", "De Luca", "De Marco", "De Rosa", "De Santis", "De Simone", "De Vita", "Degl'Innocenti", "Degli Innocenti", "Dei", "Del Lungo", "Del Re", "Di Marco", "Di Stefano", "Dini", "Diop", "Dobre", "Dolfi", "Donati", "Dondoli", "Dong", "Donnini", "Ducci", "Dumitru", "Ermini", "Esposito", "Evangelisti", "Fabbri", "Fabbrini", "Fabbrizzi", "Fabbroni", "Fabbrucci", "Fabiani", "Facchini", "Faggi", "Fagioli", "Failli", "Faini", "Falciani", "Falcini", "Falcone", "Fallani", "Falorni", "Falsini", "Falugiani", "Fancelli", "Fanelli", "Fanetti", "Fanfani", "Fani", "Fantappie'", "Fantechi", "Fanti", "Fantini", "Fantoni", "Farina", "Fattori", "Favilli", "Fedi", "Fei", "Ferrante", "Ferrara", "Ferrari", "Ferraro", "Ferretti", "Ferri", "Ferrini", "Ferroni", "Fiaschi", "Fibbi", "Fiesoli", "Filippi", "Filippini", "Fini", "Fioravanti", "Fiore", "Fiorentini", "Fiorini", "Fissi", "Focardi", "Foggi", "Fontana", "Fontanelli", "Fontani", "Forconi", "Formigli", "Forte", "Forti", "Fortini", "Fossati", "Fossi", "Francalanci", "Franceschi", "Franceschini", "Franchi", "Franchini", "Franci", "Francini", "Francioni", "Franco", "Frassineti", "Frati", "Fratini", "Frilli", "Frizzi", "Frosali", "Frosini", "Frullini", "Fusco", "Fusi", "Gabbrielli", "Gabellini", "Gagliardi", "Galanti", "Galardi", "Galeotti", "Galletti", "Galli", "Gallo", "Gallori", "Gambacciani", "Gargani", "Garofalo", "Garuglieri", "Gashi", "Gasperini", "Gatti", "Gelli", "Gensini", "Gentile", "Gentili", "Geri", "Gerini", "Gheri", "Ghini", "Giachetti", "Giachi", "Giacomelli", "Gianassi", "Giani", "Giannelli", "Giannetti", "Gianni", "Giannini", "Giannoni", "Giannotti", "Giannozzi", "Gigli", "Giordano", "Giorgetti", "Giorgi", "Giovacchini", "Giovannelli", "Giovannetti", "Giovannini", "Giovannoni", "Giuliani", "Giunti", "Giuntini", "Giusti", "Gonnelli", "Goretti", "Gori", "Gradi", "Gramigni", "Grassi", "Grasso", "Graziani", "Grazzini", "Greco", "Grifoni", "Grillo", "Grimaldi", "Grossi", "Gualtieri", "Guarducci", "Guarino", "Guarnieri", "Guasti", "Guerra", "Guerri", "Guerrini", "Guidi", "Guidotti", "He", "Hoxha", "Hu", "Huang", "Iandelli", "Ignesti", "Innocenti", "Jin", "La Rosa", "Lai", "Landi", "Landini", "Lanini", "Lapi", "Lapini", "Lari", "Lascialfari", "Lastrucci", "Latini", "Lazzeri", "Lazzerini", "Lelli", "Lenzi", "Leonardi", "Leoncini", "Leone", "Leoni", "Lepri", "Li", "Liao", "Lin", "Linari", "Lippi", "Lisi", "Livi", "Lombardi", "Lombardini", "Lombardo", "Longo", "Lopez", "Lorenzi", "Lorenzini", "Lorini", "Lotti", "Lu", "Lucchesi", "Lucherini", "Lunghi", "Lupi", "Madiai", "Maestrini", "Maffei", "Maggi", "Maggini", "Magherini", "Magini", "Magnani", "Magnelli", "Magni", "Magnolfi", "Magrini", "Malavolti", "Malevolti", "Manca", "Mancini", "Manetti", "Manfredi", "Mangani", "Mannelli", "Manni", "Mannini", "Mannucci", "Manuelli", "Manzini", "Marcelli", "Marchese", "Marchetti", "Marchi", "Marchiani", "Marchionni", "Marconi", "Marcucci", "Margheri", "Mari", "Mariani", "Marilli", "Marinai", "Marinari", "Marinelli", "Marini", "Marino", "Mariotti", "Marsili", "Martelli", "Martinelli", "Martini", "Martino", "Marzi", "Masi", "Masini", "Masoni", "Massai", "Materassi", "Mattei", "Matteini", "Matteucci", "Matteuzzi", "Mattioli", "Mattolini", "Matucci", "Mauro", "Mazzanti", "Mazzei", "Mazzetti", "Mazzi", "Mazzini", "Mazzocchi", "Mazzoli", "Mazzoni", "Mazzuoli", "Meacci", "Mecocci", "Meini", "Melani", "Mele", "Meli", "Mengoni", "Menichetti", "Meoni", "Merlini", "Messeri", "Messina", "Meucci", "Miccinesi", "Miceli", "Micheli", "Michelini", "Michelozzi", "Migliori", "Migliorini", "Milani", "Miniati", "Misuri", "Monaco", "Montagnani", "Montagni", "Montanari", "Montelatici", "Monti", "Montigiani", "Montini", "Morandi", "Morandini", "Morelli", "Moretti", "Morganti", "Mori", "Morini", "Moroni", "Morozzi", "Mugnai", "Mugnaini", "Mustafa", "Naldi", "Naldini", "Nannelli", "Nanni", "Nannini", "Nannucci", "Nardi", "Nardini", "Nardoni", "Natali", "Ndiaye", "Nencetti", "Nencini", "Nencioni", "Neri", "Nesi", "Nesti", "Niccolai", "Niccoli", "Niccolini", "Nigi", "Nistri", "Nocentini", "Noferini", "Novelli", "Nucci", "Nuti", "Nutini", "Oliva", "Olivieri", "Olmi", "Orlandi", "Orlandini", "Orlando", "Orsini", "Ortolani", "Ottanelli", "Pacciani", "Pace", "Paci", "Pacini", "Pagani", "Pagano", "Paggetti", "Pagliai", "Pagni", "Pagnini", "Paladini", "Palagi", "Palchetti", "Palloni", "Palmieri", "Palumbo", "Pampaloni", "Pancani", "Pandolfi", "Pandolfini", "Panerai", "Panichi", "Paoletti", "Paoli", "Paolini", "Papi", "Papini", "Papucci", "Parenti", "Parigi", "Parisi", "Parri", "Parrini", "Pasquini", "Passeri", "Pecchioli", "Pecorini", "Pellegrini", "Pepi", "Perini", "Perrone", "Peruzzi", "Pesci", "Pestelli", "Petri", "Petrini", "Petrucci", "Pettini", "Pezzati", "Pezzatini", "Piani", "Piazza", "Piazzesi", "Piazzini", "Piccardi", "Picchi", "Piccini", "Piccioli", "Pieraccini", "Pieraccioni", "Pieralli", "Pierattini", "Pieri", "Pierini", "Pieroni", "Pietrini", "Pini", "Pinna", "Pinto", "Pinzani", "Pinzauti", "Piras", "Pisani", "Pistolesi", "Poggesi", "Poggi", "Poggiali", "Poggiolini", "Poli", "Pollastri", "Porciani", "Pozzi", "Pratellesi", "Pratesi", "Prosperi", "Pruneti", "Pucci", "Puccini", "Puccioni", "Pugi", "Pugliese", "Puliti", "Querci", "Quercioli", "Raddi", "Radu", "Raffaelli", "Ragazzini", "Ranfagni", "Ranieri", "Rastrelli", "Raugei", "Raveggi", "Renai", "Renzi", "Rettori", "Ricci", "Ricciardi", "Ridi", "Ridolfi", "Rigacci", "Righi", "Righini", "Rinaldi", "Risaliti", "Ristori", "Rizzo", "Rocchi", "Rocchini", "Rogai", "Romagnoli", "Romanelli", "Romani", "Romano", "Romei", "Romeo", "Romiti", "Romoli", "Romolini", "Rontini", "Rosati", "Roselli", "Rosi", "Rossetti", "Rossi", "Rossini", "Rovai", "Ruggeri", "Ruggiero", "Russo", "Sabatini", "Saccardi", "Sacchetti", "Sacchi", "Sacco", "Salerno", "Salimbeni", "Salucci", "Salvadori", "Salvestrini", "Salvi", "Salvini", "Sanesi", "Sani", "Sanna", "Santi", "Santini", "Santoni", "Santoro", "Santucci", "Sardi", "Sarri", "Sarti", "Sassi", "Sbolci", "Scali", "Scarpelli", "Scarselli", "Scopetani", "Secci", "Selvi", "Senatori", "Senesi", "Serafini", "Sereni", "Serra", "Sestini", "Sguanci", "Sieni", "Signorini", "Silvestri", "Simoncini", "Simonetti", "Simoni", "Singh", "Sodi", "Soldi", "Somigli", "Sorbi", "Sorelli", "Sorrentino", "Sottili", "Spina", "Spinelli", "Staccioli", "Staderini", "Stefanelli", "Stefani", "Stefanini", "Stella", "Susini", "Tacchi", "Tacconi", "Taddei", "Tagliaferri", "Tamburini", "Tanganelli", "Tani", "Tanini", "Tapinassi", "Tarchi", "Tarchiani", "Targioni", "Tassi", "Tassini", "Tempesti", "Terzani", "Tesi", "Testa", "Testi", "Tilli", "Tinti", "Tirinnanzi", "Toccafondi", "Tofanari", "Tofani", "Tognaccini", "Tonelli", "Tonini", "Torelli", "Torrini", "Tosi", "Toti", "Tozzi", "Trambusti", "Trapani", "Tucci", "Turchi", "Ugolini", "Ulivi", "Valente", "Valenti", "Valentini", "Vangelisti", "Vanni", "Vannini", "Vannoni", "Vannozzi", "Vannucchi", "Vannucci", "Ventura", "Venturi", "Venturini", "Vestri", "Vettori", "Vichi", "Viciani", "Vieri", "Vigiani", "Vignoli", "Vignolini", "Vignozzi", "Villani", "Vinci", "Visani", "Vitale", "Vitali", "Viti", "Viviani", "Vivoli", "Volpe", "Volpi", "Wang", "Wu", "Xu", "Yang", "Ye", "Zagli", "Zani", "Zanieri", "Zanobini", "Zecchi", "Zetti", "Zhang", "Zheng", "Zhou", "Zhu", "Zingoni", "Zini", "Zoppi"]
	        },
	
	        // Data taken from https://github.com/umpirsky/country-list/blob/master/country/cldr/en_US/country.json
	        countries: [{"name":"Afghanistan","abbreviation":"AF"},{"name":"Albania","abbreviation":"AL"},{"name":"Algeria","abbreviation":"DZ"},{"name":"American Samoa","abbreviation":"AS"},{"name":"Andorra","abbreviation":"AD"},{"name":"Angola","abbreviation":"AO"},{"name":"Anguilla","abbreviation":"AI"},{"name":"Antarctica","abbreviation":"AQ"},{"name":"Antigua and Barbuda","abbreviation":"AG"},{"name":"Argentina","abbreviation":"AR"},{"name":"Armenia","abbreviation":"AM"},{"name":"Aruba","abbreviation":"AW"},{"name":"Australia","abbreviation":"AU"},{"name":"Austria","abbreviation":"AT"},{"name":"Azerbaijan","abbreviation":"AZ"},{"name":"Bahamas","abbreviation":"BS"},{"name":"Bahrain","abbreviation":"BH"},{"name":"Bangladesh","abbreviation":"BD"},{"name":"Barbados","abbreviation":"BB"},{"name":"Belarus","abbreviation":"BY"},{"name":"Belgium","abbreviation":"BE"},{"name":"Belize","abbreviation":"BZ"},{"name":"Benin","abbreviation":"BJ"},{"name":"Bermuda","abbreviation":"BM"},{"name":"Bhutan","abbreviation":"BT"},{"name":"Bolivia","abbreviation":"BO"},{"name":"Bosnia and Herzegovina","abbreviation":"BA"},{"name":"Botswana","abbreviation":"BW"},{"name":"Bouvet Island","abbreviation":"BV"},{"name":"Brazil","abbreviation":"BR"},{"name":"British Antarctic Territory","abbreviation":"BQ"},{"name":"British Indian Ocean Territory","abbreviation":"IO"},{"name":"British Virgin Islands","abbreviation":"VG"},{"name":"Brunei","abbreviation":"BN"},{"name":"Bulgaria","abbreviation":"BG"},{"name":"Burkina Faso","abbreviation":"BF"},{"name":"Burundi","abbreviation":"BI"},{"name":"Cambodia","abbreviation":"KH"},{"name":"Cameroon","abbreviation":"CM"},{"name":"Canada","abbreviation":"CA"},{"name":"Canton and Enderbury Islands","abbreviation":"CT"},{"name":"Cape Verde","abbreviation":"CV"},{"name":"Cayman Islands","abbreviation":"KY"},{"name":"Central African Republic","abbreviation":"CF"},{"name":"Chad","abbreviation":"TD"},{"name":"Chile","abbreviation":"CL"},{"name":"China","abbreviation":"CN"},{"name":"Christmas Island","abbreviation":"CX"},{"name":"Cocos [Keeling] Islands","abbreviation":"CC"},{"name":"Colombia","abbreviation":"CO"},{"name":"Comoros","abbreviation":"KM"},{"name":"Congo - Brazzaville","abbreviation":"CG"},{"name":"Congo - Kinshasa","abbreviation":"CD"},{"name":"Cook Islands","abbreviation":"CK"},{"name":"Costa Rica","abbreviation":"CR"},{"name":"Croatia","abbreviation":"HR"},{"name":"Cuba","abbreviation":"CU"},{"name":"Cyprus","abbreviation":"CY"},{"name":"Czech Republic","abbreviation":"CZ"},{"name":"Côte d’Ivoire","abbreviation":"CI"},{"name":"Denmark","abbreviation":"DK"},{"name":"Djibouti","abbreviation":"DJ"},{"name":"Dominica","abbreviation":"DM"},{"name":"Dominican Republic","abbreviation":"DO"},{"name":"Dronning Maud Land","abbreviation":"NQ"},{"name":"East Germany","abbreviation":"DD"},{"name":"Ecuador","abbreviation":"EC"},{"name":"Egypt","abbreviation":"EG"},{"name":"El Salvador","abbreviation":"SV"},{"name":"Equatorial Guinea","abbreviation":"GQ"},{"name":"Eritrea","abbreviation":"ER"},{"name":"Estonia","abbreviation":"EE"},{"name":"Ethiopia","abbreviation":"ET"},{"name":"Falkland Islands","abbreviation":"FK"},{"name":"Faroe Islands","abbreviation":"FO"},{"name":"Fiji","abbreviation":"FJ"},{"name":"Finland","abbreviation":"FI"},{"name":"France","abbreviation":"FR"},{"name":"French Guiana","abbreviation":"GF"},{"name":"French Polynesia","abbreviation":"PF"},{"name":"French Southern Territories","abbreviation":"TF"},{"name":"French Southern and Antarctic Territories","abbreviation":"FQ"},{"name":"Gabon","abbreviation":"GA"},{"name":"Gambia","abbreviation":"GM"},{"name":"Georgia","abbreviation":"GE"},{"name":"Germany","abbreviation":"DE"},{"name":"Ghana","abbreviation":"GH"},{"name":"Gibraltar","abbreviation":"GI"},{"name":"Greece","abbreviation":"GR"},{"name":"Greenland","abbreviation":"GL"},{"name":"Grenada","abbreviation":"GD"},{"name":"Guadeloupe","abbreviation":"GP"},{"name":"Guam","abbreviation":"GU"},{"name":"Guatemala","abbreviation":"GT"},{"name":"Guernsey","abbreviation":"GG"},{"name":"Guinea","abbreviation":"GN"},{"name":"Guinea-Bissau","abbreviation":"GW"},{"name":"Guyana","abbreviation":"GY"},{"name":"Haiti","abbreviation":"HT"},{"name":"Heard Island and McDonald Islands","abbreviation":"HM"},{"name":"Honduras","abbreviation":"HN"},{"name":"Hong Kong SAR China","abbreviation":"HK"},{"name":"Hungary","abbreviation":"HU"},{"name":"Iceland","abbreviation":"IS"},{"name":"India","abbreviation":"IN"},{"name":"Indonesia","abbreviation":"ID"},{"name":"Iran","abbreviation":"IR"},{"name":"Iraq","abbreviation":"IQ"},{"name":"Ireland","abbreviation":"IE"},{"name":"Isle of Man","abbreviation":"IM"},{"name":"Israel","abbreviation":"IL"},{"name":"Italy","abbreviation":"IT"},{"name":"Jamaica","abbreviation":"JM"},{"name":"Japan","abbreviation":"JP"},{"name":"Jersey","abbreviation":"JE"},{"name":"Johnston Island","abbreviation":"JT"},{"name":"Jordan","abbreviation":"JO"},{"name":"Kazakhstan","abbreviation":"KZ"},{"name":"Kenya","abbreviation":"KE"},{"name":"Kiribati","abbreviation":"KI"},{"name":"Kuwait","abbreviation":"KW"},{"name":"Kyrgyzstan","abbreviation":"KG"},{"name":"Laos","abbreviation":"LA"},{"name":"Latvia","abbreviation":"LV"},{"name":"Lebanon","abbreviation":"LB"},{"name":"Lesotho","abbreviation":"LS"},{"name":"Liberia","abbreviation":"LR"},{"name":"Libya","abbreviation":"LY"},{"name":"Liechtenstein","abbreviation":"LI"},{"name":"Lithuania","abbreviation":"LT"},{"name":"Luxembourg","abbreviation":"LU"},{"name":"Macau SAR China","abbreviation":"MO"},{"name":"Macedonia","abbreviation":"MK"},{"name":"Madagascar","abbreviation":"MG"},{"name":"Malawi","abbreviation":"MW"},{"name":"Malaysia","abbreviation":"MY"},{"name":"Maldives","abbreviation":"MV"},{"name":"Mali","abbreviation":"ML"},{"name":"Malta","abbreviation":"MT"},{"name":"Marshall Islands","abbreviation":"MH"},{"name":"Martinique","abbreviation":"MQ"},{"name":"Mauritania","abbreviation":"MR"},{"name":"Mauritius","abbreviation":"MU"},{"name":"Mayotte","abbreviation":"YT"},{"name":"Metropolitan France","abbreviation":"FX"},{"name":"Mexico","abbreviation":"MX"},{"name":"Micronesia","abbreviation":"FM"},{"name":"Midway Islands","abbreviation":"MI"},{"name":"Moldova","abbreviation":"MD"},{"name":"Monaco","abbreviation":"MC"},{"name":"Mongolia","abbreviation":"MN"},{"name":"Montenegro","abbreviation":"ME"},{"name":"Montserrat","abbreviation":"MS"},{"name":"Morocco","abbreviation":"MA"},{"name":"Mozambique","abbreviation":"MZ"},{"name":"Myanmar [Burma]","abbreviation":"MM"},{"name":"Namibia","abbreviation":"NA"},{"name":"Nauru","abbreviation":"NR"},{"name":"Nepal","abbreviation":"NP"},{"name":"Netherlands","abbreviation":"NL"},{"name":"Netherlands Antilles","abbreviation":"AN"},{"name":"Neutral Zone","abbreviation":"NT"},{"name":"New Caledonia","abbreviation":"NC"},{"name":"New Zealand","abbreviation":"NZ"},{"name":"Nicaragua","abbreviation":"NI"},{"name":"Niger","abbreviation":"NE"},{"name":"Nigeria","abbreviation":"NG"},{"name":"Niue","abbreviation":"NU"},{"name":"Norfolk Island","abbreviation":"NF"},{"name":"North Korea","abbreviation":"KP"},{"name":"North Vietnam","abbreviation":"VD"},{"name":"Northern Mariana Islands","abbreviation":"MP"},{"name":"Norway","abbreviation":"NO"},{"name":"Oman","abbreviation":"OM"},{"name":"Pacific Islands Trust Territory","abbreviation":"PC"},{"name":"Pakistan","abbreviation":"PK"},{"name":"Palau","abbreviation":"PW"},{"name":"Palestinian Territories","abbreviation":"PS"},{"name":"Panama","abbreviation":"PA"},{"name":"Panama Canal Zone","abbreviation":"PZ"},{"name":"Papua New Guinea","abbreviation":"PG"},{"name":"Paraguay","abbreviation":"PY"},{"name":"People's Democratic Republic of Yemen","abbreviation":"YD"},{"name":"Peru","abbreviation":"PE"},{"name":"Philippines","abbreviation":"PH"},{"name":"Pitcairn Islands","abbreviation":"PN"},{"name":"Poland","abbreviation":"PL"},{"name":"Portugal","abbreviation":"PT"},{"name":"Puerto Rico","abbreviation":"PR"},{"name":"Qatar","abbreviation":"QA"},{"name":"Romania","abbreviation":"RO"},{"name":"Russia","abbreviation":"RU"},{"name":"Rwanda","abbreviation":"RW"},{"name":"Réunion","abbreviation":"RE"},{"name":"Saint Barthélemy","abbreviation":"BL"},{"name":"Saint Helena","abbreviation":"SH"},{"name":"Saint Kitts and Nevis","abbreviation":"KN"},{"name":"Saint Lucia","abbreviation":"LC"},{"name":"Saint Martin","abbreviation":"MF"},{"name":"Saint Pierre and Miquelon","abbreviation":"PM"},{"name":"Saint Vincent and the Grenadines","abbreviation":"VC"},{"name":"Samoa","abbreviation":"WS"},{"name":"San Marino","abbreviation":"SM"},{"name":"Saudi Arabia","abbreviation":"SA"},{"name":"Senegal","abbreviation":"SN"},{"name":"Serbia","abbreviation":"RS"},{"name":"Serbia and Montenegro","abbreviation":"CS"},{"name":"Seychelles","abbreviation":"SC"},{"name":"Sierra Leone","abbreviation":"SL"},{"name":"Singapore","abbreviation":"SG"},{"name":"Slovakia","abbreviation":"SK"},{"name":"Slovenia","abbreviation":"SI"},{"name":"Solomon Islands","abbreviation":"SB"},{"name":"Somalia","abbreviation":"SO"},{"name":"South Africa","abbreviation":"ZA"},{"name":"South Georgia and the South Sandwich Islands","abbreviation":"GS"},{"name":"South Korea","abbreviation":"KR"},{"name":"Spain","abbreviation":"ES"},{"name":"Sri Lanka","abbreviation":"LK"},{"name":"Sudan","abbreviation":"SD"},{"name":"Suriname","abbreviation":"SR"},{"name":"Svalbard and Jan Mayen","abbreviation":"SJ"},{"name":"Swaziland","abbreviation":"SZ"},{"name":"Sweden","abbreviation":"SE"},{"name":"Switzerland","abbreviation":"CH"},{"name":"Syria","abbreviation":"SY"},{"name":"São Tomé and Príncipe","abbreviation":"ST"},{"name":"Taiwan","abbreviation":"TW"},{"name":"Tajikistan","abbreviation":"TJ"},{"name":"Tanzania","abbreviation":"TZ"},{"name":"Thailand","abbreviation":"TH"},{"name":"Timor-Leste","abbreviation":"TL"},{"name":"Togo","abbreviation":"TG"},{"name":"Tokelau","abbreviation":"TK"},{"name":"Tonga","abbreviation":"TO"},{"name":"Trinidad and Tobago","abbreviation":"TT"},{"name":"Tunisia","abbreviation":"TN"},{"name":"Turkey","abbreviation":"TR"},{"name":"Turkmenistan","abbreviation":"TM"},{"name":"Turks and Caicos Islands","abbreviation":"TC"},{"name":"Tuvalu","abbreviation":"TV"},{"name":"U.S. Minor Outlying Islands","abbreviation":"UM"},{"name":"U.S. Miscellaneous Pacific Islands","abbreviation":"PU"},{"name":"U.S. Virgin Islands","abbreviation":"VI"},{"name":"Uganda","abbreviation":"UG"},{"name":"Ukraine","abbreviation":"UA"},{"name":"Union of Soviet Socialist Republics","abbreviation":"SU"},{"name":"United Arab Emirates","abbreviation":"AE"},{"name":"United Kingdom","abbreviation":"GB"},{"name":"United States","abbreviation":"US"},{"name":"Unknown or Invalid Region","abbreviation":"ZZ"},{"name":"Uruguay","abbreviation":"UY"},{"name":"Uzbekistan","abbreviation":"UZ"},{"name":"Vanuatu","abbreviation":"VU"},{"name":"Vatican City","abbreviation":"VA"},{"name":"Venezuela","abbreviation":"VE"},{"name":"Vietnam","abbreviation":"VN"},{"name":"Wake Island","abbreviation":"WK"},{"name":"Wallis and Futuna","abbreviation":"WF"},{"name":"Western Sahara","abbreviation":"EH"},{"name":"Yemen","abbreviation":"YE"},{"name":"Zambia","abbreviation":"ZM"},{"name":"Zimbabwe","abbreviation":"ZW"},{"name":"Åland Islands","abbreviation":"AX"}],
	
	        provinces: {
	            "ca": [
	                {name: 'Alberta', abbreviation: 'AB'},
	                {name: 'British Columbia', abbreviation: 'BC'},
	                {name: 'Manitoba', abbreviation: 'MB'},
	                {name: 'New Brunswick', abbreviation: 'NB'},
	                {name: 'Newfoundland and Labrador', abbreviation: 'NL'},
	                {name: 'Nova Scotia', abbreviation: 'NS'},
	                {name: 'Ontario', abbreviation: 'ON'},
	                {name: 'Prince Edward Island', abbreviation: 'PE'},
	                {name: 'Quebec', abbreviation: 'QC'},
	                {name: 'Saskatchewan', abbreviation: 'SK'},
	
	                // The case could be made that the following are not actually provinces
	                // since they are technically considered "territories" however they all
	                // look the same on an envelope!
	                {name: 'Northwest Territories', abbreviation: 'NT'},
	                {name: 'Nunavut', abbreviation: 'NU'},
	                {name: 'Yukon', abbreviation: 'YT'}
	            ],
	            "it": [
	                { name: "Agrigento", abbreviation: "AG", code: 84 },
	                { name: "Alessandria", abbreviation: "AL", code: 6 },
	                { name: "Ancona", abbreviation: "AN", code: 42 },
	                { name: "Aosta", abbreviation: "AO", code: 7 },
	                { name: "L'Aquila", abbreviation: "AQ", code: 66 },
	                { name: "Arezzo", abbreviation: "AR", code: 51 },
	                { name: "Ascoli-Piceno", abbreviation: "AP", code: 44 },
	                { name: "Asti", abbreviation: "AT", code: 5 },
	                { name: "Avellino", abbreviation: "AV", code: 64 },
	                { name: "Bari", abbreviation: "BA", code: 72 },
	                { name: "Barletta-Andria-Trani", abbreviation: "BT", code: 72 },
	                { name: "Belluno", abbreviation: "BL", code: 25 },
	                { name: "Benevento", abbreviation: "BN", code: 62 },
	                { name: "Bergamo", abbreviation: "BG", code: 16 },
	                { name: "Biella", abbreviation: "BI", code: 96 },
	                { name: "Bologna", abbreviation: "BO", code: 37 },
	                { name: "Bolzano", abbreviation: "BZ", code: 21 },
	                { name: "Brescia", abbreviation: "BS", code: 17 },
	                { name: "Brindisi", abbreviation: "BR", code: 74 },
	                { name: "Cagliari", abbreviation: "CA", code: 92 },
	                { name: "Caltanissetta", abbreviation: "CL", code: 85 },
	                { name: "Campobasso", abbreviation: "CB", code: 70 },
	                { name: "Carbonia Iglesias", abbreviation: "CI", code: 70 },
	                { name: "Caserta", abbreviation: "CE", code: 61 },
	                { name: "Catania", abbreviation: "CT", code: 87 },
	                { name: "Catanzaro", abbreviation: "CZ", code: 79 },
	                { name: "Chieti", abbreviation: "CH", code: 69 },
	                { name: "Como", abbreviation: "CO", code: 13 },
	                { name: "Cosenza", abbreviation: "CS", code: 78 },
	                { name: "Cremona", abbreviation: "CR", code: 19 },
	                { name: "Crotone", abbreviation: "KR", code: 101 },
	                { name: "Cuneo", abbreviation: "CN", code: 4 },
	                { name: "Enna", abbreviation: "EN", code: 86 },
	                { name: "Fermo", abbreviation: "FM", code: 86 },
	                { name: "Ferrara", abbreviation: "FE", code: 38 },
	                { name: "Firenze", abbreviation: "FI", code: 48 },
	                { name: "Foggia", abbreviation: "FG", code: 71 },
	                { name: "Forli-Cesena", abbreviation: "FC", code: 71 },
	                { name: "Frosinone", abbreviation: "FR", code: 60 },
	                { name: "Genova", abbreviation: "GE", code: 10 },
	                { name: "Gorizia", abbreviation: "GO", code: 31 },
	                { name: "Grosseto", abbreviation: "GR", code: 53 },
	                { name: "Imperia", abbreviation: "IM", code: 8 },
	                { name: "Isernia", abbreviation: "IS", code: 94 },
	                { name: "La-Spezia", abbreviation: "SP", code: 66 },
	                { name: "Latina", abbreviation: "LT", code: 59 },
	                { name: "Lecce", abbreviation: "LE", code: 75 },
	                { name: "Lecco", abbreviation: "LC", code: 97 },
	                { name: "Livorno", abbreviation: "LI", code: 49 },
	                { name: "Lodi", abbreviation: "LO", code: 98 },
	                { name: "Lucca", abbreviation: "LU", code: 46 },
	                { name: "Macerata", abbreviation: "MC", code: 43 },
	                { name: "Mantova", abbreviation: "MN", code: 20 },
	                { name: "Massa-Carrara", abbreviation: "MS", code: 45 },
	                { name: "Matera", abbreviation: "MT", code: 77 },
	                { name: "Medio Campidano", abbreviation: "VS", code: 77 },
	                { name: "Messina", abbreviation: "ME", code: 83 },
	                { name: "Milano", abbreviation: "MI", code: 15 },
	                { name: "Modena", abbreviation: "MO", code: 36 },
	                { name: "Monza-Brianza", abbreviation: "MB", code: 36 },
	                { name: "Napoli", abbreviation: "NA", code: 63 },
	                { name: "Novara", abbreviation: "NO", code: 3 },
	                { name: "Nuoro", abbreviation: "NU", code: 91 },
	                { name: "Ogliastra", abbreviation: "OG", code: 91 },
	                { name: "Olbia Tempio", abbreviation: "OT", code: 91 },
	                { name: "Oristano", abbreviation: "OR", code: 95 },
	                { name: "Padova", abbreviation: "PD", code: 28 },
	                { name: "Palermo", abbreviation: "PA", code: 82 },
	                { name: "Parma", abbreviation: "PR", code: 34 },
	                { name: "Pavia", abbreviation: "PV", code: 18 },
	                { name: "Perugia", abbreviation: "PG", code: 54 },
	                { name: "Pesaro-Urbino", abbreviation: "PU", code: 41 },
	                { name: "Pescara", abbreviation: "PE", code: 68 },
	                { name: "Piacenza", abbreviation: "PC", code: 33 },
	                { name: "Pisa", abbreviation: "PI", code: 50 },
	                { name: "Pistoia", abbreviation: "PT", code: 47 },
	                { name: "Pordenone", abbreviation: "PN", code: 93 },
	                { name: "Potenza", abbreviation: "PZ", code: 76 },
	                { name: "Prato", abbreviation: "PO", code: 100 },
	                { name: "Ragusa", abbreviation: "RG", code: 88 },
	                { name: "Ravenna", abbreviation: "RA", code: 39 },
	                { name: "Reggio-Calabria", abbreviation: "RC", code: 35 },
	                { name: "Reggio-Emilia", abbreviation: "RE", code: 35 },
	                { name: "Rieti", abbreviation: "RI", code: 57 },
	                { name: "Rimini", abbreviation: "RN", code: 99 },
	                { name: "Roma", abbreviation: "Roma", code: 58 },
	                { name: "Rovigo", abbreviation: "RO", code: 29 },
	                { name: "Salerno", abbreviation: "SA", code: 65 },
	                { name: "Sassari", abbreviation: "SS", code: 90 },
	                { name: "Savona", abbreviation: "SV", code: 9 },
	                { name: "Siena", abbreviation: "SI", code: 52 },
	                { name: "Siracusa", abbreviation: "SR", code: 89 },
	                { name: "Sondrio", abbreviation: "SO", code: 14 },
	                { name: "Taranto", abbreviation: "TA", code: 73 },
	                { name: "Teramo", abbreviation: "TE", code: 67 },
	                { name: "Terni", abbreviation: "TR", code: 55 },
	                { name: "Torino", abbreviation: "TO", code: 1 },
	                { name: "Trapani", abbreviation: "TP", code: 81 },
	                { name: "Trento", abbreviation: "TN", code: 22 },
	                { name: "Treviso", abbreviation: "TV", code: 26 },
	                { name: "Trieste", abbreviation: "TS", code: 32 },
	                { name: "Udine", abbreviation: "UD", code: 30 },
	                { name: "Varese", abbreviation: "VA", code: 12 },
	                { name: "Venezia", abbreviation: "VE", code: 27 },
	                { name: "Verbania", abbreviation: "VB", code: 27 },
	                { name: "Vercelli", abbreviation: "VC", code: 2 },
	                { name: "Verona", abbreviation: "VR", code: 23 },
	                { name: "Vibo-Valentia", abbreviation: "VV", code: 102 },
	                { name: "Vicenza", abbreviation: "VI", code: 24 },
	                { name: "Viterbo", abbreviation: "VT", code: 56 }   
	            ]
	        },
	
	            // from: https://github.com/samsargent/Useful-Autocomplete-Data/blob/master/data/nationalities.json
	        nationalities: [
	           {name: 'Afghan'},
	           {name: 'Albanian'},
	           {name: 'Algerian'},
	           {name: 'American'},
	           {name: 'Andorran'},
	           {name: 'Angolan'},
	           {name: 'Antiguans'},
	           {name: 'Argentinean'},
	           {name: 'Armenian'},
	           {name: 'Australian'},
	           {name: 'Austrian'},
	           {name: 'Azerbaijani'},
	           {name: 'Bahami'},
	           {name: 'Bahraini'},
	           {name: 'Bangladeshi'},
	           {name: 'Barbadian'},
	           {name: 'Barbudans'},
	           {name: 'Batswana'},
	           {name: 'Belarusian'},
	           {name: 'Belgian'},
	           {name: 'Belizean'},
	           {name: 'Beninese'},
	           {name: 'Bhutanese'},
	           {name: 'Bolivian'},
	           {name: 'Bosnian'},
	           {name: 'Brazilian'},
	           {name: 'British'},
	           {name: 'Bruneian'},
	           {name: 'Bulgarian'},
	           {name: 'Burkinabe'},
	           {name: 'Burmese'},
	           {name: 'Burundian'},
	           {name: 'Cambodian'},
	           {name: 'Cameroonian'},
	           {name: 'Canadian'},
	           {name: 'Cape Verdean'},
	           {name: 'Central African'},
	           {name: 'Chadian'},
	           {name: 'Chilean'},
	           {name: 'Chinese'},
	           {name: 'Colombian'},
	           {name: 'Comoran'},
	           {name: 'Congolese'},
	           {name: 'Costa Rican'},
	           {name: 'Croatian'},
	           {name: 'Cuban'},
	           {name: 'Cypriot'},
	           {name: 'Czech'},
	           {name: 'Danish'},
	           {name: 'Djibouti'},
	           {name: 'Dominican'},
	           {name: 'Dutch'},
	           {name: 'East Timorese'},
	           {name: 'Ecuadorean'},
	           {name: 'Egyptian'},
	           {name: 'Emirian'},
	           {name: 'Equatorial Guinean'},
	           {name: 'Eritrean'},
	           {name: 'Estonian'},
	           {name: 'Ethiopian'},
	           {name: 'Fijian'},
	           {name: 'Filipino'},
	           {name: 'Finnish'},
	           {name: 'French'},
	           {name: 'Gabonese'},
	           {name: 'Gambian'},
	           {name: 'Georgian'},
	           {name: 'German'},
	           {name: 'Ghanaian'},
	           {name: 'Greek'},
	           {name: 'Grenadian'},
	           {name: 'Guatemalan'},
	           {name: 'Guinea-Bissauan'},
	           {name: 'Guinean'},
	           {name: 'Guyanese'},
	           {name: 'Haitian'},
	           {name: 'Herzegovinian'},
	           {name: 'Honduran'},
	           {name: 'Hungarian'},
	           {name: 'I-Kiribati'},
	           {name: 'Icelander'},
	           {name: 'Indian'},
	           {name: 'Indonesian'},
	           {name: 'Iranian'},
	           {name: 'Iraqi'},
	           {name: 'Irish'},
	           {name: 'Israeli'},
	           {name: 'Italian'},
	           {name: 'Ivorian'},
	           {name: 'Jamaican'},
	           {name: 'Japanese'},
	           {name: 'Jordanian'},
	           {name: 'Kazakhstani'},
	           {name: 'Kenyan'},
	           {name: 'Kittian and Nevisian'},
	           {name: 'Kuwaiti'},
	           {name: 'Kyrgyz'},
	           {name: 'Laotian'},
	           {name: 'Latvian'},
	           {name: 'Lebanese'},
	           {name: 'Liberian'},
	           {name: 'Libyan'},
	           {name: 'Liechtensteiner'},
	           {name: 'Lithuanian'},
	           {name: 'Luxembourger'},
	           {name: 'Macedonian'},
	           {name: 'Malagasy'},
	           {name: 'Malawian'},
	           {name: 'Malaysian'},
	           {name: 'Maldivan'},
	           {name: 'Malian'},
	           {name: 'Maltese'},
	           {name: 'Marshallese'},
	           {name: 'Mauritanian'},
	           {name: 'Mauritian'},
	           {name: 'Mexican'},
	           {name: 'Micronesian'},
	           {name: 'Moldovan'},
	           {name: 'Monacan'},
	           {name: 'Mongolian'},
	           {name: 'Moroccan'},
	           {name: 'Mosotho'},
	           {name: 'Motswana'},
	           {name: 'Mozambican'},
	           {name: 'Namibian'},
	           {name: 'Nauruan'},
	           {name: 'Nepalese'},
	           {name: 'New Zealander'},
	           {name: 'Nicaraguan'},
	           {name: 'Nigerian'},
	           {name: 'Nigerien'},
	           {name: 'North Korean'},
	           {name: 'Northern Irish'},
	           {name: 'Norwegian'},
	           {name: 'Omani'},
	           {name: 'Pakistani'},
	           {name: 'Palauan'},
	           {name: 'Panamanian'},
	           {name: 'Papua New Guinean'},
	           {name: 'Paraguayan'},
	           {name: 'Peruvian'},
	           {name: 'Polish'},
	           {name: 'Portuguese'},
	           {name: 'Qatari'},
	           {name: 'Romani'},          
	           {name: 'Russian'},
	           {name: 'Rwandan'},
	           {name: 'Saint Lucian'},
	           {name: 'Salvadoran'},
	           {name: 'Samoan'},
	           {name: 'San Marinese'},
	           {name: 'Sao Tomean'},
	           {name: 'Saudi'},
	           {name: 'Scottish'},
	           {name: 'Senegalese'},
	           {name: 'Serbian'},
	           {name: 'Seychellois'},
	           {name: 'Sierra Leonean'},
	           {name: 'Singaporean'},
	           {name: 'Slovakian'},
	           {name: 'Slovenian'},
	           {name: 'Solomon Islander'},
	           {name: 'Somali'},
	           {name: 'South African'},
	           {name: 'South Korean'},
	           {name: 'Spanish'},
	           {name: 'Sri Lankan'},
	           {name: 'Sudanese'},
	           {name: 'Surinamer'},
	           {name: 'Swazi'},
	           {name: 'Swedish'},
	           {name: 'Swiss'},
	           {name: 'Syrian'},
	           {name: 'Taiwanese'},
	           {name: 'Tajik'},
	           {name: 'Tanzanian'},
	           {name: 'Thai'},
	           {name: 'Togolese'},
	           {name: 'Tongan'},
	           {name: 'Trinidadian or Tobagonian'},
	           {name: 'Tunisian'},
	           {name: 'Turkish'},
	           {name: 'Tuvaluan'},
	           {name: 'Ugandan'},
	           {name: 'Ukrainian'},
	           {name: 'Uruguaya'},
	           {name: 'Uzbekistani'},
	           {name: 'Venezuela'},
	           {name: 'Vietnamese'},
	           {name: 'Wels'},
	           {name: 'Yemenit'},
	           {name: 'Zambia'},
	           {name: 'Zimbabwe'},
	        ],
	
	        us_states_and_dc: [
	            {name: 'Alabama', abbreviation: 'AL'},
	            {name: 'Alaska', abbreviation: 'AK'},
	            {name: 'Arizona', abbreviation: 'AZ'},
	            {name: 'Arkansas', abbreviation: 'AR'},
	            {name: 'California', abbreviation: 'CA'},
	            {name: 'Colorado', abbreviation: 'CO'},
	            {name: 'Connecticut', abbreviation: 'CT'},
	            {name: 'Delaware', abbreviation: 'DE'},
	            {name: 'District of Columbia', abbreviation: 'DC'},
	            {name: 'Florida', abbreviation: 'FL'},
	            {name: 'Georgia', abbreviation: 'GA'},
	            {name: 'Hawaii', abbreviation: 'HI'},
	            {name: 'Idaho', abbreviation: 'ID'},
	            {name: 'Illinois', abbreviation: 'IL'},
	            {name: 'Indiana', abbreviation: 'IN'},
	            {name: 'Iowa', abbreviation: 'IA'},
	            {name: 'Kansas', abbreviation: 'KS'},
	            {name: 'Kentucky', abbreviation: 'KY'},
	            {name: 'Louisiana', abbreviation: 'LA'},
	            {name: 'Maine', abbreviation: 'ME'},
	            {name: 'Maryland', abbreviation: 'MD'},
	            {name: 'Massachusetts', abbreviation: 'MA'},
	            {name: 'Michigan', abbreviation: 'MI'},
	            {name: 'Minnesota', abbreviation: 'MN'},
	            {name: 'Mississippi', abbreviation: 'MS'},
	            {name: 'Missouri', abbreviation: 'MO'},
	            {name: 'Montana', abbreviation: 'MT'},
	            {name: 'Nebraska', abbreviation: 'NE'},
	            {name: 'Nevada', abbreviation: 'NV'},
	            {name: 'New Hampshire', abbreviation: 'NH'},
	            {name: 'New Jersey', abbreviation: 'NJ'},
	            {name: 'New Mexico', abbreviation: 'NM'},
	            {name: 'New York', abbreviation: 'NY'},
	            {name: 'North Carolina', abbreviation: 'NC'},
	            {name: 'North Dakota', abbreviation: 'ND'},
	            {name: 'Ohio', abbreviation: 'OH'},
	            {name: 'Oklahoma', abbreviation: 'OK'},
	            {name: 'Oregon', abbreviation: 'OR'},
	            {name: 'Pennsylvania', abbreviation: 'PA'},
	            {name: 'Rhode Island', abbreviation: 'RI'},
	            {name: 'South Carolina', abbreviation: 'SC'},
	            {name: 'South Dakota', abbreviation: 'SD'},
	            {name: 'Tennessee', abbreviation: 'TN'},
	            {name: 'Texas', abbreviation: 'TX'},
	            {name: 'Utah', abbreviation: 'UT'},
	            {name: 'Vermont', abbreviation: 'VT'},
	            {name: 'Virginia', abbreviation: 'VA'},
	            {name: 'Washington', abbreviation: 'WA'},
	            {name: 'West Virginia', abbreviation: 'WV'},
	            {name: 'Wisconsin', abbreviation: 'WI'},
	            {name: 'Wyoming', abbreviation: 'WY'}
	        ],
	
	        territories: [
	            {name: 'American Samoa', abbreviation: 'AS'},
	            {name: 'Federated States of Micronesia', abbreviation: 'FM'},
	            {name: 'Guam', abbreviation: 'GU'},
	            {name: 'Marshall Islands', abbreviation: 'MH'},
	            {name: 'Northern Mariana Islands', abbreviation: 'MP'},
	            {name: 'Puerto Rico', abbreviation: 'PR'},
	            {name: 'Virgin Islands, U.S.', abbreviation: 'VI'}
	        ],
	
	        armed_forces: [
	            {name: 'Armed Forces Europe', abbreviation: 'AE'},
	            {name: 'Armed Forces Pacific', abbreviation: 'AP'},
	            {name: 'Armed Forces the Americas', abbreviation: 'AA'}
	        ],
	
	        country_regions: {
	            it: [
	                { name: "Valle d'Aosta", abbreviation: "VDA" },
	                { name: "Piemonte", abbreviation: "PIE" },
	                { name: "Lombardia", abbreviation: "LOM" },
	                { name: "Veneto", abbreviation: "VEN" },
	                { name: "Trentino Alto Adige", abbreviation: "TAA" },
	                { name: "Friuli Venezia Giulia", abbreviation: "FVG" },
	                { name: "Liguria", abbreviation: "LIG" },
	                { name: "Emilia Romagna", abbreviation: "EMR" },
	                { name: "Toscana", abbreviation: "TOS" },
	                { name: "Umbria", abbreviation: "UMB" },
	                { name: "Marche", abbreviation: "MAR" },
	                { name: "Abruzzo", abbreviation: "ABR" },
	                { name: "Lazio", abbreviation: "LAZ" },
	                { name: "Campania", abbreviation: "CAM" },
	                { name: "Puglia", abbreviation: "PUG" },
	                { name: "Basilicata", abbreviation: "BAS" },
	                { name: "Molise", abbreviation: "MOL" },
	                { name: "Calabria", abbreviation: "CAL" },
	                { name: "Sicilia", abbreviation: "SIC" },
	                { name: "Sardegna", abbreviation: "SAR" }
	            ]
	        },
	
	        street_suffixes: {
	            'us': [
	                {name: 'Avenue', abbreviation: 'Ave'},
	                {name: 'Boulevard', abbreviation: 'Blvd'},
	                {name: 'Center', abbreviation: 'Ctr'},
	                {name: 'Circle', abbreviation: 'Cir'},
	                {name: 'Court', abbreviation: 'Ct'},
	                {name: 'Drive', abbreviation: 'Dr'},
	                {name: 'Extension', abbreviation: 'Ext'},
	                {name: 'Glen', abbreviation: 'Gln'},
	                {name: 'Grove', abbreviation: 'Grv'},
	                {name: 'Heights', abbreviation: 'Hts'},
	                {name: 'Highway', abbreviation: 'Hwy'},
	                {name: 'Junction', abbreviation: 'Jct'},
	                {name: 'Key', abbreviation: 'Key'},
	                {name: 'Lane', abbreviation: 'Ln'},
	                {name: 'Loop', abbreviation: 'Loop'},
	                {name: 'Manor', abbreviation: 'Mnr'},
	                {name: 'Mill', abbreviation: 'Mill'},
	                {name: 'Park', abbreviation: 'Park'},
	                {name: 'Parkway', abbreviation: 'Pkwy'},
	                {name: 'Pass', abbreviation: 'Pass'},
	                {name: 'Path', abbreviation: 'Path'},
	                {name: 'Pike', abbreviation: 'Pike'},
	                {name: 'Place', abbreviation: 'Pl'},
	                {name: 'Plaza', abbreviation: 'Plz'},
	                {name: 'Point', abbreviation: 'Pt'},
	                {name: 'Ridge', abbreviation: 'Rdg'},
	                {name: 'River', abbreviation: 'Riv'},
	                {name: 'Road', abbreviation: 'Rd'},
	                {name: 'Square', abbreviation: 'Sq'},
	                {name: 'Street', abbreviation: 'St'},
	                {name: 'Terrace', abbreviation: 'Ter'},
	                {name: 'Trail', abbreviation: 'Trl'},
	                {name: 'Turnpike', abbreviation: 'Tpke'},
	                {name: 'View', abbreviation: 'Vw'},
	                {name: 'Way', abbreviation: 'Way'}
	            ],
	            'it': [
	                { name: 'Accesso', abbreviation: 'Acc.' },
	                { name: 'Alzaia', abbreviation: 'Alz.' },
	                { name: 'Arco', abbreviation: 'Arco' },
	                { name: 'Archivolto', abbreviation: 'Acv.' },
	                { name: 'Arena', abbreviation: 'Arena' },
	                { name: 'Argine', abbreviation: 'Argine' },
	                { name: 'Bacino', abbreviation: 'Bacino' },
	                { name: 'Banchi', abbreviation: 'Banchi' },
	                { name: 'Banchina', abbreviation: 'Ban.' },
	                { name: 'Bastioni', abbreviation: 'Bas.' },
	                { name: 'Belvedere', abbreviation: 'Belv.' },
	                { name: 'Borgata', abbreviation: 'B.ta' },
	                { name: 'Borgo', abbreviation: 'B.go' },
	                { name: 'Calata', abbreviation: 'Cal.' },
	                { name: 'Calle', abbreviation: 'Calle' },
	                { name: 'Campiello', abbreviation: 'Cam.' },
	                { name: 'Campo', abbreviation: 'Cam.' },
	                { name: 'Canale', abbreviation: 'Can.' },
	                { name: 'Carraia', abbreviation: 'Carr.' },
	                { name: 'Cascina', abbreviation: 'Cascina' },
	                { name: 'Case sparse', abbreviation: 'c.s.' },
	                { name: 'Cavalcavia', abbreviation: 'Cv.' },
	                { name: 'Circonvallazione', abbreviation: 'Cv.' },
	                { name: 'Complanare', abbreviation: 'C.re' },
	                { name: 'Contrada', abbreviation: 'C.da' },
	                { name: 'Corso', abbreviation: 'C.so' },
	                { name: 'Corte', abbreviation: 'C.te' },
	                { name: 'Cortile', abbreviation: 'C.le' },
	                { name: 'Diramazione', abbreviation: 'Dir.' },
	                { name: 'Fondaco', abbreviation: 'F.co' },
	                { name: 'Fondamenta', abbreviation: 'F.ta' },
	                { name: 'Fondo', abbreviation: 'F.do' },
	                { name: 'Frazione', abbreviation: 'Fr.' },
	                { name: 'Isola', abbreviation: 'Is.' },
	                { name: 'Largo', abbreviation: 'L.go' },
	                { name: 'Litoranea', abbreviation: 'Lit.' },
	                { name: 'Lungolago', abbreviation: 'L.go lago' },
	                { name: 'Lungo Po', abbreviation: 'l.go Po' },
	                { name: 'Molo', abbreviation: 'Molo' },
	                { name: 'Mura', abbreviation: 'Mura' },
	                { name: 'Passaggio privato', abbreviation: 'pass. priv.' },
	                { name: 'Passeggiata', abbreviation: 'Pass.' },
	                { name: 'Piazza', abbreviation: 'P.zza' },
	                { name: 'Piazzale', abbreviation: 'P.le' },
	                { name: 'Ponte', abbreviation: 'P.te' },
	                { name: 'Portico', abbreviation: 'P.co' },
	                { name: 'Rampa', abbreviation: 'Rampa' },
	                { name: 'Regione', abbreviation: 'Reg.' },
	                { name: 'Rione', abbreviation: 'R.ne' },
	                { name: 'Rio', abbreviation: 'Rio' },
	                { name: 'Ripa', abbreviation: 'Ripa' },
	                { name: 'Riva', abbreviation: 'Riva' },
	                { name: 'Rondò', abbreviation: 'Rondò' },
	                { name: 'Rotonda', abbreviation: 'Rot.' },
	                { name: 'Sagrato', abbreviation: 'Sagr.' },
	                { name: 'Salita', abbreviation: 'Sal.' },
	                { name: 'Scalinata', abbreviation: 'Scal.' },
	                { name: 'Scalone', abbreviation: 'Scal.' },
	                { name: 'Slargo', abbreviation: 'Sl.' },
	                { name: 'Sottoportico', abbreviation: 'Sott.' },
	                { name: 'Strada', abbreviation: 'Str.' },
	                { name: 'Stradale', abbreviation: 'Str.le' },
	                { name: 'Strettoia', abbreviation: 'Strett.' },
	                { name: 'Traversa', abbreviation: 'Trav.' },
	                { name: 'Via', abbreviation: 'V.' },
	                { name: 'Viale', abbreviation: 'V.le' },
	                { name: 'Vicinale', abbreviation: 'Vic.le' },
	                { name: 'Vicolo', abbreviation: 'Vic.' }
	            ]
	        },
	
	        months: [
	            {name: 'January', short_name: 'Jan', numeric: '01', days: 31},
	            // Not messing with leap years...
	            {name: 'February', short_name: 'Feb', numeric: '02', days: 28},
	            {name: 'March', short_name: 'Mar', numeric: '03', days: 31},
	            {name: 'April', short_name: 'Apr', numeric: '04', days: 30},
	            {name: 'May', short_name: 'May', numeric: '05', days: 31},
	            {name: 'June', short_name: 'Jun', numeric: '06', days: 30},
	            {name: 'July', short_name: 'Jul', numeric: '07', days: 31},
	            {name: 'August', short_name: 'Aug', numeric: '08', days: 31},
	            {name: 'September', short_name: 'Sep', numeric: '09', days: 30},
	            {name: 'October', short_name: 'Oct', numeric: '10', days: 31},
	            {name: 'November', short_name: 'Nov', numeric: '11', days: 30},
	            {name: 'December', short_name: 'Dec', numeric: '12', days: 31}
	        ],
	
	        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
	        cc_types: [
	            {name: "American Express", short_name: 'amex', prefix: '34', length: 15},
	            {name: "Bankcard", short_name: 'bankcard', prefix: '5610', length: 16},
	            {name: "China UnionPay", short_name: 'chinaunion', prefix: '62', length: 16},
	            {name: "Diners Club Carte Blanche", short_name: 'dccarte', prefix: '300', length: 14},
	            {name: "Diners Club enRoute", short_name: 'dcenroute', prefix: '2014', length: 15},
	            {name: "Diners Club International", short_name: 'dcintl', prefix: '36', length: 14},
	            {name: "Diners Club United States & Canada", short_name: 'dcusc', prefix: '54', length: 16},
	            {name: "Discover Card", short_name: 'discover', prefix: '6011', length: 16},
	            {name: "InstaPayment", short_name: 'instapay', prefix: '637', length: 16},
	            {name: "JCB", short_name: 'jcb', prefix: '3528', length: 16},
	            {name: "Laser", short_name: 'laser', prefix: '6304', length: 16},
	            {name: "Maestro", short_name: 'maestro', prefix: '5018', length: 16},
	            {name: "Mastercard", short_name: 'mc', prefix: '51', length: 16},
	            {name: "Solo", short_name: 'solo', prefix: '6334', length: 16},
	            {name: "Switch", short_name: 'switch', prefix: '4903', length: 16},
	            {name: "Visa", short_name: 'visa', prefix: '4', length: 16},
	            {name: "Visa Electron", short_name: 'electron', prefix: '4026', length: 16}
	        ],
	
	        //return all world currency by ISO 4217
	        currency_types: [
	            {'code' : 'AED', 'name' : 'United Arab Emirates Dirham'},
	            {'code' : 'AFN', 'name' : 'Afghanistan Afghani'},
	            {'code' : 'ALL', 'name' : 'Albania Lek'},
	            {'code' : 'AMD', 'name' : 'Armenia Dram'},
	            {'code' : 'ANG', 'name' : 'Netherlands Antilles Guilder'},
	            {'code' : 'AOA', 'name' : 'Angola Kwanza'},
	            {'code' : 'ARS', 'name' : 'Argentina Peso'},
	            {'code' : 'AUD', 'name' : 'Australia Dollar'},
	            {'code' : 'AWG', 'name' : 'Aruba Guilder'},
	            {'code' : 'AZN', 'name' : 'Azerbaijan New Manat'},
	            {'code' : 'BAM', 'name' : 'Bosnia and Herzegovina Convertible Marka'},
	            {'code' : 'BBD', 'name' : 'Barbados Dollar'},
	            {'code' : 'BDT', 'name' : 'Bangladesh Taka'},
	            {'code' : 'BGN', 'name' : 'Bulgaria Lev'},
	            {'code' : 'BHD', 'name' : 'Bahrain Dinar'},
	            {'code' : 'BIF', 'name' : 'Burundi Franc'},
	            {'code' : 'BMD', 'name' : 'Bermuda Dollar'},
	            {'code' : 'BND', 'name' : 'Brunei Darussalam Dollar'},
	            {'code' : 'BOB', 'name' : 'Bolivia Boliviano'},
	            {'code' : 'BRL', 'name' : 'Brazil Real'},
	            {'code' : 'BSD', 'name' : 'Bahamas Dollar'},
	            {'code' : 'BTN', 'name' : 'Bhutan Ngultrum'},
	            {'code' : 'BWP', 'name' : 'Botswana Pula'},
	            {'code' : 'BYR', 'name' : 'Belarus Ruble'},
	            {'code' : 'BZD', 'name' : 'Belize Dollar'},
	            {'code' : 'CAD', 'name' : 'Canada Dollar'},
	            {'code' : 'CDF', 'name' : 'Congo/Kinshasa Franc'},
	            {'code' : 'CHF', 'name' : 'Switzerland Franc'},
	            {'code' : 'CLP', 'name' : 'Chile Peso'},
	            {'code' : 'CNY', 'name' : 'China Yuan Renminbi'},
	            {'code' : 'COP', 'name' : 'Colombia Peso'},
	            {'code' : 'CRC', 'name' : 'Costa Rica Colon'},
	            {'code' : 'CUC', 'name' : 'Cuba Convertible Peso'},
	            {'code' : 'CUP', 'name' : 'Cuba Peso'},
	            {'code' : 'CVE', 'name' : 'Cape Verde Escudo'},
	            {'code' : 'CZK', 'name' : 'Czech Republic Koruna'},
	            {'code' : 'DJF', 'name' : 'Djibouti Franc'},
	            {'code' : 'DKK', 'name' : 'Denmark Krone'},
	            {'code' : 'DOP', 'name' : 'Dominican Republic Peso'},
	            {'code' : 'DZD', 'name' : 'Algeria Dinar'},
	            {'code' : 'EGP', 'name' : 'Egypt Pound'},
	            {'code' : 'ERN', 'name' : 'Eritrea Nakfa'},
	            {'code' : 'ETB', 'name' : 'Ethiopia Birr'},
	            {'code' : 'EUR', 'name' : 'Euro Member Countries'},
	            {'code' : 'FJD', 'name' : 'Fiji Dollar'},
	            {'code' : 'FKP', 'name' : 'Falkland Islands (Malvinas) Pound'},
	            {'code' : 'GBP', 'name' : 'United Kingdom Pound'},
	            {'code' : 'GEL', 'name' : 'Georgia Lari'},
	            {'code' : 'GGP', 'name' : 'Guernsey Pound'},
	            {'code' : 'GHS', 'name' : 'Ghana Cedi'},
	            {'code' : 'GIP', 'name' : 'Gibraltar Pound'},
	            {'code' : 'GMD', 'name' : 'Gambia Dalasi'},
	            {'code' : 'GNF', 'name' : 'Guinea Franc'},
	            {'code' : 'GTQ', 'name' : 'Guatemala Quetzal'},
	            {'code' : 'GYD', 'name' : 'Guyana Dollar'},
	            {'code' : 'HKD', 'name' : 'Hong Kong Dollar'},
	            {'code' : 'HNL', 'name' : 'Honduras Lempira'},
	            {'code' : 'HRK', 'name' : 'Croatia Kuna'},
	            {'code' : 'HTG', 'name' : 'Haiti Gourde'},
	            {'code' : 'HUF', 'name' : 'Hungary Forint'},
	            {'code' : 'IDR', 'name' : 'Indonesia Rupiah'},
	            {'code' : 'ILS', 'name' : 'Israel Shekel'},
	            {'code' : 'IMP', 'name' : 'Isle of Man Pound'},
	            {'code' : 'INR', 'name' : 'India Rupee'},
	            {'code' : 'IQD', 'name' : 'Iraq Dinar'},
	            {'code' : 'IRR', 'name' : 'Iran Rial'},
	            {'code' : 'ISK', 'name' : 'Iceland Krona'},
	            {'code' : 'JEP', 'name' : 'Jersey Pound'},
	            {'code' : 'JMD', 'name' : 'Jamaica Dollar'},
	            {'code' : 'JOD', 'name' : 'Jordan Dinar'},
	            {'code' : 'JPY', 'name' : 'Japan Yen'},
	            {'code' : 'KES', 'name' : 'Kenya Shilling'},
	            {'code' : 'KGS', 'name' : 'Kyrgyzstan Som'},
	            {'code' : 'KHR', 'name' : 'Cambodia Riel'},
	            {'code' : 'KMF', 'name' : 'Comoros Franc'},
	            {'code' : 'KPW', 'name' : 'Korea (North) Won'},
	            {'code' : 'KRW', 'name' : 'Korea (South) Won'},
	            {'code' : 'KWD', 'name' : 'Kuwait Dinar'},
	            {'code' : 'KYD', 'name' : 'Cayman Islands Dollar'},
	            {'code' : 'KZT', 'name' : 'Kazakhstan Tenge'},
	            {'code' : 'LAK', 'name' : 'Laos Kip'},
	            {'code' : 'LBP', 'name' : 'Lebanon Pound'},
	            {'code' : 'LKR', 'name' : 'Sri Lanka Rupee'},
	            {'code' : 'LRD', 'name' : 'Liberia Dollar'},
	            {'code' : 'LSL', 'name' : 'Lesotho Loti'},
	            {'code' : 'LTL', 'name' : 'Lithuania Litas'},
	            {'code' : 'LYD', 'name' : 'Libya Dinar'},
	            {'code' : 'MAD', 'name' : 'Morocco Dirham'},
	            {'code' : 'MDL', 'name' : 'Moldova Leu'},
	            {'code' : 'MGA', 'name' : 'Madagascar Ariary'},
	            {'code' : 'MKD', 'name' : 'Macedonia Denar'},
	            {'code' : 'MMK', 'name' : 'Myanmar (Burma) Kyat'},
	            {'code' : 'MNT', 'name' : 'Mongolia Tughrik'},
	            {'code' : 'MOP', 'name' : 'Macau Pataca'},
	            {'code' : 'MRO', 'name' : 'Mauritania Ouguiya'},
	            {'code' : 'MUR', 'name' : 'Mauritius Rupee'},
	            {'code' : 'MVR', 'name' : 'Maldives (Maldive Islands) Rufiyaa'},
	            {'code' : 'MWK', 'name' : 'Malawi Kwacha'},
	            {'code' : 'MXN', 'name' : 'Mexico Peso'},
	            {'code' : 'MYR', 'name' : 'Malaysia Ringgit'},
	            {'code' : 'MZN', 'name' : 'Mozambique Metical'},
	            {'code' : 'NAD', 'name' : 'Namibia Dollar'},
	            {'code' : 'NGN', 'name' : 'Nigeria Naira'},
	            {'code' : 'NIO', 'name' : 'Nicaragua Cordoba'},
	            {'code' : 'NOK', 'name' : 'Norway Krone'},
	            {'code' : 'NPR', 'name' : 'Nepal Rupee'},
	            {'code' : 'NZD', 'name' : 'New Zealand Dollar'},
	            {'code' : 'OMR', 'name' : 'Oman Rial'},
	            {'code' : 'PAB', 'name' : 'Panama Balboa'},
	            {'code' : 'PEN', 'name' : 'Peru Nuevo Sol'},
	            {'code' : 'PGK', 'name' : 'Papua New Guinea Kina'},
	            {'code' : 'PHP', 'name' : 'Philippines Peso'},
	            {'code' : 'PKR', 'name' : 'Pakistan Rupee'},
	            {'code' : 'PLN', 'name' : 'Poland Zloty'},
	            {'code' : 'PYG', 'name' : 'Paraguay Guarani'},
	            {'code' : 'QAR', 'name' : 'Qatar Riyal'},
	            {'code' : 'RON', 'name' : 'Romania New Leu'},
	            {'code' : 'RSD', 'name' : 'Serbia Dinar'},
	            {'code' : 'RUB', 'name' : 'Russia Ruble'},
	            {'code' : 'RWF', 'name' : 'Rwanda Franc'},
	            {'code' : 'SAR', 'name' : 'Saudi Arabia Riyal'},
	            {'code' : 'SBD', 'name' : 'Solomon Islands Dollar'},
	            {'code' : 'SCR', 'name' : 'Seychelles Rupee'},
	            {'code' : 'SDG', 'name' : 'Sudan Pound'},
	            {'code' : 'SEK', 'name' : 'Sweden Krona'},
	            {'code' : 'SGD', 'name' : 'Singapore Dollar'},
	            {'code' : 'SHP', 'name' : 'Saint Helena Pound'},
	            {'code' : 'SLL', 'name' : 'Sierra Leone Leone'},
	            {'code' : 'SOS', 'name' : 'Somalia Shilling'},
	            {'code' : 'SPL', 'name' : 'Seborga Luigino'},
	            {'code' : 'SRD', 'name' : 'Suriname Dollar'},
	            {'code' : 'STD', 'name' : 'São Tomé and Príncipe Dobra'},
	            {'code' : 'SVC', 'name' : 'El Salvador Colon'},
	            {'code' : 'SYP', 'name' : 'Syria Pound'},
	            {'code' : 'SZL', 'name' : 'Swaziland Lilangeni'},
	            {'code' : 'THB', 'name' : 'Thailand Baht'},
	            {'code' : 'TJS', 'name' : 'Tajikistan Somoni'},
	            {'code' : 'TMT', 'name' : 'Turkmenistan Manat'},
	            {'code' : 'TND', 'name' : 'Tunisia Dinar'},
	            {'code' : 'TOP', 'name' : 'Tonga Pa\'anga'},
	            {'code' : 'TRY', 'name' : 'Turkey Lira'},
	            {'code' : 'TTD', 'name' : 'Trinidad and Tobago Dollar'},
	            {'code' : 'TVD', 'name' : 'Tuvalu Dollar'},
	            {'code' : 'TWD', 'name' : 'Taiwan New Dollar'},
	            {'code' : 'TZS', 'name' : 'Tanzania Shilling'},
	            {'code' : 'UAH', 'name' : 'Ukraine Hryvnia'},
	            {'code' : 'UGX', 'name' : 'Uganda Shilling'},
	            {'code' : 'USD', 'name' : 'United States Dollar'},
	            {'code' : 'UYU', 'name' : 'Uruguay Peso'},
	            {'code' : 'UZS', 'name' : 'Uzbekistan Som'},
	            {'code' : 'VEF', 'name' : 'Venezuela Bolivar'},
	            {'code' : 'VND', 'name' : 'Viet Nam Dong'},
	            {'code' : 'VUV', 'name' : 'Vanuatu Vatu'},
	            {'code' : 'WST', 'name' : 'Samoa Tala'},
	            {'code' : 'XAF', 'name' : 'Communauté Financière Africaine (BEAC) CFA Franc BEAC'},
	            {'code' : 'XCD', 'name' : 'East Caribbean Dollar'},
	            {'code' : 'XDR', 'name' : 'International Monetary Fund (IMF) Special Drawing Rights'},
	            {'code' : 'XOF', 'name' : 'Communauté Financière Africaine (BCEAO) Franc'},
	            {'code' : 'XPF', 'name' : 'Comptoirs Français du Pacifique (CFP) Franc'},
	            {'code' : 'YER', 'name' : 'Yemen Rial'},
	            {'code' : 'ZAR', 'name' : 'South Africa Rand'},
	            {'code' : 'ZMW', 'name' : 'Zambia Kwacha'},
	            {'code' : 'ZWD', 'name' : 'Zimbabwe Dollar'}
	        ],
	        
	        // return the names of all valide colors
	        colorNames : [  "AliceBlue", "Black", "Navy", "DarkBlue", "MediumBlue", "Blue", "DarkGreen", "Green", "Teal", "DarkCyan", "DeepSkyBlue", "DarkTurquoise", "MediumSpringGreen", "Lime", "SpringGreen",
	            "Aqua", "Cyan", "MidnightBlue", "DodgerBlue", "LightSeaGreen", "ForestGreen", "SeaGreen", "DarkSlateGray", "LimeGreen", "MediumSeaGreen", "Turquoise", "RoyalBlue", "SteelBlue", "DarkSlateBlue", "MediumTurquoise",
	            "Indigo", "DarkOliveGreen", "CadetBlue", "CornflowerBlue", "RebeccaPurple", "MediumAquaMarine", "DimGray", "SlateBlue", "OliveDrab", "SlateGray", "LightSlateGray", "MediumSlateBlue", "LawnGreen", "Chartreuse",
	            "Aquamarine", "Maroon", "Purple", "Olive", "Gray", "SkyBlue", "LightSkyBlue", "BlueViolet", "DarkRed", "DarkMagenta", "SaddleBrown", "Ivory", "White",
	            "DarkSeaGreen", "LightGreen", "MediumPurple", "DarkViolet", "PaleGreen", "DarkOrchid", "YellowGreen", "Sienna", "Brown", "DarkGray", "LightBlue", "GreenYellow", "PaleTurquoise", "LightSteelBlue", "PowderBlue",
	            "FireBrick", "DarkGoldenRod", "MediumOrchid", "RosyBrown", "DarkKhaki", "Silver", "MediumVioletRed", "IndianRed", "Peru", "Chocolate", "Tan", "LightGray", "Thistle", "Orchid", "GoldenRod", "PaleVioletRed",
	            "Crimson", "Gainsboro", "Plum", "BurlyWood", "LightCyan", "Lavender", "DarkSalmon", "Violet", "PaleGoldenRod", "LightCoral", "Khaki", "AliceBlue", "HoneyDew", "Azure", "SandyBrown", "Wheat", "Beige", "WhiteSmoke",
	            "MintCream", "GhostWhite", "Salmon", "AntiqueWhite", "Linen", "LightGoldenRodYellow", "OldLace", "Red", "Fuchsia", "Magenta", "DeepPink", "OrangeRed", "Tomato", "HotPink", "Coral", "DarkOrange", "LightSalmon", "Orange",
	            "LightPink", "Pink", "Gold", "PeachPuff", "NavajoWhite", "Moccasin", "Bisque", "MistyRose", "BlanchedAlmond", "PapayaWhip", "LavenderBlush", "SeaShell", "Cornsilk", "LemonChiffon", "FloralWhite", "Snow", "Yellow", "LightYellow"
	        ],        
	
	        fileExtension : {
	            "raster"    : ["bmp", "gif", "gpl", "ico", "jpeg", "psd", "png", "psp", "raw", "tiff"],
	            "vector"    : ["3dv", "amf", "awg", "ai", "cgm", "cdr", "cmx", "dxf", "e2d", "egt", "eps", "fs", "odg", "svg", "xar"],
	            "3d"        : ["3dmf", "3dm", "3mf", "3ds", "an8", "aoi", "blend", "cal3d", "cob", "ctm", "iob", "jas", "max", "mb", "mdx", "obj", "x", "x3d"],
	            "document"  : ["doc", "docx", "dot", "html", "xml", "odt", "odm", "ott", "csv", "rtf", "tex", "xhtml", "xps"]
	        }
	    };
	
	    var o_hasOwnProperty = Object.prototype.hasOwnProperty;
	    var o_keys = (Object.keys || function(obj) {
	      var result = [];
	      for (var key in obj) {
	        if (o_hasOwnProperty.call(obj, key)) {
	          result.push(key);
	        }
	      }
	
	      return result;
	    });
	
	    function _copyObject(source, target) {
	      var keys = o_keys(source);
	      var key;
	
	      for (var i = 0, l = keys.length; i < l; i++) {
	        key = keys[i];
	        target[key] = source[key] || target[key];
	      }
	    }
	
	    function _copyArray(source, target) {
	      for (var i = 0, l = source.length; i < l; i++) {
	        target[i] = source[i];
	      }
	    }
	
	    function copyObject(source, _target) {
	        var isArray = Array.isArray(source);
	        var target = _target || (isArray ? new Array(source.length) : {});
	
	        if (isArray) {
	          _copyArray(source, target);
	        } else {
	          _copyObject(source, target);
	        }
	
	        return target;
	    }
	
	    /** Get the data based on key**/
	    Chance.prototype.get = function (name) {
	        return copyObject(data[name]);
	    };
	
	    // Mac Address
	    Chance.prototype.mac_address = function(options){
	        // typically mac addresses are separated by ":"
	        // however they can also be separated by "-"
	        // the network variant uses a dot every fourth byte
	
	        options = initOptions(options);
	        if(!options.separator) {
	            options.separator =  options.networkVersion ? "." : ":";
	        }
	
	        var mac_pool="ABCDEF1234567890",
	            mac = "";
	        if(!options.networkVersion) {
	            mac = this.n(this.string, 6, { pool: mac_pool, length:2 }).join(options.separator);
	        } else {
	            mac = this.n(this.string, 3, { pool: mac_pool, length:4 }).join(options.separator);
	        }
	
	        return mac;
	    };
	
	    Chance.prototype.normal = function (options) {
	        options = initOptions(options, {mean : 0, dev : 1, pool : []});
	
	        testRange(
	            options.pool.constructor !== Array,
	            "Chance: The pool option must be a valid array."
	        );
	
	        // If a pool has been passed, then we are returning an item from that pool,
	        // using the normal distribution settings that were passed in
	        if (options.pool.length > 0) {
	            return this.normal_pool(options);
	        }
	
	        // The Marsaglia Polar method
	        var s, u, v, norm,
	            mean = options.mean,
	            dev = options.dev;
	
	        do {
	            // U and V are from the uniform distribution on (-1, 1)
	            u = this.random() * 2 - 1;
	            v = this.random() * 2 - 1;
	
	            s = u * u + v * v;
	        } while (s >= 1);
	
	        // Compute the standard normal variate
	        norm = u * Math.sqrt(-2 * Math.log(s) / s);
	
	        // Shape and scale
	        return dev * norm + mean;
	    };
	
	    Chance.prototype.normal_pool = function(options) {
	        var performanceCounter = 0;
	        do {
	            var idx = Math.round(this.normal({ mean: options.mean, dev: options.dev }));
	            if (idx < options.pool.length && idx >= 0) {
	                return options.pool[idx];
	            } else {
	                performanceCounter++;
	            }
	        } while(performanceCounter < 100);
	
	        throw new RangeError("Chance: Your pool is too small for the given mean and standard deviation. Please adjust.");
	    };
	
	    Chance.prototype.radio = function (options) {
	        // Initial Letter (Typically Designated by Side of Mississippi River)
	        options = initOptions(options, {side : "?"});
	        var fl = "";
	        switch (options.side.toLowerCase()) {
	        case "east":
	        case "e":
	            fl = "W";
	            break;
	        case "west":
	        case "w":
	            fl = "K";
	            break;
	        default:
	            fl = this.character({pool: "KW"});
	            break;
	        }
	
	        return fl + this.character({alpha: true, casing: "upper"}) +
	                this.character({alpha: true, casing: "upper"}) +
	                this.character({alpha: true, casing: "upper"});
	    };
	
	    // Set the data as key and data or the data map
	    Chance.prototype.set = function (name, values) {
	        if (typeof name === "string") {
	            data[name] = values;
	        } else {
	            data = copyObject(name, data);
	        }
	    };
	
	    Chance.prototype.tv = function (options) {
	        return this.radio(options);
	    };
	
	    // ID number for Brazil companies
	    Chance.prototype.cnpj = function () {
	        var n = this.n(this.natural, 8, { max: 9 });
	        var d1 = 2+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
	        d1 = 11 - (d1 % 11);
	        if (d1>=10){
	            d1 = 0;
	        }
	        var d2 = d1*2+3+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
	        d2 = 11 - (d2 % 11);
	        if (d2>=10){
	            d2 = 0;
	        }
	        return ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/0001-'+d1+d2;
	    };
	
	    // -- End Miscellaneous --
	
	    Chance.prototype.mersenne_twister = function (seed) {
	        return new MersenneTwister(seed);
	    };
	
	    Chance.prototype.blueimp_md5 = function () {
	        return new BlueImpMD5();
	    };
	
	    // Mersenne Twister from https://gist.github.com/banksean/300494
	    var MersenneTwister = function (seed) {
	        if (seed === undefined) {
	            // kept random number same size as time used previously to ensure no unexpected results downstream
	            seed = Math.floor(Math.random()*Math.pow(10,13));
	        }
	        /* Period parameters */
	        this.N = 624;
	        this.M = 397;
	        this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	        this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	        this.LOWER_MASK = 0x7fffffff; /* least significant r bits */
	
	        this.mt = new Array(this.N); /* the array for the state vector */
	        this.mti = this.N + 1; /* mti==N + 1 means mt[N] is not initialized */
	
	        this.init_genrand(seed);
	    };
	
	    /* initializes mt[N] with a seed */
	    MersenneTwister.prototype.init_genrand = function (s) {
	        this.mt[0] = s >>> 0;
	        for (this.mti = 1; this.mti < this.N; this.mti++) {
	            s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
	            this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
	            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
	            /* In the previous versions, MSBs of the seed affect   */
	            /* only MSBs of the array mt[].                        */
	            /* 2002/01/09 modified by Makoto Matsumoto             */
	            this.mt[this.mti] >>>= 0;
	            /* for >32 bit machines */
	        }
	    };
	
	    /* initialize by an array with array-length */
	    /* init_key is the array for initializing keys */
	    /* key_length is its length */
	    /* slight change for C++, 2004/2/26 */
	    MersenneTwister.prototype.init_by_array = function (init_key, key_length) {
	        var i = 1, j = 0, k, s;
	        this.init_genrand(19650218);
	        k = (this.N > key_length ? this.N : key_length);
	        for (; k; k--) {
	            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
	            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525))) + init_key[j] + j; /* non linear */
	            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
	            i++;
	            j++;
	            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
	            if (j >= key_length) { j = 0; }
	        }
	        for (k = this.N - 1; k; k--) {
	            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
	            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941)) - i; /* non linear */
	            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
	            i++;
	            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
	        }
	
	        this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
	    };
	
	    /* generates a random number on [0,0xffffffff]-interval */
	    MersenneTwister.prototype.genrand_int32 = function () {
	        var y;
	        var mag01 = new Array(0x0, this.MATRIX_A);
	        /* mag01[x] = x * MATRIX_A  for x=0,1 */
	
	        if (this.mti >= this.N) { /* generate N words at one time */
	            var kk;
	
	            if (this.mti === this.N + 1) {   /* if init_genrand() has not been called, */
	                this.init_genrand(5489); /* a default initial seed is used */
	            }
	            for (kk = 0; kk < this.N - this.M; kk++) {
	                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
	                this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
	            }
	            for (;kk < this.N - 1; kk++) {
	                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
	                this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
	            }
	            y = (this.mt[this.N - 1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
	            this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];
	
	            this.mti = 0;
	        }
	
	        y = this.mt[this.mti++];
	
	        /* Tempering */
	        y ^= (y >>> 11);
	        y ^= (y << 7) & 0x9d2c5680;
	        y ^= (y << 15) & 0xefc60000;
	        y ^= (y >>> 18);
	
	        return y >>> 0;
	    };
	
	    /* generates a random number on [0,0x7fffffff]-interval */
	    MersenneTwister.prototype.genrand_int31 = function () {
	        return (this.genrand_int32() >>> 1);
	    };
	
	    /* generates a random number on [0,1]-real-interval */
	    MersenneTwister.prototype.genrand_real1 = function () {
	        return this.genrand_int32() * (1.0 / 4294967295.0);
	        /* divided by 2^32-1 */
	    };
	
	    /* generates a random number on [0,1)-real-interval */
	    MersenneTwister.prototype.random = function () {
	        return this.genrand_int32() * (1.0 / 4294967296.0);
	        /* divided by 2^32 */
	    };
	
	    /* generates a random number on (0,1)-real-interval */
	    MersenneTwister.prototype.genrand_real3 = function () {
	        return (this.genrand_int32() + 0.5) * (1.0 / 4294967296.0);
	        /* divided by 2^32 */
	    };
	
	    /* generates a random number on [0,1) with 53-bit resolution*/
	    MersenneTwister.prototype.genrand_res53 = function () {
	        var a = this.genrand_int32()>>>5, b = this.genrand_int32()>>>6;
	        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
	    };
	
	    // BlueImp MD5 hashing algorithm from https://github.com/blueimp/JavaScript-MD5
	    var BlueImpMD5 = function () {};
	
	    BlueImpMD5.prototype.VERSION = '1.0.1';
	
	    /*
	    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	    * to work around bugs in some JS interpreters.
	    */
	    BlueImpMD5.prototype.safe_add = function safe_add(x, y) {
	        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
	            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	        return (msw << 16) | (lsw & 0xFFFF);
	    };
	
	    /*
	    * Bitwise rotate a 32-bit number to the left.
	    */
	    BlueImpMD5.prototype.bit_roll = function (num, cnt) {
	        return (num << cnt) | (num >>> (32 - cnt));
	    };
	
	    /*
	    * These functions implement the five basic operations the algorithm uses.
	    */
	    BlueImpMD5.prototype.md5_cmn = function (q, a, b, x, s, t) {
	        return this.safe_add(this.bit_roll(this.safe_add(this.safe_add(a, q), this.safe_add(x, t)), s), b);
	    };
	    BlueImpMD5.prototype.md5_ff = function (a, b, c, d, x, s, t) {
	        return this.md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	    };
	    BlueImpMD5.prototype.md5_gg = function (a, b, c, d, x, s, t) {
	        return this.md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	    };
	    BlueImpMD5.prototype.md5_hh = function (a, b, c, d, x, s, t) {
	        return this.md5_cmn(b ^ c ^ d, a, b, x, s, t);
	    };
	    BlueImpMD5.prototype.md5_ii = function (a, b, c, d, x, s, t) {
	        return this.md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	    };
	
	    /*
	    * Calculate the MD5 of an array of little-endian words, and a bit length.
	    */
	    BlueImpMD5.prototype.binl_md5 = function (x, len) {
	        /* append padding */
	        x[len >> 5] |= 0x80 << (len % 32);
	        x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	        var i, olda, oldb, oldc, oldd,
	            a =  1732584193,
	            b = -271733879,
	            c = -1732584194,
	            d =  271733878;
	
	        for (i = 0; i < x.length; i += 16) {
	            olda = a;
	            oldb = b;
	            oldc = c;
	            oldd = d;
	
	            a = this.md5_ff(a, b, c, d, x[i],       7, -680876936);
	            d = this.md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
	            c = this.md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
	            b = this.md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
	            a = this.md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
	            d = this.md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
	            c = this.md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
	            b = this.md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
	            a = this.md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
	            d = this.md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
	            c = this.md5_ff(c, d, a, b, x[i + 10], 17, -42063);
	            b = this.md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
	            a = this.md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
	            d = this.md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
	            c = this.md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
	            b = this.md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);
	
	            a = this.md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
	            d = this.md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
	            c = this.md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
	            b = this.md5_gg(b, c, d, a, x[i],      20, -373897302);
	            a = this.md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
	            d = this.md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
	            c = this.md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
	            b = this.md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
	            a = this.md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
	            d = this.md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
	            c = this.md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
	            b = this.md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
	            a = this.md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
	            d = this.md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
	            c = this.md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
	            b = this.md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
	
	            a = this.md5_hh(a, b, c, d, x[i +  5],  4, -378558);
	            d = this.md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
	            c = this.md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
	            b = this.md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
	            a = this.md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
	            d = this.md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
	            c = this.md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
	            b = this.md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
	            a = this.md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
	            d = this.md5_hh(d, a, b, c, x[i],      11, -358537222);
	            c = this.md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
	            b = this.md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
	            a = this.md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
	            d = this.md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
	            c = this.md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
	            b = this.md5_hh(b, c, d, a, x[i +  2], 23, -995338651);
	
	            a = this.md5_ii(a, b, c, d, x[i],       6, -198630844);
	            d = this.md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
	            c = this.md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
	            b = this.md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
	            a = this.md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
	            d = this.md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
	            c = this.md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
	            b = this.md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
	            a = this.md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
	            d = this.md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
	            c = this.md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
	            b = this.md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
	            a = this.md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
	            d = this.md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
	            c = this.md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
	            b = this.md5_ii(b, c, d, a, x[i +  9], 21, -343485551);
	
	            a = this.safe_add(a, olda);
	            b = this.safe_add(b, oldb);
	            c = this.safe_add(c, oldc);
	            d = this.safe_add(d, oldd);
	        }
	        return [a, b, c, d];
	    };
	
	    /*
	    * Convert an array of little-endian words to a string
	    */
	    BlueImpMD5.prototype.binl2rstr = function (input) {
	        var i,
	            output = '';
	        for (i = 0; i < input.length * 32; i += 8) {
	            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
	        }
	        return output;
	    };
	
	    /*
	    * Convert a raw string to an array of little-endian words
	    * Characters >255 have their high-byte silently ignored.
	    */
	    BlueImpMD5.prototype.rstr2binl = function (input) {
	        var i,
	            output = [];
	        output[(input.length >> 2) - 1] = undefined;
	        for (i = 0; i < output.length; i += 1) {
	            output[i] = 0;
	        }
	        for (i = 0; i < input.length * 8; i += 8) {
	            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
	        }
	        return output;
	    };
	
	    /*
	    * Calculate the MD5 of a raw string
	    */
	    BlueImpMD5.prototype.rstr_md5 = function (s) {
	        return this.binl2rstr(this.binl_md5(this.rstr2binl(s), s.length * 8));
	    };
	
	    /*
	    * Calculate the HMAC-MD5, of a key and some data (raw strings)
	    */
	    BlueImpMD5.prototype.rstr_hmac_md5 = function (key, data) {
	        var i,
	            bkey = this.rstr2binl(key),
	            ipad = [],
	            opad = [],
	            hash;
	        ipad[15] = opad[15] = undefined;
	        if (bkey.length > 16) {
	            bkey = this.binl_md5(bkey, key.length * 8);
	        }
	        for (i = 0; i < 16; i += 1) {
	            ipad[i] = bkey[i] ^ 0x36363636;
	            opad[i] = bkey[i] ^ 0x5C5C5C5C;
	        }
	        hash = this.binl_md5(ipad.concat(this.rstr2binl(data)), 512 + data.length * 8);
	        return this.binl2rstr(this.binl_md5(opad.concat(hash), 512 + 128));
	    };
	
	    /*
	    * Convert a raw string to a hex string
	    */
	    BlueImpMD5.prototype.rstr2hex = function (input) {
	        var hex_tab = '0123456789abcdef',
	            output = '',
	            x,
	            i;
	        for (i = 0; i < input.length; i += 1) {
	            x = input.charCodeAt(i);
	            output += hex_tab.charAt((x >>> 4) & 0x0F) +
	                hex_tab.charAt(x & 0x0F);
	        }
	        return output;
	    };
	
	    /*
	    * Encode a string as utf-8
	    */
	    BlueImpMD5.prototype.str2rstr_utf8 = function (input) {
	        return unescape(encodeURIComponent(input));
	    };
	
	    /*
	    * Take string arguments and return either raw or hex encoded strings
	    */
	    BlueImpMD5.prototype.raw_md5 = function (s) {
	        return this.rstr_md5(this.str2rstr_utf8(s));
	    };
	    BlueImpMD5.prototype.hex_md5 = function (s) {
	        return this.rstr2hex(this.raw_md5(s));
	    };
	    BlueImpMD5.prototype.raw_hmac_md5 = function (k, d) {
	        return this.rstr_hmac_md5(this.str2rstr_utf8(k), this.str2rstr_utf8(d));
	    };
	    BlueImpMD5.prototype.hex_hmac_md5 = function (k, d) {
	        return this.rstr2hex(this.raw_hmac_md5(k, d));
	    };
	
	    BlueImpMD5.prototype.md5 = function (string, key, raw) {
	        if (!key) {
	            if (!raw) {
	                return this.hex_md5(string);
	            }
	
	            return this.raw_md5(string);
	        }
	
	        if (!raw) {
	            return this.hex_hmac_md5(key, string);
	        }
	
	        return this.raw_hmac_md5(key, string);
	    };
	
	    // CommonJS module
	    if (true) {
	        if (typeof module !== 'undefined' && module.exports) {
	            exports = module.exports = Chance;
	        }
	        exports.Chance = Chance;
	    }
	
	    // Register as an anonymous AMD module
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Chance;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	
	    // if there is a importsScrips object define chance for worker
	    if (typeof importScripts !== 'undefined') {
	        chance = new Chance();
	    }
	
	    // If there is a window object, that at least has a document property,
	    // instantiate and define chance on the window
	    if (typeof window === "object" && typeof window.document === "object") {
	        window.Chance = Chance;
	        window.chance = new Chance();
	    }
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82).Buffer))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(83)
	var ieee754 = __webpack_require__(84)
	var isArray = __webpack_require__(85)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82).Buffer, (function() { return this; }())))

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 84 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 85 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(43);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(46);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(47);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(48);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(71);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(78);
	
	var Record = _require.Record;
	
	
	var READY = 'ready';
	var RUNNING = 'running';
	var WON = 'won';
	var LOST = 'lost';
	
	var GameStatusRecord = Record({
	  status: READY,
	  message: ''
	});
	
	var GameStatus = function (_GameStatusRecord) {
	  (0, _inherits3.default)(GameStatus, _GameStatusRecord);
	
	  function GameStatus() {
	    (0, _classCallCheck3.default)(this, GameStatus);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(GameStatus).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(GameStatus, [{
	    key: 'setReady',
	    value: function setReady() {
	      return this.set('status', READY).set('message', '');
	    }
	  }, {
	    key: 'setRunning',
	    value: function setRunning() {
	      return this.set('status', RUNNING).set('message', '');
	    }
	  }, {
	    key: 'setWon',
	    value: function setWon() {
	      return this.set('status', WON).set('message', '');
	    }
	  }, {
	    key: 'setLost',
	    value: function setLost(message) {
	      return this.set('status', LOST).set('message', message);
	    }
	  }, {
	    key: 'isReady',
	    get: function get() {
	      return this.status === READY;
	    }
	  }, {
	    key: 'isRunning',
	    get: function get() {
	      return this.status === RUNNING;
	    }
	  }, {
	    key: 'isWon',
	    get: function get() {
	      return this.status === WON;
	    }
	  }, {
	    key: 'isLost',
	    get: function get() {
	      return this.status === LOST;
	    }
	  }]);
	  return GameStatus;
	}(GameStatusRecord);
	
	module.exports = GameStatus;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(43);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(46);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(47);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(48);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(71);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(78);
	
	var Record = _require.Record;
	var List = _require.List;
	
	
	var Vector = __webpack_require__(42);
	
	// Body parts added for each food item
	var GROWTH_RATE = 5; // parts per goal
	
	var LineRecord = Record({
	  front: undefined,
	  back: undefined
	});
	
	var Line = function (_LineRecord) {
	  (0, _inherits3.default)(Line, _LineRecord);
	
	  function Line() {
	    (0, _classCallCheck3.default)(this, Line);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Line).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Line, [{
	    key: 'contains',
	    value: function contains(_ref) {
	      var x = _ref.x;
	      var y = _ref.y;
	      var _front = this.front;
	      var f_x = _front.x;
	      var f_y = _front.y;
	      var _back = this.back;
	      var b_x = _back.x;
	      var b_y = _back.y;
	
	      // Given vertex must be horizontally or vertically within the line
	
	      return f_x === x && b_x === x && y >= Math.min(f_y, b_y) && y <= Math.max(f_y, b_y) || f_y === y && b_y === y && x >= Math.min(f_x, b_x) && x <= Math.max(f_x, b_x);
	    }
	  }, {
	    key: 'totalSize',
	    get: function get() {
	      // This works because lines are always horizontal or vertical so one
	      // of these differences will be zero
	      return Math.abs(this.front.x - this.back.x) + Math.abs(this.front.y - this.back.y) + 1;
	    }
	  }, {
	    key: 'direction',
	    get: function get() {
	      return this.front.sub(this.back).normalize();
	    }
	  }], [{
	    key: 'fromPoint',
	    value: function fromPoint(_ref2) {
	      var x = _ref2.x;
	      var y = _ref2.y;
	
	      return new Line({
	        front: new Vector({ x: x, y: y }),
	        back: new Vector({ x: x, y: y })
	      });
	    }
	  }]);
	  return Line;
	}(LineRecord);
	
	var SnakeRecord = Record({
	  body: List.of(),
	  direction: undefined,
	  pendingGrowth: 0
	});
	
	var Snake = function (_SnakeRecord) {
	  (0, _inherits3.default)(Snake, _SnakeRecord);
	
	  function Snake() {
	    (0, _classCallCheck3.default)(this, Snake);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Snake).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Snake, [{
	    key: 'setDirection',
	    value: function setDirection(direction) {
	      if (!this.canTravelInDirection(direction)) {
	        return this;
	      }
	      return this.set('direction', direction);
	    }
	  }, {
	    key: 'canTravelInDirection',
	    value: function canTravelInDirection(direction) {
	      // Only allow travel in a given direction
	      // if it would not directly collide with the
	      // segment just after the head
	      // In general, colliding with any other part is allowed
	      // This also allows the user to change their mind
	      // Example: if heading downwards after going left,
	      // the user could hit right and then left immediately
	      // That's okay with this method, since it doesn't use
	      // the current direction, but instead uses a possible
	      // collision to determine if the direction is okay
	      if (this.length < 2) {
	        return true;
	      }
	
	      var frontLine = this.body.first();
	
	      var delta = void 0;
	      if (frontLine.totalSize === 1) {
	        // if the front line is only size 1, use the second line front as well
	        delta = this.body.get(1).front.sub(frontLine.front).normalize();
	      } else {
	        delta = frontLine.direction.negate();
	      }
	
	      return !delta.equals(direction);
	    }
	  }, {
	    key: 'contains',
	    value: function contains(vec) {
	      vec = new Vector(vec);
	      return this.body.some(function (b) {
	        return b.contains(vec);
	      });
	    }
	  }, {
	    key: 'isWithinSelf',
	    value: function isWithinSelf() {
	      var head = this.head();
	      return this.body.slice(1).some(function (b) {
	        return b.contains(head);
	      });
	    }
	  }, {
	    key: 'head',
	    value: function head() {
	      return this.body.first().front;
	    }
	  }, {
	    key: 'tail',
	    value: function tail() {
	      return this.body.last().back;
	    }
	  }, {
	    key: 'grow',
	    value: function grow() {
	      return this.update('pendingGrowth', function (g) {
	        return g + GROWTH_RATE;
	      });
	    }
	  }, {
	    key: 'shift',
	    value: function shift() {
	      var _this3 = this;
	
	      var body = this.body;
	
	      // append one to the front
	      var frontLine = body.first();
	      if (frontLine.totalSize === 1 || frontLine.direction.equals(this.direction)) {
	        body = body.set(0, frontLine.update('front', function (front) {
	          return front.add(_this3.direction);
	        }));
	      } else {
	        body = body.unshift(Line.fromPoint(frontLine.front.add(this.direction)));
	      }
	
	      var backLine = body.last();
	
	      var pendingGrowth = this.pendingGrowth;
	      if (pendingGrowth) {
	        // just don't take one off from the back
	        pendingGrowth--;
	      }
	      // remove one from the back or remove the line if it will be empty
	      else if (backLine.totalSize === 1) {
	          body = body.pop();
	        } else {
	          body = body.set(body.size - 1, backLine.update('back', function (back) {
	            return back.add(backLine.direction);
	          }));
	        }
	
	      return this.set('body', body).set('pendingGrowth', pendingGrowth);
	    }
	  }, {
	    key: 'length',
	    get: function get() {
	      return this.body.reduce(function (t, L) {
	        return t + L.totalSize;
	      }, 0);
	    }
	  }], [{
	    key: 'fromStartPosition',
	    value: function fromStartPosition(_ref3) {
	      var x = _ref3.x;
	      var y = _ref3.y;
	
	      return new Snake({
	        // First element is the head
	        body: List.of(Line.fromPoint({ x: x, y: y })),
	        // Can be used to set the initial size of the snake
	        pendingGrowth: 0
	      });
	    }
	  }]);
	  return Snake;
	}(SnakeRecord);
	
	module.exports = Snake;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ACTION_CLEAR_PLANNED_PATH = exports.ACTION_SHIFT_PLANNED_PATH = exports.ACTION_UPDATE_PLANNED_PATH = exports.ACTION_ENABLE_DEBUG_AI_PATH = exports.ACTION_ENABLE_AI = exports.ACTION_DIRECTION = exports.ACTION_UPDATE = exports.ACTION_RESET = undefined;
	
	var _extends2 = __webpack_require__(1);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	exports.resetGame = resetGame;
	exports.updateGame = updateGame;
	exports.snakeDirection = snakeDirection;
	exports.enableAI = enableAI;
	exports.enableDebugAIPath = enableDebugAIPath;
	exports.updatePlannedPath = updatePlannedPath;
	exports.shiftPlannedPath = shiftPlannedPath;
	exports.clearPlannedPath = clearPlannedPath;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ACTION_RESET = exports.ACTION_RESET = 'reset';
	var ACTION_UPDATE = exports.ACTION_UPDATE = 'update';
	var ACTION_DIRECTION = exports.ACTION_DIRECTION = 'direction';
	var ACTION_ENABLE_AI = exports.ACTION_ENABLE_AI = 'ai-enabled';
	var ACTION_ENABLE_DEBUG_AI_PATH = exports.ACTION_ENABLE_DEBUG_AI_PATH = 'ai-path-debug-enabled';
	var ACTION_UPDATE_PLANNED_PATH = exports.ACTION_UPDATE_PLANNED_PATH = 'update-planned-path';
	var ACTION_SHIFT_PLANNED_PATH = exports.ACTION_SHIFT_PLANNED_PATH = 'shift-planned-path';
	var ACTION_CLEAR_PLANNED_PATH = exports.ACTION_CLEAR_PLANNED_PATH = 'clear-planned-path';
	
	function resetGame() {
	  return createAction(ACTION_RESET);
	}
	
	function updateGame() {
	  var goal = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  // the goal parameter manually overwrites the goal and is typically
	  // used to tell the AI process what the goal should be whenever an update
	  // is sent. This is a forced change that is applied AFTER the actual update
	  // itself
	  // NOTE: since null is a valid value for a goal, only an empty object
	  // prevents the goal from being set
	  return createAction(ACTION_UPDATE, { goal: goal });
	}
	
	function snakeDirection(directionName) {
	  return createAction(ACTION_DIRECTION, { name: directionName });
	}
	
	function enableAI() {
	  var enabled = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	  return createAction(ACTION_ENABLE_AI, { enabled: enabled });
	}
	
	function enableDebugAIPath() {
	  var enabled = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	  return createAction(ACTION_ENABLE_DEBUG_AI_PATH, { enabled: enabled });
	}
	
	function updatePlannedPath(path, target) {
	  return createAction(ACTION_UPDATE_PLANNED_PATH, { path: path, target: target });
	}
	
	function shiftPlannedPath() {
	  return createAction(ACTION_SHIFT_PLANNED_PATH);
	}
	
	function clearPlannedPath() {
	  return createAction(ACTION_CLEAR_PLANNED_PATH);
	}
	
	function createAction(type) {
	  var payload = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  return (0, _extends3.default)({
	    type: type
	  }, payload);
	}

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _defineProperty2 = __webpack_require__(34);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _createReducer;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(41);
	
	var createReducer = _require.createReducer;
	
	
	var AI = __webpack_require__(90);
	var PathPlan = __webpack_require__(91);
	
	var _require2 = __webpack_require__(88);
	
	var ACTION_RESET = _require2.ACTION_RESET;
	var ACTION_UPDATE_PLANNED_PATH = _require2.ACTION_UPDATE_PLANNED_PATH;
	var ACTION_SHIFT_PLANNED_PATH = _require2.ACTION_SHIFT_PLANNED_PATH;
	var ACTION_CLEAR_PLANNED_PATH = _require2.ACTION_CLEAR_PLANNED_PATH;
	
	
	var initialState = new AI({ plan: new PathPlan() });
	var game = createReducer(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, ACTION_RESET, function () {
	  return initialState;
	}), (0, _defineProperty3.default)(_createReducer, ACTION_CLEAR_PLANNED_PATH, function (state) {
	  return initialState;
	}), (0, _defineProperty3.default)(_createReducer, ACTION_UPDATE_PLANNED_PATH, function (state, _ref) {
	  var path = _ref.path;
	  var target = _ref.target;
	
	  return state.setPlan(PathPlan.fromJSON(path)).setTarget(target);
	}), (0, _defineProperty3.default)(_createReducer, ACTION_SHIFT_PLANNED_PATH, function (state) {
	  return state.update('plan', function (plan) {
	    return plan.shift();
	  });
	}), _createReducer));
	
	module.exports = game;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(43);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(46);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(47);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(48);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(71);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(78);
	
	var Record = _require.Record;
	
	
	var AIRecord = Record({
	  plan: undefined,
	  // the target this plan was made for
	  target: {}
	});
	
	var AI = function (_AIRecord) {
	  (0, _inherits3.default)(AI, _AIRecord);
	
	  function AI() {
	    (0, _classCallCheck3.default)(this, AI);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AI).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(AI, [{
	    key: 'setPlan',
	    value: function setPlan(plan) {
	      return this.set('plan', plan);
	    }
	  }, {
	    key: 'setTarget',
	    value: function setTarget(target) {
	      return this.set('target', target);
	    }
	  }]);
	  return AI;
	}(AIRecord);
	
	module.exports = AI;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getIterator2 = __webpack_require__(92);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _getPrototypeOf = __webpack_require__(43);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(46);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(47);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(48);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(71);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(78);
	
	var Record = _require.Record;
	var List = _require.List;
	
	
	var Turn = Record({
	  // x and y to make this turn at
	  x: undefined,
	  y: undefined,
	  // direction to turn in
	  direction: undefined
	});
	
	var PathPlanRecord = Record({
	  // List of Turns
	  nextDirections: List.of()
	});
	
	var PathPlan = function (_PathPlanRecord) {
	  (0, _inherits3.default)(PathPlan, _PathPlanRecord);
	
	  function PathPlan() {
	    (0, _classCallCheck3.default)(this, PathPlan);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(PathPlan).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(PathPlan, [{
	    key: 'hasPlan',
	    value: function hasPlan() {
	      return !this.nextDirections.isEmpty();
	    }
	
	    // Adds a turn on the path where the snake should turn at the given position
	
	  }, {
	    key: 'addTurn',
	    value: function addTurn(_ref, direction) {
	      var x = _ref.x;
	      var y = _ref.y;
	
	      return this.update('nextDirections', function (next) {
	        return next.push(new PathPlan.Turn({ x: x, y: y, direction: direction }));
	      });
	    }
	
	    // Same as addTurn but appends to the front of the path
	
	  }, {
	    key: 'prependTurn',
	    value: function prependTurn(_ref2, direction) {
	      var x = _ref2.x;
	      var y = _ref2.y;
	
	      return this.update('nextDirections', function (next) {
	        return next.unshift(new PathPlan.Turn({ x: x, y: y, direction: direction }));
	      });
	    }
	
	    // Returns the next direction to turn and the position to turn at
	    // i.e. The first turn in the planned path
	
	  }, {
	    key: 'firstTurn',
	    value: function firstTurn() {
	      return this.nextDirections.first();
	    }
	
	    // Removes the first turn in the planned path and
	    // returns the new planned path
	
	  }, {
	    key: 'shift',
	    value: function shift() {
	      return this.update('nextDirections', function (next) {
	        return next.shift();
	      });
	    }
	  }], [{
	    key: 'fromJSON',
	    value: function fromJSON(pathJSON) {
	      var plan = new PathPlan();
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = (0, _getIterator3.default)(pathJSON.nextDirections), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var _step$value = _step.value;
	          var x = _step$value.x;
	          var y = _step$value.y;
	          var direction = _step$value.direction;
	
	          plan = plan.addTurn({ x: x, y: y }, direction);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return plan;
	    }
	  }]);
	  return PathPlan;
	}(PathPlanRecord);
	
	PathPlan.Turn = Turn;
	
	
	module.exports = PathPlan;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(93), __esModule: true };

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(94);
	__webpack_require__(101);
	module.exports = __webpack_require__(104);

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(95);
	var Iterators = __webpack_require__(98);
	Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(96)
	  , step             = __webpack_require__(97)
	  , Iterators        = __webpack_require__(98)
	  , toIObject        = __webpack_require__(63);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(99)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(69)
	  , $export        = __webpack_require__(5)
	  , redefine       = __webpack_require__(55)
	  , hide           = __webpack_require__(56)
	  , has            = __webpack_require__(53)
	  , Iterators      = __webpack_require__(98)
	  , $iterCreate    = __webpack_require__(100)
	  , setToStringTag = __webpack_require__(59)
	  , getProto       = __webpack_require__(11).getProto
	  , ITERATOR       = __webpack_require__(60)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , methods, key;
	  // Fix native
	  if($native){
	    var IteratorPrototype = getProto($default.call(new Base));
	    // Set @@toStringTag to native iterators
	    setToStringTag(IteratorPrototype, TAG, true);
	    // FF fix
	    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    // fix Array#{values, @@iterator}.name in V8 / FF
	    if(DEF_VALUES && $native.name !== VALUES){
	      VALUES_BUG = true;
	      $default = function values(){ return $native.call(this); };
	    }
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES  ? $default : getMethod(VALUES),
	      keys:    IS_SET      ? $default : getMethod(KEYS),
	      entries: !DEF_VALUES ? $default : getMethod('entries')
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $              = __webpack_require__(11)
	  , descriptor     = __webpack_require__(57)
	  , setToStringTag = __webpack_require__(59)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(56)(IteratorPrototype, __webpack_require__(60)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(102)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(99)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(103)
	  , defined   = __webpack_require__(13);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 103 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(67)
	  , get      = __webpack_require__(105);
	module.exports = __webpack_require__(7).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(106)
	  , ITERATOR  = __webpack_require__(60)('iterator')
	  , Iterators = __webpack_require__(98);
	module.exports = __webpack_require__(7).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(15)
	  , TAG = __webpack_require__(60)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _defineProperty2 = __webpack_require__(34);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _createReducer;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(41);
	
	var createReducer = _require.createReducer;
	
	
	var Settings = __webpack_require__(108);
	
	var _require2 = __webpack_require__(88);
	
	var ACTION_ENABLE_AI = _require2.ACTION_ENABLE_AI;
	var ACTION_ENABLE_DEBUG_AI_PATH = _require2.ACTION_ENABLE_DEBUG_AI_PATH;
	
	
	var settings = createReducer(new Settings(), (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, ACTION_ENABLE_AI, function (state, _ref) {
	  var enabled = _ref.enabled;
	
	  return state.setAI(enabled);
	}), (0, _defineProperty3.default)(_createReducer, ACTION_ENABLE_DEBUG_AI_PATH, function (state, _ref2) {
	  var enabled = _ref2.enabled;
	
	  return state.setDebugAIPath(enabled);
	}), _createReducer));
	
	module.exports = settings;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(43);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(46);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(47);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(48);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(71);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _require = __webpack_require__(78);
	
	var Record = _require.Record;
	
	
	var SettingsRecord = Record({
	  useAI: false,
	  debugAIPath: false
	});
	
	var Settings = function (_SettingsRecord) {
	  (0, _inherits3.default)(Settings, _SettingsRecord);
	
	  function Settings() {
	    (0, _classCallCheck3.default)(this, Settings);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Settings).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Settings, [{
	    key: 'setAI',
	    value: function setAI(enabled) {
	      return this.set('useAI', enabled);
	    }
	  }, {
	    key: 'setDebugAIPath',
	    value: function setDebugAIPath(enabled) {
	      return this.set('debugAIPath', enabled);
	    }
	  }]);
	  return Settings;
	}(SettingsRecord);
	
	module.exports = Settings;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__(110);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _slicedToArray2 = __webpack_require__(130);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _getIterator2 = __webpack_require__(92);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _set = __webpack_require__(134);
	
	var _set2 = _interopRequireDefault(_set);
	
	exports.planPathAStar = planPathAStar;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _marked = [availableAdjacents].map(_regenerator2.default.mark);
	
	var Direction = __webpack_require__(79);
	var PathPlan = __webpack_require__(91);
	
	/**
	 * Returns a PathPlan to get from the position after the current one
	 * to the next goal
	 * Returns an empty path if there is no path to the goal (about to die)
	 */
	function planPathAStar(game) {
	  // Need to start on the position *after* the current one because
	  // at this point the snake is already moving there, there is nothing
	  // to be gained by searching other directions from the current position
	  game = game.update('snake', function (snake) {
	    return snake.shift();
	  });
	
	  var finish = game.goal;
	
	  var open = [createAStarNode(game, null, null, finish)];
	  var visited = new _set2.default();
	
	  while (open.length) {
	    var current = open.splice(0, 1)[0];
	    visited.add(current.id);
	
	    var position = current.game.snake.head();
	
	    if (position.equals(finish)) {
	      return solutionPathFromAStar(current);
	    }
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      var _loop = function _loop() {
	        var _step$value = _step.value;
	        var adjacent = _step$value.adjacent;
	        var direction = _step$value.direction;
	
	        if (visited.has(adjacent.hash())) {
	          return 'continue';
	        }
	
	        // Change directions AND shift so that the snake moves in this
	        // direction
	        var adjGame = current.game.update('snake', function (snake) {
	          return snake.setDirection(direction).shift();
	        });
	        var adjNode = createAStarNode(adjGame, current, direction, finish);
	
	        // Skip a potential node with a lower cost
	        sameOpen = open.findIndex(function (n) {
	          return n.id === adjNode.id;
	        });
	
	        if (sameOpen > -1) {
	          if (open[sameOpen].cost < adjNode.cost) {
	            return 'continue';
	          } else {
	            // Remove sameOpen since its cost is higher than this path
	            open.splice(sameOpen, 1);
	          }
	        }
	
	        insertAStarNodeByCost(open, adjNode);
	      };
	
	      for (var _iterator = (0, _getIterator3.default)(availableAdjacents(current.game)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var sameOpen;
	
	        var _ret = _loop();
	
	        if (_ret === 'continue') continue;
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	
	  // exhausted search
	  console.debug('exhausted search for goal, giving up');
	  return new PathPlan();
	}
	
	function createAStarNode(game, parent, direction, finish) {
	  var position = game.snake.head();
	
	  var extra = 0;
	
	  var total = 0;
	  if (parent) {
	    var parentPosition = parent.game.snake.head();
	    total = parent.totalCost + parentPosition.squaredDistanceTo(position);
	
	    // An additional extra heuristic to favor straighter paths
	    if (!game.snake.direction.equals(parent.game.snake.direction)) {
	      // This weight will be the minimum number of steps the snake
	      // will attempt to stay in a straight path for
	      // It is usually safe to set this at the width or height of the
	      // screen. Setting it too high (higher than other weights) will
	      // result in those considerations being placed at a lower priority
	      extra += 30;
	    }
	  }
	
	  var estimate = position.squaredDistanceTo(finish);
	
	  // Very basic heuristic for determining if this path will lead to a
	  // dead end. A more advanced method would be to look ahead from the
	  // finish and see if there are alternate paths afterwards
	  // The advanced method should lookahead at least the number of spaces
	  // the snake will grow to see if it hits something
	  if (position.equals(game.goal)) {
	    var afterGoal = position.add(game.snake.direction);
	    if (!game.isTraversable(afterGoal)) {
	      // this extra cost will influence the snake to avoid these conditions
	      // but also still not exhaust the search if this is the only option
	      // Needs to be at least the square of the distance from corner to corner
	      extra += 5000;
	    }
	
	    var twoAfterGoal = afterGoal.add(game.snake.direction);
	    if (!game.isTraversable(afterGoal)) {
	      extra += 4000;
	    }
	  }
	
	  return {
	    id: position.hash(),
	    game: game,
	    // the direction leading to this game
	    direction: direction,
	    parent: parent,
	    cost: total + estimate + extra,
	    // total distance up to this position from the start
	    totalCost: total,
	    estimatedCost: estimate
	  };
	}
	
	/* Simplifies the path starting from the finish
	 * to only contain the turns necessary to go through
	 * that path
	 */
	function solutionPathFromAStar(finishNode) {
	  //TODO: Some bug here causes finishNode.direction to be null sometimes
	  var path = new PathPlan();
	
	  // Note that the direction property is the direction leading
	  // **into** the node
	
	  var currentDirection = finishNode.direction;
	  var current = finishNode;
	  while (current.direction) {
	    // Looking for where this direction started
	    // Where ever the direction changes, that's where this direction
	    // started
	    if (!current.direction.equals(currentDirection)) {
	      var _position = current.game.snake.head();
	      path = path.prependTurn(_position, Direction.toName(currentDirection));
	
	      currentDirection = current.direction;
	    }
	
	    current = current.parent;
	  }
	
	  // once we reach the start node, we'll have a current position
	  // but no current direction - this needs to be prepended too
	  var position = current.game.snake.head();
	  path = path.prependTurn(position, Direction.toName(currentDirection));
	
	  return path;
	}
	
	function insertAStarNodeByCost(open, node) {
	  // attempt to insert the node before a node with a larger cost
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = (0, _getIterator3.default)(open.entries()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _step2$value = (0, _slicedToArray3.default)(_step2.value, 2);
	
	      var i = _step2$value[0];
	      var openNode = _step2$value[1];
	
	      // Since this is >= and not >, nodes with the same cost but
	      // checked earlier will be searched afterwards
	      if (openNode.cost >= node.cost) {
	        open.splice(i, 0, node);
	        return;
	      }
	    }
	
	    // never found any node with a smaller cost
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  open.push(node);
	}
	
	/**
	 * Yields each adjacent that is not a snake tile or out of bounds
	 */
	function availableAdjacents(game) {
	  var position, backwards, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _direction, adjacent;
	
	  return _regenerator2.default.wrap(function availableAdjacents$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          position = game.snake.head();
	          backwards = game.snake.direction.negate();
	          _iteratorNormalCompletion3 = true;
	          _didIteratorError3 = false;
	          _iteratorError3 = undefined;
	          _context.prev = 5;
	          _iterator3 = (0, _getIterator3.default)(Direction.all());
	
	        case 7:
	          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
	            _context.next = 19;
	            break;
	          }
	
	          _direction = _step3.value;
	
	          if (!_direction.equals(backwards)) {
	            _context.next = 11;
	            break;
	          }
	
	          return _context.abrupt('continue', 16);
	
	        case 11:
	          adjacent = position.add(_direction);
	
	          if (game.isTraversable(adjacent)) {
	            _context.next = 14;
	            break;
	          }
	
	          return _context.abrupt('continue', 16);
	
	        case 14:
	          _context.next = 16;
	          return { adjacent: adjacent, direction: _direction };
	
	        case 16:
	          _iteratorNormalCompletion3 = true;
	          _context.next = 7;
	          break;
	
	        case 19:
	          _context.next = 25;
	          break;
	
	        case 21:
	          _context.prev = 21;
	          _context.t0 = _context['catch'](5);
	          _didIteratorError3 = true;
	          _iteratorError3 = _context.t0;
	
	        case 25:
	          _context.prev = 25;
	          _context.prev = 26;
	
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	
	        case 28:
	          _context.prev = 28;
	
	          if (!_didIteratorError3) {
	            _context.next = 31;
	            break;
	          }
	
	          throw _iteratorError3;
	
	        case 31:
	          return _context.finish(28);
	
	        case 32:
	          return _context.finish(25);
	
	        case 33:
	        case 'end':
	          return _context.stop();
	      }
	    }
	  }, _marked[0], this, [[5, 21, 25, 33], [26,, 28, 32]]);
	}

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(111);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	module.exports = { "default": module.exports, __esModule: true };
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	"use strict";
	
	var _Symbol = __webpack_require__(50)["default"];
	
	var _Object$create = __webpack_require__(72)["default"];
	
	var _Object$setPrototypeOf = __webpack_require__(74)["default"];
	
	var _Promise = __webpack_require__(112)["default"];
	
	!(function (global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = _Object$create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      prototype[method] = function (arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function (genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor ? ctor === GeneratorFunction ||
	    // For the native GeneratorFunction constructor, the best we can
	    // do is to check its .name property.
	    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	  };
	
	  runtime.mark = function (genFun) {
	    if (_Object$setPrototypeOf) {
	      _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = _Object$create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function (arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return _Promise.resolve(value.arg).then(function (value) {
	            invoke("next", value, resolve, reject);
	          }, function (err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return _Promise.resolve(value).then(function (unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new _Promise(function (resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	      // If enqueue has been called before, then we want to wait until
	      // all previous Promises have been resolved before calling invoke,
	      // so that results are always delivered in the correct order. If
	      // enqueue has not been called before, then it is important to
	      // call invoke immediately, without waiting on a callback to fire,
	      // so that the async generator function has the opportunity to do
	      // any necessary setup in a predictable way. This predictability
	      // is why the Promise constructor synchronously invokes its
	      // executor callback, and why async functions synchronously
	      // execute code before the first await. Since we implement simple
	      // async functions in terms of async generators, it is especially
	      // important to get this right, even though it requires care.
	      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
	      // Avoid propagating failures to Promises returned by later
	      // invocations of the iterator.
	      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
	
	    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	    : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done ? GenStateCompleted : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function () {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function () {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function (object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1,
	            next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function reset(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function stop() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function dispatchException(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function complete(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" || record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	// Among the various tricks for obtaining a reference to the global
	// object, this seems to be the most reliable technique that does not
	// use indirect eval (which violates Content Security Policy).
	typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(18)))

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(113), __esModule: true };

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(70);
	__webpack_require__(101);
	__webpack_require__(94);
	__webpack_require__(114);
	module.exports = __webpack_require__(7).Promise;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(11)
	  , LIBRARY    = __webpack_require__(69)
	  , global     = __webpack_require__(6)
	  , ctx        = __webpack_require__(8)
	  , classof    = __webpack_require__(106)
	  , $export    = __webpack_require__(5)
	  , isObject   = __webpack_require__(68)
	  , anObject   = __webpack_require__(67)
	  , aFunction  = __webpack_require__(9)
	  , strictNew  = __webpack_require__(115)
	  , forOf      = __webpack_require__(116)
	  , setProto   = __webpack_require__(77).set
	  , same       = __webpack_require__(120)
	  , SPECIES    = __webpack_require__(60)('species')
	  , speciesConstructor = __webpack_require__(121)
	  , asap       = __webpack_require__(122)
	  , PROMISE    = 'Promise'
	  , process    = global.process
	  , isNode     = classof(process) == 'process'
	  , P          = global[PROMISE]
	  , Wrapper;
	
	var testResolve = function(sub){
	  var test = new P(function(){});
	  if(sub)test.constructor = Object;
	  return P.resolve(test) === test;
	};
	
	var USE_NATIVE = function(){
	  var works = false;
	  function P2(x){
	    var self = new P(x);
	    setProto(self, P2.prototype);
	    return self;
	  }
	  try {
	    works = P && P.resolve && testResolve();
	    setProto(P2, P);
	    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
	    // actual Firefox has broken subclass support, test that
	    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
	      works = false;
	    }
	    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
	    if(works && __webpack_require__(54)){
	      var thenableThenGotten = false;
	      P.resolve($.setDesc({}, 'then', {
	        get: function(){ thenableThenGotten = true; }
	      }));
	      works = thenableThenGotten;
	    }
	  } catch(e){ works = false; }
	  return works;
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // library wrapper special case
	  if(LIBRARY && a === P && b === Wrapper)return true;
	  return same(a, b);
	};
	var getConstructor = function(C){
	  var S = anObject(C)[SPECIES];
	  return S != undefined ? S : C;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var PromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve),
	  this.reject  = aFunction(reject)
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(record, isReject){
	  if(record.n)return;
	  record.n = true;
	  var chain = record.c;
	  asap(function(){
	    var value = record.v
	      , ok    = record.s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , result, then;
	      try {
	        if(handler){
	          if(!ok)record.h = true;
	          result = handler === true ? value : handler(value);
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    chain.length = 0;
	    record.n = false;
	    if(isReject)setTimeout(function(){
	      var promise = record.p
	        , handler, console;
	      if(isUnhandled(promise)){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      } record.a = undefined;
	    }, 1);
	  });
	};
	var isUnhandled = function(promise){
	  var record = promise._d
	    , chain  = record.a || record.c
	    , i      = 0
	    , reaction;
	  if(record.h)return false;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var $reject = function(value){
	  var record = this;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  record.v = value;
	  record.s = 2;
	  record.a = record.c.slice();
	  notify(record, true);
	};
	var $resolve = function(value){
	  var record = this
	    , then;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  try {
	    if(record.p === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      asap(function(){
	        var wrapper = {r: record, d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      record.v = value;
	      record.s = 1;
	      notify(record, false);
	    }
	  } catch(e){
	    $reject.call({r: record, d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  P = function Promise(executor){
	    aFunction(executor);
	    var record = this._d = {
	      p: strictNew(this, P, PROMISE),         // <- promise
	      c: [],                                  // <- awaiting reactions
	      a: undefined,                           // <- checked in isUnhandled reactions
	      s: 0,                                   // <- state
	      d: false,                               // <- done
	      v: undefined,                           // <- value
	      h: false,                               // <- handled rejection
	      n: false                                // <- notify
	    };
	    try {
	      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
	    } catch(err){
	      $reject.call(record, err);
	    }
	  };
	  __webpack_require__(127)(P.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction = new PromiseCapability(speciesConstructor(this, P))
	        , promise  = reaction.promise
	        , record   = this._d;
	      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      record.c.push(reaction);
	      if(record.a)record.a.push(reaction);
	      if(record.s)notify(record, false);
	      return promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
	__webpack_require__(59)(P, PROMISE);
	__webpack_require__(128)(PROMISE);
	Wrapper = __webpack_require__(7)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = new PromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof P && sameConstructor(x.constructor, this))return x;
	    var capability = new PromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(129)(function(iter){
	  P.all(iter)['catch'](function(){});
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = getConstructor(this)
	      , capability = new PromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject
	      , values     = [];
	    var abrupt = perform(function(){
	      forOf(iterable, false, values.push, values);
	      var remaining = values.length
	        , results   = Array(remaining);
	      if(remaining)$.each.call(values, function(promise, index){
	        var alreadyCalled = false;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled = true;
	          results[index] = value;
	          --remaining || resolve(results);
	        }, reject);
	      });
	      else resolve(results);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = getConstructor(this)
	      , capability = new PromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(8)
	  , call        = __webpack_require__(117)
	  , isArrayIter = __webpack_require__(118)
	  , anObject    = __webpack_require__(67)
	  , toLength    = __webpack_require__(119)
	  , getIterFn   = __webpack_require__(105);
	module.exports = function(iterable, entries, fn, that){
	  var iterFn = getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(67);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(98)
	  , ITERATOR   = __webpack_require__(60)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(103)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 120 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(67)
	  , aFunction = __webpack_require__(9)
	  , SPECIES   = __webpack_require__(60)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(6)
	  , macrotask = __webpack_require__(123).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(15)(process) == 'process'
	  , head, last, notify;
	
	var flush = function(){
	  var parent, domain, fn;
	  if(isNode && (parent = process.domain)){
	    process.domain = null;
	    parent.exit();
	  }
	  while(head){
	    domain = head.domain;
	    fn     = head.fn;
	    if(domain)domain.enter();
	    fn(); // <- currently we use it only for Promise - try / catch not required
	    if(domain)domain.exit();
	    head = head.next;
	  } last = undefined;
	  if(parent)parent.enter();
	};
	
	// Node.js
	if(isNode){
	  notify = function(){
	    process.nextTick(flush);
	  };
	// browsers with MutationObserver
	} else if(Observer){
	  var toggle = 1
	    , node   = document.createTextNode('');
	  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	  notify = function(){
	    node.data = toggle = -toggle;
	  };
	// environments with maybe non-completely correct, but existent Promise
	} else if(Promise && Promise.resolve){
	  notify = function(){
	    Promise.resolve().then(flush);
	  };
	// for other environments - macrotask based on:
	// - setImmediate
	// - MessageChannel
	// - window.postMessag
	// - onreadystatechange
	// - setTimeout
	} else {
	  notify = function(){
	    // strange IE + webpack dev server bug - use .call(global)
	    macrotask.call(global, flush);
	  };
	}
	
	module.exports = function asap(fn){
	  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
	  if(last)last.next = task;
	  if(!head){
	    head = task;
	    notify();
	  } last = task;
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(8)
	  , invoke             = __webpack_require__(124)
	  , html               = __webpack_require__(125)
	  , cel                = __webpack_require__(126)
	  , global             = __webpack_require__(6)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listner = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(15)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listner;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listner, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(6).document && document.documentElement;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(68)
	  , document = __webpack_require__(6).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(55);
	module.exports = function(target, src){
	  for(var key in src)redefine(target, key, src[key]);
	  return target;
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var core        = __webpack_require__(7)
	  , $           = __webpack_require__(11)
	  , DESCRIPTORS = __webpack_require__(54)
	  , SPECIES     = __webpack_require__(60)('species');
	
	module.exports = function(KEY){
	  var C = core[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(60)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ safe = true; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(131);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(92);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(132), __esModule: true };

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(94);
	__webpack_require__(101);
	module.exports = __webpack_require__(133);

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(106)
	  , ITERATOR  = __webpack_require__(60)('iterator')
	  , Iterators = __webpack_require__(98);
	module.exports = __webpack_require__(7).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(135), __esModule: true };

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(70);
	__webpack_require__(101);
	__webpack_require__(94);
	__webpack_require__(136);
	__webpack_require__(139);
	module.exports = __webpack_require__(7).Set;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(137);
	
	// 23.2 Set Objects
	__webpack_require__(138)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(11)
	  , hide         = __webpack_require__(56)
	  , redefineAll  = __webpack_require__(127)
	  , ctx          = __webpack_require__(8)
	  , strictNew    = __webpack_require__(115)
	  , defined      = __webpack_require__(13)
	  , forOf        = __webpack_require__(116)
	  , $iterDefine  = __webpack_require__(99)
	  , step         = __webpack_require__(97)
	  , ID           = __webpack_require__(61)('id')
	  , $has         = __webpack_require__(53)
	  , isObject     = __webpack_require__(68)
	  , setSpecies   = __webpack_require__(128)
	  , DESCRIPTORS  = __webpack_require__(54)
	  , isExtensible = Object.isExtensible || isObject
	  , SIZE         = DESCRIPTORS ? '_s' : 'size'
	  , id           = 0;
	
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!$has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	};
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = $.create(null); // index
	      that._f = undefined;      // first entry
	      that._l = undefined;      // last entry
	      that[SIZE] = 0;           // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $              = __webpack_require__(11)
	  , global         = __webpack_require__(6)
	  , $export        = __webpack_require__(5)
	  , fails          = __webpack_require__(16)
	  , hide           = __webpack_require__(56)
	  , redefineAll    = __webpack_require__(127)
	  , forOf          = __webpack_require__(116)
	  , strictNew      = __webpack_require__(115)
	  , isObject       = __webpack_require__(68)
	  , setToStringTag = __webpack_require__(59)
	  , DESCRIPTORS    = __webpack_require__(54);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	  } else {
	    C = wrapper(function(target, iterable){
	      strictNew(target, C, NAME);
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(5);
	
	$export($export.P, 'Set', {toJSON: __webpack_require__(140)('Set')});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var forOf   = __webpack_require__(116)
	  , classof = __webpack_require__(106);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    var arr = [];
	    forOf(this, false, arr.push, arr);
	    return arr;
	  };
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWRmYTAyOWNkMmEyMTBiMmZjNzIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FpL3dvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmZhaWxzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC10aHVuay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlZHVjZXJzL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcmVkdWNlcnMvZ2FtZS5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWR1Y2Vycy9yZWR1Y2VyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3ZlY3Rvci5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oaWRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC53a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnVpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQua2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmdldC1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmxpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9kaXJlY3Rpb24uanN4Iiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvc25ha2VHYW1lLmpzeCIsIndlYnBhY2s6Ly8vLi9+L2NoYW5jZS9jaGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYXNlNjQtanMvbGliL2I2NC5qcyIsIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvZ2FtZVN0YXR1cy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9zbmFrZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2FjdGlvbnMvYWN0aW9ucy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlZHVjZXJzL2FpLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL2FpLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3BhdGhQbGFuLmpzeCIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlZHVjZXJzL3NldHRpbmdzLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3NldHRpbmdzLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYWkvcGxhbm5lci5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zdHJpY3QtbmV3LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmludm9rZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLXRvLWpzb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztnQkN0Q3VDLG9CQUFRLEVBQVIsQzs7S0FBaEMsZSxZQUFBLGU7S0FBaUIsVyxZQUFBLFc7O0FBQ3hCLEtBQU0sUUFBUSxvQkFBUSxFQUFSLEVBQXVCLE9BQXJDOztBQUVBLEtBQU0sYUFBYSxvQkFBUSxFQUFSLENBQW5COztpQkFVSSxvQkFBUSxFQUFSLEM7O0tBUEYsZ0IsYUFBQSxnQjtLQUNBLGEsYUFBQSxhO0tBQ0EsUSxhQUFBLFE7S0FDQSxjLGFBQUEsYztLQUNBLGlCLGFBQUEsaUI7S0FDQSxnQixhQUFBLGdCO0tBQ0EsZ0IsYUFBQSxnQjs7O0FBR0YsS0FBTSxVQUFVLG9CQUFRLEdBQVIsQ0FBaEI7O0FBRUEsS0FBTSxPQUFPLFNBQVAsSUFBTyxDQUFDLE1BQUQ7QUFBQSxVQUFZLHVDQUNwQixNQURvQjtBQUV2QixhQUFRO0FBRmUsTUFBWjtBQUFBLEVBQWI7O0FBS0EsS0FBTSxRQUFRLFlBQ1osVUFEWSxFQUVaLGdCQUFnQixLQUFoQixDQUZZLENBQWQ7O0FBS0EsTUFBSyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxnQkFBb0I7QUFBQSxPQUFaLE1BQVksUUFBbEIsSUFBa0I7O0FBQ25ELFNBQU0sUUFBTixDQUFlLE1BQWY7O0FBRUEsT0FBTSxRQUFRLE1B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QTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DLEtBQUs7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXVDLFNBQVM7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0ZBQW1GLHlDQUF5QztBQUM1SDtBQUNBO0FBQ0Esa0ZBQWlGLHlDQUF5QztBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNENBQTJDOztBQUUzQyw4Q0FBNkM7O0FBRTdDLDBDQUF5Qzs7O0FBR3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsOEVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLFNBQVM7QUFDdkM7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLHFCQUFxQjtBQUM3RCxVQUFTO0FBQ1Q7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0Esb0NBQW1DLEtBQUs7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMEQsU0FBUztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBaUQsZUFBZTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQSxvREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxvQ0FBb0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsY0FBYyxFQUFFO0FBQ2pFO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxlQUFlLEVBQUU7QUFDdkQ7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7QUFHTDs7QUFFQSx5QkFBd0I7QUFDeEI7QUFDQSxNQUFLOztBQUVMO0FBQ0EsMENBQXlDLDhCQUE4QjtBQUN2RSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0Esa0ZBQWlGLFlBQVk7QUFDN0YsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsMkNBQTBDLDBCQUEwQjtBQUNwRSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSwyQ0FBMEMsNEJBQTRCO0FBQ3RFLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDZDQUE0Qyw4QkFBOEI7QUFDMUUsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLHdCQUF3QjtBQUNuRTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBLE1BQUs7O0FBRUwseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQ7Ozs7QUFJN0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMscUJBQXFCO0FBQzFELE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUVBO0FBQ0E7QUFDQTtBQUNBLE87O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxzQkFBcUIseUNBQXlDLEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUsNENBQTRDLEVBQUUscUNBQXFDLEVBQUUsb0NBQW9DLEVBQUUsc0NBQXNDLEVBQUUsd0NBQXdDLEVBQUUsaURBQWlELEVBQUUsdUNBQXVDLEVBQUUscUNBQXFDLEVBQUUsbUNBQW1DLEVBQUUsdUNBQXVDLEVBQUUscUNBQXFDLEVBQUUsd0NBQXdDLEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUsd0NBQXdDLEVBQUUsc0NBQXNDLEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUsb0NBQW9DLEVBQUUsbUNBQW1DLEVBQUUscUNBQXFDLEVBQUUsb0NBQW9DLEVBQUUscUNBQXFDLEVBQUUsb0RBQW9ELEVBQUUsc0NBQXNDLEVBQUUsMkNBQTJDLEVBQUUsb0NBQW9DLEVBQUUseURBQXlELEVBQUUsNERBQTRELEVBQUUsb0RBQW9ELEVBQUUsb0NBQW9DLEVBQUUsc0NBQXNDLEVBQUUsMENBQTBDLEVBQUUscUNBQXFDLEVBQUUsc0NBQXNDLEVBQUUsc0NBQXNDLEVBQUUsb0NBQW9DLEVBQUUsMERBQTBELEVBQUUsd0NBQXdDLEVBQUUsNENBQTRDLEVBQUUsc0RBQXNELEVBQUUsa0NBQWtDLEVBQUUsbUNBQW1DLEVBQUUsbUNBQW1DLEVBQUUsOENBQThDLEVBQUUscURBQXFELEVBQUUsc0NBQXNDLEVBQUUscUNBQXFDLEVBQUUsaURBQWlELEVBQUUsOENBQThDLEVBQUUsMENBQTBDLEVBQUUsd0NBQXdDLEVBQUUscUNBQXFDLEVBQUUsa0NBQWtDLEVBQUUsb0NBQW9DLEVBQUUsNENBQTRDLEVBQUUsMkNBQTJDLEVBQUUscUNBQXFDLEVBQUUsc0NBQXNDLEVBQUUsc0NBQXNDLEVBQUUsZ0RBQWdELEVBQUUsZ0RBQWdELEVBQUUsMENBQTBDLEVBQUUscUNBQXFDLEVBQUUsbUNBQW1DLEVBQUUseUNBQXlDLEVBQUUsK0NBQStDLEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUsc0NBQXNDLEVBQUUsOENBQThDLEVBQUUsMkNBQTJDLEVBQUUsa0NBQWtDLEVBQUUscUNBQXFDLEVBQUUsb0NBQW9DLEVBQUUsMkNBQTJDLEVBQUUsOENBQThDLEVBQUUseURBQXlELEVBQUUsdUVBQXVFLEVBQUUsbUNBQW1DLEVBQUUsb0NBQW9DLEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUsbUNBQW1DLEVBQUUsdUNBQXVDLEVBQUUsb0NBQW9DLEVBQUUsdUNBQXVDLEVBQUUscUNBQXFDLEVBQUUsd0NBQXdDLEVBQUUsa0NBQWtDLEVBQUUsdUNBQXVDLEVBQUUsc0NBQXNDLEVBQUUsb0NBQW9DLEVBQUUsMkNBQTJDLEVBQUUsb0NBQW9DLEVBQUUsbUNBQW1DLEVBQUUsK0RBQStELEVBQUUsc0NBQXNDLEVBQUUsaURBQWlELEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUsbUNBQW1DLEVBQUUsdUNBQXVDLEVBQUUsa0NBQWtDLEVBQUUsa0NBQWtDLEVBQUUscUNBQXFDLEVBQUUseUNBQXlDLEVBQUUsb0NBQW9DLEVBQUUsbUNBQW1DLEVBQUUscUNBQXFDLEVBQUUsbUNBQW1DLEVBQUUsb0NBQW9DLEVBQUUsNkNBQTZDLEVBQUUsb0NBQW9DLEVBQUUsd0NBQXdDLEVBQUUsbUNBQW1DLEVBQUUsc0NBQXNDLEVBQUUsb0NBQW9DLEVBQUUsd0NBQXdDLEVBQUUsa0NBQWtDLEVBQUUsb0NBQW9DLEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUscUNBQXFDLEVBQUUsbUNBQW1DLEVBQUUsMkNBQTJDLEVBQUUsdUNBQXVDLEVBQUUsd0NBQXdDLEVBQUUsNkNBQTZDLEVBQUUsdUNBQXVDLEVBQUUsd0NBQXdDLEVBQUUsb0NBQW9DLEVBQUUsc0NBQXNDLEVBQUUsc0NBQXNDLEVBQUUsa0NBQWtDLEVBQUUsbUNBQW1DLEVBQUUsOENBQThDLEVBQUUsd0NBQXdDLEVBQUUsd0NBQXdDLEVBQUUsdUNBQXVDLEVBQUUscUNBQXFDLEVBQUUsaURBQWlELEVBQUUsb0NBQW9DLEVBQUUsd0NBQXdDLEVBQUUsNENBQTRDLEVBQUUscUNBQXFDLEVBQUUsb0NBQW9DLEVBQUUsc0NBQXNDLEVBQUUsd0NBQXdDLEVBQUUsd0NBQXdDLEVBQUUscUNBQXFDLEVBQUUsd0NBQXdDLEVBQUUsNkNBQTZDLEVBQUUscUNBQXFDLEVBQUUsbUNBQW1DLEVBQUUsbUNBQW1DLEVBQUUseUNBQXlDLEVBQUUsa0RBQWtELEVBQUUsMENBQTBDLEVBQUUsMkNBQTJDLEVBQUUseUNBQXlDLEVBQUUsdUNBQXVDLEVBQUUsbUNBQW1DLEVBQUUscUNBQXFDLEVBQUUsa0NBQWtDLEVBQUUsNENBQTRDLEVBQUUseUNBQXlDLEVBQUUsMkNBQTJDLEVBQUUsc0RBQXNELEVBQUUsb0NBQW9DLEVBQUUsa0NBQWtDLEVBQUUsNkRBQTZELEVBQUUsc0NBQXNDLEVBQUUsbUNBQW1DLEVBQUUscURBQXFELEVBQUUsb0NBQW9DLEVBQUUsK0NBQStDLEVBQUUsOENBQThDLEVBQUUsc0NBQXNDLEVBQUUsbUVBQW1FLEVBQUUsa0NBQWtDLEVBQUUseUNBQXlDLEVBQUUsOENBQThDLEVBQUUsb0NBQW9DLEVBQUUsc0NBQXNDLEVBQUUseUNBQXlDLEVBQUUsbUNBQW1DLEVBQUUscUNBQXFDLEVBQUUsb0NBQW9DLEVBQUUsb0NBQW9DLEVBQUUscUNBQXFDLEVBQUUsOENBQThDLEVBQUUsMENBQTBDLEVBQUUsbURBQW1ELEVBQUUseUNBQXlDLEVBQUUsMENBQTBDLEVBQUUsdURBQXVELEVBQUUsOERBQThELEVBQUUsbUNBQW1DLEVBQUUsd0NBQXdDLEVBQUUsMENBQTBDLEVBQUUscUNBQXFDLEVBQUUsb0NBQW9DLEVBQUUsbURBQW1ELEVBQUUsd0NBQXdDLEVBQUUsMENBQTBDLEVBQUUsdUNBQXVDLEVBQUUsc0NBQXNDLEVBQUUsc0NBQXNDLEVBQUUsNkNBQTZDLEVB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eUM7QUFDdEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSxnREFBZ0Q7QUFDN0QsY0FBYSxvRUFBb0U7QUFDakYsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSxvREFBb0Q7QUFDakUsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSxnREFBZ0Q7QUFDN0QsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSxzQ0FBc0M7QUFDbkQsY0FBYSwrQ0FBK0M7QUFDNUQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSxpREFBaUQ7QUFDOUQsY0FBYSxxQ0FBcUM7QUFDbEQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSxpREFBaUQ7QUFDOUQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSxtREFBbUQ7QUFDaEUsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSxpREFBaUQ7QUFDOUQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSw2REFBNkQ7QUFDMUUsY0FBYSxnREFBZ0Q7QUFDN0QsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSxzQ0FBc0M7QUFDbkQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSxzQ0FBc0M7QUFDbkQsY0FBYSxxQ0FBcUM7QUFDbEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSxxQ0FBcUM7QUFDbEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSxpREFBaUQ7QUFDOUQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSxvQ0FBb0M7QUFDakQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSxnREFBZ0Q7QUFDN0QsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSw4Q0FBOEM7QUFDM0QsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSw4REFBOEQ7QUFDM0UsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSw4Q0FBOEM7QUFDM0QsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSw4Q0FBOEM7QUFDM0QsY0FBYSxxQ0FBcUM7QUFDbEQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSxpREFBaUQ7QUFDOUQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSw4Q0FBOEM7QUFDM0QsY0FBYSxrREFBa0Q7QUFDL0QsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSw4Q0FBOEM7QUFDM0QsY0FBYSw4Q0FBOEM7QUFDM0QsY0FBYSw0Q0FBNEM7QUFDekQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSx1REFBdUQ7QUFDcEUsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSwrQ0FBK0M7QUFDNUQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSw4Q0FBOEM7QUFDM0QsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSx1Q0FBdUM7QUFDcEQsY0FBYSxzREFBc0Q7QUFDbkUsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSwyQ0FBMkM7QUFDeEQsY0FBYSxnREFBZ0Q7QUFDN0QsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSwwQ0FBMEM7QUFDdkQsY0FBYSw2Q0FBNkM7QUFDMUQsY0FBYSx5Q0FBeUM7QUFDdEQsY0FBYSx3Q0FBd0M7QUFDckQsY0FBYSxzQ0FBc0M7QUFDbkQsY0FBYSxpRkFBaUY7QUFDOUYsY0FBYSxpREFB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7O0FDdDNHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzZ0RBOztBQUVBLEVBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUMsNkJBQXFEOzs7Ozs7O0FDM0h0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxTQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQSxzQ0FBcUMsb0JBQW9CLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRzs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEc7Ozs7OztBQ2ZBLDhFOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsYUFBYTtBQUNqQyxJQUFHO0FBQ0gsRzs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCLHFCQUFxQjtBQUNwRCxnQ0FBK0IsU0FBUyxFQUFFO0FBQzFDLEVBQUMsVUFBVTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QyxnQ0FBK0IsYUFBYTtBQUM1QztBQUNBLElBQUcsVUFBVTtBQUNiO0FBQ0EsRzs7Ozs7O0FDcEJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBd0QsK0JBQStCO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDLEc7Ozs7OztBQ2xERCxtQkFBa0IseUQ7Ozs7OztBQ0FsQjtBQUNBO0FBQ0EsMkM7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNSQSxtQkFBa0IseUQ7Ozs7OztBQ0FsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7OztBQ0xBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF3QixtRUFBbUU7QUFDM0YsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxVOzs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CLDJCQUEwQjtBQUMxQiwyQkFBMEI7QUFDMUIsc0JBQXFCO0FBQ3JCO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZELE9BQU87QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QixzQkFBcUI7QUFDckIsMkJBQTBCO0FBQzFCLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRzs7Ozs7O0FDdERBO0FBQ0E7O0FBRUEsNEJBQTJCLHdDQUFpRCxFOzs7Ozs7QUNINUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHIiwiZmlsZSI6IjFkZmEwMjljZDJhMjEwYjJmYzcyLndvcmtlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMWRmYTAyOWNkMmEyMTBiMmZjNzJcbiAqKi8iLCJjb25zdCB7YXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZX0gPSByZXF1aXJlKCdyZWR1eCcpO1xuY29uc3QgdGh1bmsgPSByZXF1aXJlKCdyZWR1eC10aHVuaycpLmRlZmF1bHQ7XG5cbmNvbnN0IGFwcFJlZHVjZXIgPSByZXF1aXJlKCcuLi9yZWR1Y2Vycy9pbmRleCcpO1xuXG5jb25zdCB7XG4gIEFDVElPTl9FTkFCTEVfQUksXG4gIEFDVElPTl9VUERBVEUsXG4gIGVuYWJsZUFJLFxuICBzbmFrZURpcmVjdGlvbixcbiAgdXBkYXRlUGxhbm5lZFBhdGgsXG4gIHNoaWZ0UGxhbm5lZFBhdGgsXG4gIGNsZWFyUGxhbm5lZFBhdGgsXG59ID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9hY3Rpb25zJyk7XG5cbmNvbnN0IHBsYW5uZXIgPSByZXF1aXJlKCcuL3BsYW5uZXInKTtcblxuY29uc3Qgc2VuZCA9IChhY3Rpb24pID0+IHBvc3RNZXNzYWdlKHtcbiAgLi4uYWN0aW9uLFxuICBzb3VyY2U6ICdhaScsXG59KTtcblxuY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgYXBwUmVkdWNlcixcbiAgYXBwbHlNaWRkbGV3YXJlKHRodW5rKVxuKTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKHtkYXRhOiBhY3Rpb259KSA9PiB7XG4gIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG5cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB1c2VBSSA9IHN0YXRlLnNldHRpbmdzLnVzZUFJO1xuICBjb25zdCBwbGFuID0gc3RhdGUuYWkucGxhbjtcbiAgY29uc3QgcGxhbm5lZFRhcmdldCA9IHN0YXRlLmFpLnRhcmdldDtcbiAgY29uc3QgZ2FtZSA9IHN0YXRlLmdhbWU7XG4gIGNvbnN0IGlzUnVubmluZyA9IGdhbWUuc3RhdHVzLmlzUnVubmluZztcbiAgY29uc3QgaGVhZCA9IGdhbWUuc25ha2UuaGVhZCgpO1xuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX0VOQUJMRV9BSSkge1xuICAgIHNlbmQoZW5hYmxlQUkodXNlQUkpKTtcblxuICAgIHN0b3JlLmRpc3BhdGNoKGNsZWFyUGxhbm5lZFBhdGgoKSk7XG4gICAgc2VuZChjbGVhclBsYW5uZWRQYXRoKCkpO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSBBQ1RJT05fVVBEQVRFICYmIGlzUnVubmluZyAmJiB1c2VBSSkge1xuICAgIC8vIEFzc3VtcHRpb246IHdlIHdpbGwgYWx3YXlzIGhpdCB0aGUgcG9pbnQgaW4gdGhlIHBsYW5cbiAgICAvLyBpLmUuIHdlIGNhbiBuZXZlciBhY2NpZGVudGFsbHkgc2tpcCBhbiB1cGRhdGUgYW5kIHRoZSBBSSB3aWxsIGFsd2F5c1xuICAgIC8vIHBsYW4gZm9yIHNxdWFyZXMgd2Ugd2lsbCBhY3R1YWxseSBoaXRcbiAgICBzZW5kRGlyZWN0aW9uVXBkYXRlKGhlYWQsIHBsYW4pO1xuXG4gICAgLy9UT0RPOiBSaWdodCBub3cgdGhpcyBoYXBwZW5zIG9uIGV2ZXJ5IHVwZGF0ZSwgYnV0IGluIHJlYWxpdHlcbiAgICAvLyB3aGF0IHNob3VsZCBoYXBwZW4gaXMgdGhhdCB0aGUgQUkgc2hvdWxkIGNvbnN0YW50bHkgYmUgd29ya2luZ1xuICAgIC8vIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBvbmx5IHBhdXNpbmcgdG8gcHJvY2VzcyBtZXNzYWdlcyBhbmQgdXBkYXRlXG4gICAgaWYgKCFnYW1lLmdvYWwuZXF1YWxzKHBsYW5uZWRUYXJnZXQpKSB7XG4gICAgICB1cGRhdGVBSVBhdGgoZ2FtZSk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBJZiB0aGUgc25ha2UgaXMgYXQgdGhlIG5leHQgcG9pbnQgb24gdGhlIHBsYW5uZWQgcGF0aCxcbiAqIHRoaXMgd2lsbCBzZW5kIGEgZGlyZWN0aW9uIHVwZGF0ZSBmb3IgdGhlIG5leHQgZGlyZWN0aW9uXG4gKiBhbmQgdGhlbiBzaGlmdCB0aGUgcGxhbm5lZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHNlbmREaXJlY3Rpb25VcGRhdGUoaGVhZCwgcGxhbikge1xuICBpZiAoIXBsYW4uaGFzUGxhbigpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge3gsIHksIGRpcmVjdGlvbn0gPSBwbGFuLmZpcnN0VHVybigpO1xuXG4gIGlmIChoZWFkLmVxdWFscyh7eCwgeX0pKSB7XG4gICAgLy8gV2UganVzdCBmaXJlIGFuZCBmb3JnZXQgaGVyZSB3aXRoIG5vIGhvcGUgb2YgYWNrbm93bGVkZ2VtZW50XG4gICAgc3RvcmUuZGlzcGF0Y2goc25ha2VEaXJlY3Rpb24oZGlyZWN0aW9uKSk7XG4gICAgc2VuZChzbmFrZURpcmVjdGlvbihkaXJlY3Rpb24pKTtcblxuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgdXBkYXRlZCBvbiBib3RoIGVuZHMgYW5kIHdpbGwgbm90IGJlIGFja25vd2xlZGdlZFxuICAgIHN0b3JlLmRpc3BhdGNoKHNoaWZ0UGxhbm5lZFBhdGgoKSk7XG4gICAgc2VuZChzaGlmdFBsYW5uZWRQYXRoKCkpO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcGxhbm5lZCBwYXRoIGlmIG5lY2Vzc2FyeSBhbmQgc2VuZHMgdGhhdCB1cGRhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQUlQYXRoKGdhbWUpIHtcbiAgY29uc29sZS50aW1lKCdhc3RhcicpO1xuICBjb25zdCBwYXRoID0gcGxhbm5lci5wbGFuUGF0aEFTdGFyKGdhbWUpO1xuICBjb25zb2xlLnRpbWVFbmQoJ2FzdGFyJyk7XG5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkIG9uIGJvdGggZW5kcyBhbmQgd2lsbCBub3QgYmUgYWNrbm93bGVkZ2VkXG4gIHN0b3JlLmRpc3BhdGNoKHVwZGF0ZVBsYW5uZWRQYXRoKHBhdGgudG9KU09OKCksIGdhbWUuZ29hbC50b0pTT04oKSkpO1xuICBzZW5kKHVwZGF0ZVBsYW5uZWRQYXRoKHBhdGgudG9KU09OKCksIGdhbWUuZ29hbC50b0pTT04oKSkpO1xufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9haS93b3JrZXIuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkYXNzaWduID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfT2JqZWN0JGFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5hc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLm9iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24ocGFyYW0pe1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgaWYoSVNfUFJPVE8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcxLjIuNid9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jdHguanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmEtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuLyQuaW9iamVjdCcpO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIGEgPSBPYmplY3QuYXNzaWduXG4gICAgLCBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuIGEoe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoYSh7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgJCQgICAgPSBhcmd1bWVudHNcbiAgICAsICQkbGVuID0gJCQubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldEtleXMgICAgPSAkLmdldEtleXNcbiAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHNcbiAgICAsIGlzRW51bSAgICAgPSAkLmlzRW51bTtcbiAgd2hpbGUoJCRsZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoJCRbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfVxuICByZXR1cm4gVDtcbn0gOiBPYmplY3QuYXNzaWduO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQub2JqZWN0LWFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcbiAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXG4gIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgZWFjaDogICAgICAgW10uZm9yRWFjaFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mYWlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBfY3JlYXRlU3RvcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBfYmluZEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IF9hcHBseU1pZGRsZXdhcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbn0gKCkpXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQWN0aW9uVHlwZXMgPSB1bmRlZmluZWQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNyZWF0ZVN0b3JlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2xPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG52YXIgQWN0aW9uVHlwZXMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW2luaXRpYWxTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5oYW5jZXIgVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBpbml0aWFsU3RhdGU7XG4gICAgaW5pdGlhbFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cblxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX3JlZjtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0hvc3RPYmplY3QgPSByZXF1aXJlKCcuL19pc0hvc3RPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbi8qKlxuICogR2V0cyB0aGUgYFtbUHJvdG90eXBlXV1gIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBgW1tQcm90b3R5cGVdXWAuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3RvdHlwZSh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlKE9iamVjdCh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0hvc3RPYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgd2luZG93ICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpKGdsb2JhbCB8fCB3aW5kb3cgfHwgdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL3BvbnlmaWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tYmluZVJlZHVjZXJzO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24pIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCA/ICdpbml0aWFsU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICB9KTtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTYW5pdHkocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gJyArICdJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgJyArICdleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5ICcgKyAnbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IHR5cGUgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIHZhciBzYW5pdHlFcnJvcjtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2FuaXR5KGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2FuaXR5RXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2FuaXR5RXJyb3IpIHtcbiAgICAgIHRocm93IHNhbml0eUVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24pO1xuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGJpbmRBY3Rpb25DcmVhdG9ycztcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGFwcGx5TWlkZGxld2FyZTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcik7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbXBvc2U7XG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdCA9IGZ1bmNzW2Z1bmNzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJlc3QgPSBmdW5jcy5zbGljZSgwLCAtMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiBmdW5jdGlvbiB2KCkge1xuICAgICAgICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgICAgICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBpZiAodHlwZW9mIF9yZXQgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY29tcG9zZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBjcmVhdGVUaHVua01pZGRsZXdhcmUoZXh0cmFBcmd1bWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoO1xuICAgIHZhciBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpO1xudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHRodW5rO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4LXRodW5rL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJjb25zdCB7Y29tYmluZVJlZHVjZXJzfSA9IHJlcXVpcmUoJ3JlZHV4Jyk7XG5cbmNvbnN0IGdhbWUgPSByZXF1aXJlKCcuL2dhbWUnKTtcbmNvbnN0IGFpID0gcmVxdWlyZSgnLi9haScpO1xuY29uc3Qgc2V0dGluZ3MgPSByZXF1aXJlKCcuL3NldHRpbmdzJyk7XG5cbmNvbnN0IGFwcCA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGdhbWUsXG4gIGFpLFxuICBzZXR0aW5ncyxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcDtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVkdWNlcnMvaW5kZXguanN4XG4gKiovIiwiY29uc3Qge2NyZWF0ZVJlZHVjZXJ9ID0gcmVxdWlyZSgnLi9yZWR1Y2VyJyk7XG5cbmNvbnN0IFZlY3RvciA9IHJlcXVpcmUoJy4uL21vZGVscy92ZWN0b3InKTtcbmNvbnN0IERpcmVjdGlvbiA9IHJlcXVpcmUoJy4uL21vZGVscy9kaXJlY3Rpb24nKTtcbmNvbnN0IFNuYWtlR2FtZSA9IHJlcXVpcmUoJy4uL21vZGVscy9zbmFrZUdhbWUnKTtcblxuY29uc3Qge1xuICBBQ1RJT05fUkVTRVQsXG4gIEFDVElPTl9ESVJFQ1RJT04sXG4gIEFDVElPTl9VUERBVEUsXG59ID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9hY3Rpb25zJyk7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IFNuYWtlR2FtZS5mcm9tRGltZW5zaW9ucyh7cm93czogMzAsIGNvbHM6IDMwfSk7XG5jb25zdCBnYW1lID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIHtcbiAgW0FDVElPTl9SRVNFVF0oc3RhdGUpIHtcbiAgICByZXR1cm4gaW5pdGlhbFN0YXRlLnBsYWNlUmFuZG9tR29hbCgpO1xuICB9LFxuICBbQUNUSU9OX0RJUkVDVElPTl0oc3RhdGUsIHtuYW1lfSkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IERpcmVjdGlvbi50b0RpcmVjdGlvbihuYW1lKTtcbiAgICByZXR1cm4gc3RhdGVcbiAgICAgIC51cGRhdGUoJ3NuYWtlJywgKHNuYWtlKSA9PiBzbmFrZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKSlcbiAgICAgIC51cGRhdGUoJ3N0YXR1cycsIChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cy5pc1JlYWR5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXR1cy5zZXRSdW5uaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgIH0pO1xuICB9LFxuICBbQUNUSU9OX1VQREFURV0oc3RhdGUsIHtnb2FsID0ge319KSB7XG4gICAgaWYgKHN0YXRlLnN0YXR1cy5pc1J1bm5pbmcpIHtcbiAgICAgIHN0YXRlID0gc3RhdGUudXBkYXRlKCdzbmFrZScsIChzbmFrZSkgPT4gc25ha2Uuc2hpZnQoKSk7XG4gICAgICBpZiAoc3RhdGUuaXNHb2FsKHN0YXRlLnNuYWtlLmhlYWQoKSkpIHtcbiAgICAgICAgc3RhdGUgPSBzdGF0ZVxuICAgICAgICAgIC51cGRhdGUoJ3NuYWtlJywgKHNuYWtlKSA9PiBzbmFrZS5ncm93KCkpXG4gICAgICAgICAgLnBsYWNlUmFuZG9tR29hbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNpbmNlIG51bGwgaXMgYSB2YWxpZCBnb2FsIHZhbHVlLCBnb2FsIGlzIG9ubHkgbm90IHNldCBpZiBhbiBlbXB0eSBvYmplY3QgaXMgcHJvdmlkZWRcbiAgICBpZiAoIWdvYWwgfHwgT2JqZWN0LmtleXMoZ29hbCkubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2dvYWwnLCBuZXcgVmVjdG9yKGdvYWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUudXBkYXRlKCdzdGF0dXMnLCAoc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc25ha2UuaXNXaXRoaW5TZWxmKCkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cy5zZXRMb3N0KCdidW1wZWQgaW50byB5b3Vyc2VsZicpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaXNPdXRPZkJvdW5kcyhzdGF0ZS5zbmFrZS5oZWFkKCkpKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXMuc2V0TG9zdCgnb3V0IG9mIGJvdW5kcycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaXNGdWxsKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXMuc2V0V29uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH0pO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2FtZTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVkdWNlcnMvZ2FtZS5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcbiAgcmV0dXJuICQuc2V0RGVzYyhpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmtleXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oJGtleXMpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm9iamVjdC1zYXAuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBhY3Rpb25IYW5kbGVycyA9IHt9KSB7XG4gIHJldHVybiAoc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBhY3Rpb25IYW5kbGVyc1thY3Rpb24udHlwZV07XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKHN0YXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JlZHVjZXJzL3JlZHVjZXIuanN4XG4gKiovIiwiY29uc3Qge1JlY29yZH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcblxuY29uc3QgVmVjdG9yUmVjb3JkID0gUmVjb3JkKHtcbiAgeDogdW5kZWZpbmVkLFxuICB5OiB1bmRlZmluZWQsXG59KTtcblxuY2xhc3MgVmVjdG9yIGV4dGVuZHMgVmVjdG9yUmVjb3JkIHtcbiAgZ2V0IG1hZ25pdHVkZSgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqKiAyICsgdGhpcy55ICoqIDIpO1xuICB9XG5cbiAgZXF1YWxzKHt4LCB5fSkge1xuICAgIHJldHVybiB0aGlzLnggPT09IHggJiYgdGhpcy55ID09PSB5O1xuICB9XG5cbiAgYWRkKHt4LCB5fSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yKHtcbiAgICAgIHg6IHRoaXMueCArIHgsXG4gICAgICB5OiB0aGlzLnkgKyB5LFxuICAgIH0pO1xuICB9XG5cbiAgc3ViKHt4LCB5fSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yKHtcbiAgICAgIHg6IHRoaXMueCAtIHgsXG4gICAgICB5OiB0aGlzLnkgLSB5LFxuICAgIH0pO1xuICB9XG5cbiAgZGl2KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3Ioe1xuICAgICAgeDogdGhpcy54IC8gdmFsdWUsXG4gICAgICB5OiB0aGlzLnkgLyB2YWx1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGRvdCh7eCwgeX0pIHtcbiAgICByZXR1cm4gdGhpcy54ICogeCArIHRoaXMueSAqIHk7XG4gIH1cblxuICBub3JtYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2KHRoaXMubWFnbml0dWRlKTtcbiAgfVxuXG4gIG5lZ2F0ZSgpIHtcbiAgICByZXR1cm4gbmV3IFZlY3Rvcih7XG4gICAgICB4OiAtdGhpcy54LFxuICAgICAgeTogLXRoaXMueSxcbiAgICB9KTtcbiAgfVxuXG4gIHNxdWFyZWREaXN0YW5jZVRvKHt4LCB5fSkge1xuICAgIHJldHVybiAodGhpcy54IC0geCkgKiogMiArICh0aGlzLnkgLSB5KSAqKiAyO1xuICB9XG5cbiAgaGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgXCIsXCIgKyB0aGlzLnk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3I7XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVscy92ZWN0b3IuanN4XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigkZ2V0UHJvdG90eXBlT2Ype1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuU3ltYm9sO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyICQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLndrcycpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuLyQua2V5b2YnKVxuICAsICRuYW1lcyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdldC1uYW1lcycpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuLyQuZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vJC5wcm9wZXJ0eS1kZXNjJylcbiAgLCBnZXREZXNjICAgICAgICA9ICQuZ2V0RGVzY1xuICAsIHNldERlc2MgICAgICAgID0gJC5zZXREZXNjXG4gICwgX2NyZWF0ZSAgICAgICAgPSAkLmNyZWF0ZVxuICAsIGdldE5hbWVzICAgICAgID0gJG5hbWVzLmdldFxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIHNldHRlciAgICAgICAgID0gZmFsc2VcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgaXNFbnVtICAgICAgICAgPSAkLmlzRW51bVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCB1c2VOYXRpdmUgICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoc2V0RGVzYyh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gc2V0RGVzYyh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnZXREZXNjKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIHNldERlc2MoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pc2V0RGVzYyhPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IHNldERlc2M7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbC5wcm90b3R5cGUpO1xuICBzeW0uX2sgPSB0YWc7XG4gIERFU0NSSVBUT1JTICYmIHNldHRlciAmJiBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlzZXREZXNjKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBzZXREZXNjKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkpO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldXG4gICAgPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgdmFyIEQgPSBnZXREZXNjKGl0ID0gdG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOKXJlc3VsdC5wdXNoKGtleSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyICRzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgLCBpICAgID0gMVxuICAgICwgJCQgICA9IGFyZ3VtZW50c1xuICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgd2hpbGUoJCQubGVuZ3RoID4gaSlhcmdzLnB1c2goJCRbaSsrXSk7XG4gIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgfTtcbiAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG59O1xudmFyIGJ1Z2d5SlNPTiA9ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighdXNlTmF0aXZlKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKGlzU3ltYm9sKHRoaXMpKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgcmV0dXJuIHdyYXAodWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKSk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2wucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xuICB9O1xuXG4gICQuY3JlYXRlICAgICA9ICRjcmVhdGU7XG4gICQuaXNFbnVtICAgICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgJC5nZXREZXNjICAgID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJC5zZXREZXNjICAgID0gJGRlZmluZVByb3BlcnR5O1xuICAkLnNldERlc2NzICAgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgJC5nZXROYW1lcyAgID0gJG5hbWVzLmdldCA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAkLmdldFN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuLyQubGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgc3ltYm9sU3RhdGljcyA9IHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufTtcbi8vIDE5LjQuMi4yIFN5bWJvbC5oYXNJbnN0YW5jZVxuLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxuLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXG4vLyAxOS40LjIuNiBTeW1ib2wubWF0Y2hcbi8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXG4vLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXG4vLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcbi8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcbi8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcbi8vIDE5LjQuMi4xMyBTeW1ib2wudG9TdHJpbmdUYWdcbi8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcbiQuZWFjaC5jYWxsKChcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCwnICtcbiAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHN5bSA9IHdrcyhpdCk7XG4gIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xufSk7XG5cbnNldHRlciA9IHRydWU7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3ltYm9sJywgc3ltYm9sU3RhdGljcyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXVzZU5hdGl2ZSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIXVzZU5hdGl2ZSB8fCBidWdneUpTT04pLCAnSlNPTicsIHtzdHJpbmdpZnk6ICRzdHJpbmdpZnl9KTtcblxuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaGFzLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRlc2NyaXB0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmhpZGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnByb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vJCcpLnNldERlc2NcbiAgLCBoYXMgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtdG8tc3RyaW5nLXRhZy5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3RvcmUgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIFN5bWJvbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKS5TeW1ib2w7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBTeW1ib2wgJiYgU3ltYm9sW25hbWVdIHx8IChTeW1ib2wgfHwgdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQud2tzLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudWlkLmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9ICQuZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5rZXlvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgZ2V0TmFtZXMgID0gcmVxdWlyZSgnLi8kJykuZ2V0TmFtZXNcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnZXROYW1lcyhpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICBpZih3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJylyZXR1cm4gZ2V0V2luZG93TmFtZXMoaXQpO1xuICByZXR1cm4gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2V0LW5hbWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5lbnVtLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5saWJyYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRjcmVhdGUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGVcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBfT2JqZWN0JGNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX09iamVjdCRzZXRQcm90b3R5cGVPZiA/IF9PYmplY3Qkc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGdldERlc2MgID0gcmVxdWlyZSgnLi8kJykuZ2V0RGVzY1xuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi8kLmN0eCcpKEZ1bmN0aW9uLmNhbGwsIGdldERlc2MoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1wcm90by5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqICBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqICBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwuSW1tdXRhYmxlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoY3Rvciwgc3VwZXJDbGFzcykge1xuICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSXRlcmFibGUodmFsdWUpID8gdmFsdWUgOiBTZXEodmFsdWUpO1xuICAgIH1cblxuXG4gIGNyZWF0ZUNsYXNzKEtleWVkSXRlcmFibGUsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBLZXllZEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZSA6IEtleWVkU2VxKHZhbHVlKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhJbmRleGVkSXRlcmFibGUsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBJbmRleGVkSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0luZGV4ZWQodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhTZXRJdGVyYWJsZSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIFNldEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJdGVyYWJsZSh2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICAgIH1cblxuXG5cbiAgZnVuY3Rpb24gaXNJdGVyYWJsZShtYXliZUl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuICEhKG1heWJlSXRlcmFibGUgJiYgbWF5YmVJdGVyYWJsZVtJU19JVEVSQUJMRV9TRU5USU5FTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXllZChtYXliZUtleWVkKSB7XG4gICAgcmV0dXJuICEhKG1heWJlS2V5ZWQgJiYgbWF5YmVLZXllZFtJU19LRVlFRF9TRU5USU5FTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuICAgIHJldHVybiAhIShtYXliZUluZGV4ZWQgJiYgbWF5YmVJbmRleGVkW0lTX0lOREVYRURfU0VOVElORUxdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuICAgIHJldHVybiBpc0tleWVkKG1heWJlQXNzb2NpYXRpdmUpIHx8IGlzSW5kZXhlZChtYXliZUFzc29jaWF0aXZlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcbiAgICByZXR1cm4gISEobWF5YmVPcmRlcmVkICYmIG1heWJlT3JkZXJlZFtJU19PUkRFUkVEX1NFTlRJTkVMXSk7XG4gIH1cblxuICBJdGVyYWJsZS5pc0l0ZXJhYmxlID0gaXNJdGVyYWJsZTtcbiAgSXRlcmFibGUuaXNLZXllZCA9IGlzS2V5ZWQ7XG4gIEl0ZXJhYmxlLmlzSW5kZXhlZCA9IGlzSW5kZXhlZDtcbiAgSXRlcmFibGUuaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG4gIEl0ZXJhYmxlLmlzT3JkZXJlZCA9IGlzT3JkZXJlZDtcblxuICBJdGVyYWJsZS5LZXllZCA9IEtleWVkSXRlcmFibGU7XG4gIEl0ZXJhYmxlLkluZGV4ZWQgPSBJbmRleGVkSXRlcmFibGU7XG4gIEl0ZXJhYmxlLlNldCA9IFNldEl0ZXJhYmxlO1xuXG5cbiAgdmFyIElTX0lURVJBQkxFX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJztcbiAgdmFyIElTX0tFWUVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcbiAgdmFyIElTX0lOREVYRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG4gIHZhciBJU19PUkRFUkVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG4gIC8vIFVzZWQgZm9yIHNldHRpbmcgcHJvdG90eXBlIG1ldGhvZHMgdGhhdCBJRTggY2hva2VzIG9uLlxuICB2YXIgREVMRVRFID0gJ2RlbGV0ZSc7XG5cbiAgLy8gQ29uc3RhbnRzIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdHJpZSBub2Rlcy5cbiAgdmFyIFNISUZUID0gNTsgLy8gUmVzdWx0ZWQgaW4gYmVzdCBwZXJmb3JtYW5jZSBhZnRlciBfX19fX18/XG4gIHZhciBTSVpFID0gMSA8PCBTSElGVDtcbiAgdmFyIE1BU0sgPSBTSVpFIC0gMTtcblxuICAvLyBBIGNvbnNpc3RlbnQgc2hhcmVkIHZhbHVlIHJlcHJlc2VudGluZyBcIm5vdCBzZXRcIiB3aGljaCBlcXVhbHMgbm90aGluZyBvdGhlclxuICAvLyB0aGFuIGl0c2VsZiwgYW5kIG5vdGhpbmcgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBleHRlcm5hbGx5LlxuICB2YXIgTk9UX1NFVCA9IHt9O1xuXG4gIC8vIEJvb2xlYW4gcmVmZXJlbmNlcywgUm91Z2ggZXF1aXZhbGVudCBvZiBgYm9vbCAmYC5cbiAgdmFyIENIQU5HRV9MRU5HVEggPSB7IHZhbHVlOiBmYWxzZSB9O1xuICB2YXIgRElEX0FMVEVSID0geyB2YWx1ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBNYWtlUmVmKHJlZikge1xuICAgIHJlZi52YWx1ZSA9IGZhbHNlO1xuICAgIHJldHVybiByZWY7XG4gIH1cblxuICBmdW5jdGlvbiBTZXRSZWYocmVmKSB7XG4gICAgcmVmICYmIChyZWYudmFsdWUgPSB0cnVlKTtcbiAgfVxuXG4gIC8vIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHZhbHVlIHJlcHJlc2VudGluZyBhbiBcIm93bmVyXCIgZm9yIHRyYW5zaWVudCB3cml0ZXNcbiAgLy8gdG8gdHJpZXMuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBvbmx5IGV2ZXIgZXF1YWwgaXRzZWxmLCBhbmQgd2lsbCBub3QgZXF1YWxcbiAgLy8gdGhlIHJldHVybiBvZiBhbnkgc3Vic2VxdWVudCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIE93bmVySUQoKSB7fVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvcHktYXJyYXktaW5saW5lXG4gIGZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgYXJyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgIG5ld0FycltpaV0gPSBhcnJbaWkgKyBvZmZzZXRdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyLnNpemUgPSBpdGVyLl9faXRlcmF0ZShyZXR1cm5UcnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuc2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBcImlzIGFycmF5IGluZGV4XCIgd2hpY2ggdGhlIEVDTUFTdHJpbmcgc3BlYyBkZWZpbmVzIGFzOlxuICAgIC8vXG4gICAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuICAgIC8vICAgICBUb1N0cmluZyhUb1VpbnQzMihQKSkgaXMgZXF1YWwgdG8gUCBhbmQgVG9VaW50MzIoUCkgaXMgbm90IGVxdWFsXG4gICAgLy8gICAgIHRvIDJeMzLiiJIxLlxuICAgIC8vXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LWV4b3RpYy1vYmplY3RzXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcbiAgICAgIGlmICgnJyArIHVpbnQzMkluZGV4ICE9PSBpbmRleCB8fCB1aW50MzJJbmRleCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgaW5kZXggPSB1aW50MzJJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiAoYmVnaW4gPT09IDAgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBiZWdpbiA8PSAtc2l6ZSkpICYmXG4gICAgICAoZW5kID09PSB1bmRlZmluZWQgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBlbmQgPj0gc2l6ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSB7XG4gICAgcmV0dXJuIHJlc29sdmVJbmRleChiZWdpbiwgc2l6ZSwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiByZXNvbHZlSW5kZXgoZW5kLCBzaXplLCBzaXplKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVJbmRleChpbmRleCwgc2l6ZSwgZGVmYXVsdEluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgP1xuICAgICAgZGVmYXVsdEluZGV4IDpcbiAgICAgIGluZGV4IDwgMCA/XG4gICAgICAgIE1hdGgubWF4KDAsIHNpemUgKyBpbmRleCkgOlxuICAgICAgICBzaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgIGluZGV4IDpcbiAgICAgICAgICBNYXRoLm1pbihzaXplLCBpbmRleCk7XG4gIH1cblxuICAvKiBnbG9iYWwgU3ltYm9sICovXG5cbiAgdmFyIElURVJBVEVfS0VZUyA9IDA7XG4gIHZhciBJVEVSQVRFX1ZBTFVFUyA9IDE7XG4gIHZhciBJVEVSQVRFX0VOVFJJRVMgPSAyO1xuXG4gIHZhciBSRUFMX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IFJFQUxfSVRFUkFUT1JfU1lNQk9MIHx8IEZBVVhfSVRFUkFUT1JfU1lNQk9MO1xuXG5cbiAgZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG5cbiAgICBJdGVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnW0l0ZXJhdG9yXSc7XG4gICAgfTtcblxuXG4gIEl0ZXJhdG9yLktFWVMgPSBJVEVSQVRFX0tFWVM7XG4gIEl0ZXJhdG9yLlZBTFVFUyA9IElURVJBVEVfVkFMVUVTO1xuICBJdGVyYXRvci5FTlRSSUVTID0gSVRFUkFURV9FTlRSSUVTO1xuXG4gIEl0ZXJhdG9yLnByb3RvdHlwZS5pbnNwZWN0ID1cbiAgSXRlcmF0b3IucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9XG4gIEl0ZXJhdG9yLnByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBpdGVyYXRvclJlc3VsdCkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGUgPT09IDAgPyBrIDogdHlwZSA9PT0gMSA/IHYgOiBbaywgdl07XG4gICAgaXRlcmF0b3JSZXN1bHQgPyAoaXRlcmF0b3JSZXN1bHQudmFsdWUgPSB2YWx1ZSkgOiAoaXRlcmF0b3JSZXN1bHQgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yUmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JEb25lKCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0l0ZXJhdG9yKG1heWJlSXRlcmFibGUpIHtcbiAgICByZXR1cm4gISFnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJdGVyYXRvcihtYXliZUl0ZXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3IgJiYgdHlwZW9mIG1heWJlSXRlcmF0b3IubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gaXRlcmFibGUgJiYgKFxuICAgICAgKFJFQUxfSVRFUkFUT1JfU1lNQk9MICYmIGl0ZXJhYmxlW1JFQUxfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgIGl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXVxuICAgICk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFNlcSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVNlcXVlbmNlKCkgOlxuICAgICAgICBpc0l0ZXJhYmxlKHZhbHVlKSA/IHZhbHVlLnRvU2VxKCkgOiBzZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZSAmJiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5lbnRyeVNlcSgpLnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKVxuXG4gICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdGUodGhpcywgZm4sIHJldmVyc2UsIHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuICAgIFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXFJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlLCB0cnVlKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhLZXllZFNlcSwgU2VxKTtcbiAgICBmdW5jdGlvbiBLZXllZFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgP1xuICAgICAgICBlbXB0eVNlcXVlbmNlKCkudG9LZXllZFNlcSgpIDpcbiAgICAgICAgaXNJdGVyYWJsZSh2YWx1ZSkgP1xuICAgICAgICAgIChpc0tleWVkKHZhbHVlKSA/IHZhbHVlLnRvU2VxKCkgOiB2YWx1ZS5mcm9tRW50cnlTZXEoKSkgOlxuICAgICAgICAgIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBLZXllZFNlcS5wcm90b3R5cGUudG9LZXllZFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoSW5kZXhlZFNlcSwgU2VxKTtcbiAgICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2VxdWVuY2UoKSA6XG4gICAgICAgICFpc0l0ZXJhYmxlKHZhbHVlKSA/IGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIDpcbiAgICAgICAgaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS5lbnRyeVNlcSgpIDogdmFsdWUudG9JbmRleGVkU2VxKCk7XG4gICAgfVxuXG4gICAgSW5kZXhlZFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBJbmRleGVkU2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgWycsICddJyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gc2VxSXRlcmF0ZSh0aGlzLCBmbiwgcmV2ZXJzZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UsIGZhbHNlKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhTZXRTZXEsIFNlcSk7XG4gICAgZnVuY3Rpb24gU2V0U2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXF1ZW5jZSgpIDpcbiAgICAgICAgIWlzSXRlcmFibGUodmFsdWUpID8gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgOlxuICAgICAgICBpc0tleWVkKHZhbHVlKSA/IHZhbHVlLmVudHJ5U2VxKCkgOiB2YWx1ZVxuICAgICAgKS50b1NldFNlcSgpO1xuICAgIH1cblxuICAgIFNldFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBTZXRTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0U2VxLnByb3RvdHlwZS50b1NldFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG5cbiAgU2VxLmlzU2VxID0gaXNTZXE7XG4gIFNlcS5LZXllZCA9IEtleWVkU2VxO1xuICBTZXEuU2V0ID0gU2V0U2VxO1xuICBTZXEuSW5kZXhlZCA9IEluZGV4ZWRTZXE7XG5cbiAgdmFyIElTX1NFUV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG4gIFNlcS5wcm90b3R5cGVbSVNfU0VRX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuXG4gIGNyZWF0ZUNsYXNzKEFycmF5U2VxLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBBcnJheVNlcShhcnJheSkge1xuICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgIHRoaXMuc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fYXJyYXlbd3JhcEluZGV4KHRoaXMsIGluZGV4KV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIGlmIChmbihhcnJheVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIFxuICAgICAgICB7cmV0dXJuIGlpID4gbWF4SW5kZXggP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSsrIDogaWkrK10pfVxuICAgICAgKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhPYmplY3RTZXEsIEtleWVkU2VxKTtcbiAgICBmdW5jdGlvbiBPYmplY3RTZXEob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKG5vdFNldFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFtrZXldO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgICAgdmFyIG1heEluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKGZuKG9iamVjdFtrZXldLCBrZXksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICAgIHZhciBtYXhJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICAgIHJldHVybiBpaSsrID4gbWF4SW5kZXggP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGtleSwgb2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuXG4gIGNyZWF0ZUNsYXNzKEl0ZXJhYmxlU2VxLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBJdGVyYWJsZVNlcShpdGVyYWJsZSkge1xuICAgICAgdGhpcy5faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXJhYmxlLmxlbmd0aCB8fCBpdGVyYWJsZS5zaXplO1xuICAgIH1cblxuICAgIEl0ZXJhYmxlU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLl9pdGVyYWJsZTtcbiAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGlmIChpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgSXRlcmFibGVTZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMuX2l0ZXJhYmxlO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgICAgaWYgKCFpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoSXRlcmF0b3JTZXEsIEluZGV4ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yU2VxKGl0ZXJhdG9yKSB7XG4gICAgICB0aGlzLl9pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgdGhpcy5faXRlcmF0b3JDYWNoZSA9IFtdO1xuICAgIH1cblxuICAgIEl0ZXJhdG9yU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2l0ZXJhdG9yQ2FjaGU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoaXRlcmF0aW9ucyA8IGNhY2hlLmxlbmd0aCkge1xuICAgICAgICBpZiAoZm4oY2FjaGVbaXRlcmF0aW9uc10sIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdGVwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIgdmFsID0gc3RlcC52YWx1ZTtcbiAgICAgICAgY2FjaGVbaXRlcmF0aW9uc10gPSB2YWw7XG4gICAgICAgIGlmIChmbih2YWwsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBJdGVyYXRvclNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlcmF0b3I7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9pdGVyYXRvckNhY2hlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmIChpdGVyYXRpb25zID49IGNhY2hlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWNoZVtpdGVyYXRpb25zXSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucywgY2FjaGVbaXRlcmF0aW9ucysrXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuXG4gIC8vICMgcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBpc1NlcShtYXliZVNlcSkge1xuICAgIHJldHVybiAhIShtYXliZVNlcSAmJiBtYXliZVNlcVtJU19TRVFfU0VOVElORUxdKTtcbiAgfVxuXG4gIHZhciBFTVBUWV9TRVE7XG5cbiAgZnVuY3Rpb24gZW1wdHlTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4gRU1QVFlfU0VRIHx8IChFTVBUWV9TRVEgPSBuZXcgQXJyYXlTZXEoW10pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9XG4gICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IG5ldyBBcnJheVNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuICAgICAgaXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmF0b3JTZXEodmFsdWUpLmZyb21FbnRyeVNlcSgpIDpcbiAgICAgIGhhc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYWJsZVNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IG5ldyBPYmplY3RTZXEodmFsdWUpIDpcbiAgICAgIHVuZGVmaW5lZDtcbiAgICBpZiAoIXNlcSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGl0ZXJhYmxlIG9iamVjdCBvZiBbaywgdl0gZW50cmllcywgJytcbiAgICAgICAgJ29yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIGlmICghc2VxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgaXRlcmFibGUgb2JqZWN0IG9mIHZhbHVlczogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgfHxcbiAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIG5ldyBPYmplY3RTZXEodmFsdWUpKTtcbiAgICBpZiAoIXNlcSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGl0ZXJhYmxlIG9iamVjdCBvZiB2YWx1ZXMsIG9yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSA/IG5ldyBBcnJheVNlcSh2YWx1ZSkgOlxuICAgICAgaXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmF0b3JTZXEodmFsdWUpIDpcbiAgICAgIGhhc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYWJsZVNlcSh2YWx1ZSkgOlxuICAgICAgdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcUl0ZXJhdGUoc2VxLCBmbiwgcmV2ZXJzZSwgdXNlS2V5cykge1xuICAgIHZhciBjYWNoZSA9IHNlcS5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSBjYWNoZS5sZW5ndGggLSAxO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKGZuKGVudHJ5WzFdLCB1c2VLZXlzID8gZW50cnlbMF0gOiBpaSwgc2VxKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWk7XG4gICAgfVxuICAgIHJldHVybiBzZXEuX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxSXRlcmF0b3Ioc2VxLCB0eXBlLCByZXZlcnNlLCB1c2VLZXlzKSB7XG4gICAgdmFyIGNhY2hlID0gc2VxLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IGNhY2hlLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgICByZXR1cm4gaWkrKyA+IG1heEluZGV4ID9cbiAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8gZW50cnlbMF0gOiBpaSAtIDEsIGVudHJ5WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VxLl9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KUyhqc29uLCBjb252ZXJ0ZXIpIHtcbiAgICByZXR1cm4gY29udmVydGVyID9cbiAgICAgIGZyb21KU1dpdGgoY29udmVydGVyLCBqc29uLCAnJywgeycnOiBqc29ufSkgOlxuICAgICAgZnJvbUpTRGVmYXVsdChqc29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KU1dpdGgoY29udmVydGVyLCBqc29uLCBrZXksIHBhcmVudEpTT04pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlci5jYWxsKHBhcmVudEpTT04sIGtleSwgSW5kZXhlZFNlcShqc29uKS5tYXAoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZnJvbUpTV2l0aChjb252ZXJ0ZXIsIHYsIGssIGpzb24pfSkpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlci5jYWxsKHBhcmVudEpTT04sIGtleSwgS2V5ZWRTZXEoanNvbikubWFwKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZyb21KU1dpdGgoY29udmVydGVyLCB2LCBrLCBqc29uKX0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSlNEZWZhdWx0KGpzb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgcmV0dXJuIEluZGV4ZWRTZXEoanNvbikubWFwKGZyb21KU0RlZmF1bHQpLnRvTGlzdCgpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuICAgICAgcmV0dXJuIEtleWVkU2VxKGpzb24pLm1hcChmcm9tSlNEZWZhdWx0KS50b01hcCgpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmoodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCk7XG4gIH1cblxuICAvKipcbiAgICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBcInNhbWUtdmFsdWVcIiBhbGdvcml0aG0gYXMgW2Rlc2NyaWJlZCBmb3IgdXNlIGJ5IEVTNiBNYXBcbiAgICogYW5kIFNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0tleV9lcXVhbGl0eSlcbiAgICpcbiAgICogTmFOIGlzIGNvbnNpZGVyZWQgdGhlIHNhbWUgYXMgTmFOLCBob3dldmVyIC0wIGFuZCAwIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAqIHZhbHVlLCB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBieVxuICAgKiBbYE9iamVjdC5pc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pcykuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0ZW5kZWQgZnVydGhlciB0byBhbGxvdyBPYmplY3RzIHRvIGRlc2NyaWJlIHRoZSB2YWx1ZXMgdGhleVxuICAgKiByZXByZXNlbnQsIGJ5IHdheSBvZiBgdmFsdWVPZmAgb3IgYGVxdWFsc2AgKGFuZCBgaGFzaENvZGVgKS5cbiAgICpcbiAgICogTm90ZTogYmVjYXVzZSBvZiB0aGlzIGV4dGVuc2lvbiwgdGhlIGtleSBlcXVhbGl0eSBvZiBJbW11dGFibGUuTWFwIGFuZCB0aGVcbiAgICogdmFsdWUgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLlNldCB3aWxsIGRpZmZlciBmcm9tIEVTNiBNYXAgYW5kIFNldC5cbiAgICpcbiAgICogIyMjIERlZmluaW5nIGN1c3RvbSB2YWx1ZXNcbiAgICpcbiAgICogVGhlIGVhc2llc3Qgd2F5IHRvIGRlc2NyaWJlIHRoZSB2YWx1ZSBhbiBvYmplY3QgcmVwcmVzZW50cyBpcyBieSBpbXBsZW1lbnRpbmdcbiAgICogYHZhbHVlT2ZgLiBGb3IgZXhhbXBsZSwgYERhdGVgIHJlcHJlc2VudHMgYSB2YWx1ZSBieSByZXR1cm5pbmcgYSB1bml4XG4gICAqIHRpbWVzdGFtcCBmb3IgYHZhbHVlT2ZgOlxuICAgKlxuICAgKiAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7IC8vIEZyaSBGZWIgMTMgMjAwOSAuLi5cbiAgICogICAgIHZhciBkYXRlMiA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApO1xuICAgKiAgICAgZGF0ZTEudmFsdWVPZigpOyAvLyAxMjM0NTY3ODkwMDAwXG4gICAqICAgICBhc3NlcnQoIGRhdGUxICE9PSBkYXRlMiApO1xuICAgKiAgICAgYXNzZXJ0KCBJbW11dGFibGUuaXMoIGRhdGUxLCBkYXRlMiApICk7XG4gICAqXG4gICAqIE5vdGU6IG92ZXJyaWRpbmcgYHZhbHVlT2ZgIG1heSBoYXZlIG90aGVyIGltcGxpY2F0aW9ucyBpZiB5b3UgdXNlIHRoaXMgb2JqZWN0XG4gICAqIHdoZXJlIEphdmFTY3JpcHQgZXhwZWN0cyBhIHByaW1pdGl2ZSwgc3VjaCBhcyBpbXBsaWNpdCBzdHJpbmcgY29lcmNpb24uXG4gICAqXG4gICAqIEZvciBtb3JlIGNvbXBsZXggdHlwZXMsIGVzcGVjaWFsbHkgY29sbGVjdGlvbnMsIGltcGxlbWVudGluZyBgdmFsdWVPZmAgbWF5XG4gICAqIG5vdCBiZSBwZXJmb3JtYW50LiBBbiBhbHRlcm5hdGl2ZSBpcyB0byBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gICAqXG4gICAqIGBlcXVhbHNgIHRha2VzIGFub3RoZXIgb2JqZWN0LCBwcmVzdW1hYmx5IG9mIHNpbWlsYXIgdHlwZSwgYW5kIHJldHVybnMgdHJ1ZVxuICAgKiBpZiB0aGUgaXQgaXMgZXF1YWwuIEVxdWFsaXR5IGlzIHN5bW1ldHJpY2FsLCBzbyB0aGUgc2FtZSByZXN1bHQgc2hvdWxkIGJlXG4gICAqIHJldHVybmVkIGlmIHRoaXMgYW5kIHRoZSBhcmd1bWVudCBhcmUgZmxpcHBlZC5cbiAgICpcbiAgICogICAgIGFzc2VydCggYS5lcXVhbHMoYikgPT09IGIuZXF1YWxzKGEpICk7XG4gICAqXG4gICAqIGBoYXNoQ29kZWAgcmV0dXJucyBhIDMyYml0IGludGVnZXIgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgb2JqZWN0IHdoaWNoIHdpbGxcbiAgICogYmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRoZSB2YWx1ZSBvYmplY3QgaW4gYSBNYXAgb3IgU2V0LiBZb3UgbXVzdFxuICAgKiBwcm92aWRlIGJvdGggb3IgbmVpdGhlciBtZXRob2RzLCBvbmUgbXVzdCBub3QgZXhpc3Qgd2l0aG91dCB0aGUgb3RoZXIuXG4gICAqXG4gICAqIEFsc28sIGFuIGltcG9ydGFudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSBtZXRob2RzIG11c3QgYmUgdXBoZWxkOiBpZiB0d29cbiAgICogdmFsdWVzIGFyZSBlcXVhbCwgdGhleSAqbXVzdCogcmV0dXJuIHRoZSBzYW1lIGhhc2hDb2RlLiBJZiB0aGUgdmFsdWVzIGFyZSBub3RcbiAgICogZXF1YWwsIHRoZXkgbWlnaHQgaGF2ZSB0aGUgc2FtZSBoYXNoQ29kZTsgdGhpcyBpcyBjYWxsZWQgYSBoYXNoIGNvbGxpc2lvbixcbiAgICogYW5kIHdoaWxlIHVuZGVzaXJhYmxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyBhY2NlcHRhYmxlLlxuICAgKlxuICAgKiAgICAgaWYgKGEuZXF1YWxzKGIpKSB7XG4gICAqICAgICAgIGFzc2VydCggYS5oYXNoQ29kZSgpID09PSBiLmhhc2hDb2RlKCkgKTtcbiAgICogICAgIH1cbiAgICpcbiAgICogQWxsIEltbXV0YWJsZSBjb2xsZWN0aW9ucyBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBpcyh2YWx1ZUEsIHZhbHVlQikge1xuICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlQS52YWx1ZU9mID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZUIudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWVBID0gdmFsdWVBLnZhbHVlT2YoKTtcbiAgICAgIHZhbHVlQiA9IHZhbHVlQi52YWx1ZU9mKCk7XG4gICAgICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlQS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlQi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdmFsdWVBLmVxdWFscyh2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWlzSXRlcmFibGUoYikgfHxcbiAgICAgIGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplIHx8XG4gICAgICBhLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmIGIuX19oYXNoICE9PSB1bmRlZmluZWQgJiYgYS5fX2hhc2ggIT09IGIuX19oYXNoIHx8XG4gICAgICBpc0tleWVkKGEpICE9PSBpc0tleWVkKGIpIHx8XG4gICAgICBpc0luZGV4ZWQoYSkgIT09IGlzSW5kZXhlZChiKSB8fFxuICAgICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYS5zaXplID09PSAwICYmIGIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG5vdEFzc29jaWF0aXZlID0gIWlzQXNzb2NpYXRpdmUoYSk7XG5cbiAgICBpZiAoaXNPcmRlcmVkKGEpKSB7XG4gICAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgICAgcmV0dXJuIGIuZXZlcnkoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5uZXh0KCkudmFsdWU7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBpcyhlbnRyeVsxXSwgdikgJiYgKG5vdEFzc29jaWF0aXZlIHx8IGlzKGVudHJ5WzBdLCBrKSk7XG4gICAgICB9KSAmJiBlbnRyaWVzLm5leHQoKS5kb25lO1xuICAgIH1cblxuICAgIHZhciBmbGlwcGVkID0gZmFsc2U7XG5cbiAgICBpZiAoYS5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGEuY2FjaGVSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhLmNhY2hlUmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsaXBwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgXyA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gXztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWxsRXF1YWwgPSB0cnVlO1xuICAgIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICBpZiAobm90QXNzb2NpYXRpdmUgPyAhYS5oYXModikgOlxuICAgICAgICAgIGZsaXBwZWQgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpIDogIWlzKGEuZ2V0KGssIE5PVF9TRVQpLCB2KSkge1xuICAgICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWxsRXF1YWwgJiYgYS5zaXplID09PSBiU2l6ZTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJlcGVhdCwgSW5kZXhlZFNlcSk7XG5cbiAgICBmdW5jdGlvbiBSZXBlYXQodmFsdWUsIHRpbWVzKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVwZWF0KSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKEVNUFRZX1JFUEVBVCkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SRVBFQVQ7XG4gICAgICAgIH1cbiAgICAgICAgRU1QVFlfUkVQRUFUID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmVwZWF0IFtdJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5zaXplICsgJyB0aW1lcyBdJztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl92YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSA/IHRoaXMgOlxuICAgICAgICBuZXcgUmVwZWF0KHRoaXMuX3ZhbHVlLCByZXNvbHZlRW5kKGVuZCwgc2l6ZSkgLSByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB0aGlzLnNpemU7IGlpKyspIHtcbiAgICAgICAgaWYgKGZuKHRoaXMuX3ZhbHVlLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIFxuICAgICAgICB7cmV0dXJuIGlpIDwgdGhpcyQwLnNpemUgPyBpdGVyYXRvclZhbHVlKHR5cGUsIGlpKyssIHRoaXMkMC5fdmFsdWUpIDogaXRlcmF0b3JEb25lKCl9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSZXBlYXQgP1xuICAgICAgICBpcyh0aGlzLl92YWx1ZSwgb3RoZXIuX3ZhbHVlKSA6XG4gICAgICAgIGRlZXBFcXVhbChvdGhlcik7XG4gICAgfTtcblxuXG4gIHZhciBFTVBUWV9SRVBFQVQ7XG5cbiAgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJhbmdlLCBJbmRleGVkU2VxKTtcblxuICAgIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICAgIH1cbiAgICAgIGludmFyaWFudChzdGVwICE9PSAwLCAnQ2Fubm90IHN0ZXAgYSBSYW5nZSBieSAwJyk7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGguYWJzKHN0ZXApO1xuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCAtIDEpICsgMSk7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChFTVBUWV9SQU5HRSkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SQU5HRSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmFuZ2UgW10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdSYW5nZSBbICcgK1xuICAgICAgICB0aGlzLl9zdGFydCArICcuLi4nICsgdGhpcy5fZW5kICtcbiAgICAgICAgKHRoaXMuX3N0ZXAgIT09IDEgPyAnIGJ5ICcgKyB0aGlzLl9zdGVwIDogJycpICtcbiAgICAgICcgXSc7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgP1xuICAgICAgICB0aGlzLl9zdGFydCArIHdyYXBJbmRleCh0aGlzLCBpbmRleCkgKiB0aGlzLl9zdGVwIDpcbiAgICAgICAgbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIgcG9zc2libGVJbmRleCA9IChzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0KSAvIHRoaXMuX3N0ZXA7XG4gICAgICByZXR1cm4gcG9zc2libGVJbmRleCA+PSAwICYmXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcbiAgICAgICAgcG9zc2libGVJbmRleCA9PT0gTWF0aC5mbG9vcihwb3NzaWJsZUluZGV4KTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgICAgZW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAoZW5kIDw9IGJlZ2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuZ2V0KGJlZ2luLCB0aGlzLl9lbmQpLCB0aGlzLmdldChlbmQsIHRoaXMuX2VuZCksIHRoaXMuX3N0ZXApO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0VmFsdWUgPSBzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgaWYgKG9mZnNldFZhbHVlICUgdGhpcy5fc3RlcCA9PT0gMCkge1xuICAgICAgICB2YXIgaW5kZXggPSBvZmZzZXRWYWx1ZSAvIHRoaXMuX3N0ZXA7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IHRoaXMuc2l6ZSAtIDE7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyBtYXhJbmRleCAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgICAgaWYgKGZuKHZhbHVlLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IHRoaXMuc2l6ZSAtIDE7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyBtYXhJbmRleCAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgICAgcmV0dXJuIGlpID4gbWF4SW5kZXggPyBpdGVyYXRvckRvbmUoKSA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaWkrKywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSYW5nZSA/XG4gICAgICAgIHRoaXMuX3N0YXJ0ID09PSBvdGhlci5fc3RhcnQgJiZcbiAgICAgICAgdGhpcy5fZW5kID09PSBvdGhlci5fZW5kICYmXG4gICAgICAgIHRoaXMuX3N0ZXAgPT09IG90aGVyLl9zdGVwIDpcbiAgICAgICAgZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgICB9O1xuXG5cbiAgdmFyIEVNUFRZX1JBTkdFO1xuXG4gIGNyZWF0ZUNsYXNzKENvbGxlY3Rpb24sIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdBYnN0cmFjdCcpO1xuICAgIH1cblxuXG4gIGNyZWF0ZUNsYXNzKEtleWVkQ29sbGVjdGlvbiwgQ29sbGVjdGlvbik7ZnVuY3Rpb24gS2V5ZWRDb2xsZWN0aW9uKCkge31cblxuICBjcmVhdGVDbGFzcyhJbmRleGVkQ29sbGVjdGlvbiwgQ29sbGVjdGlvbik7ZnVuY3Rpb24gSW5kZXhlZENvbGxlY3Rpb24oKSB7fVxuXG4gIGNyZWF0ZUNsYXNzKFNldENvbGxlY3Rpb24sIENvbGxlY3Rpb24pO2Z1bmN0aW9uIFNldENvbGxlY3Rpb24oKSB7fVxuXG5cbiAgQ29sbGVjdGlvbi5LZXllZCA9IEtleWVkQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5JbmRleGVkID0gSW5kZXhlZENvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uU2V0ID0gU2V0Q29sbGVjdGlvbjtcblxuICB2YXIgaW11bCA9XG4gICAgdHlwZW9mIE1hdGguaW11bCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXRoLmltdWwoMHhmZmZmZmZmZiwgMikgPT09IC0yID9cbiAgICBNYXRoLmltdWwgOlxuICAgIGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICAgICAgYSA9IGEgfCAwOyAvLyBpbnRcbiAgICAgIGIgPSBiIHwgMDsgLy8gaW50XG4gICAgICB2YXIgYyA9IGEgJiAweGZmZmY7XG4gICAgICB2YXIgZCA9IGIgJiAweGZmZmY7XG4gICAgICAvLyBTaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnQuXG4gICAgICByZXR1cm4gKGMgKiBkKSArICgoKChhID4+PiAxNikgKiBkICsgYyAqIChiID4+PiAxNikpIDw8IDE2KSA+Pj4gMCkgfCAwOyAvLyBpbnRcbiAgICB9O1xuXG4gIC8vIHY4IGhhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHN0b3JpbmcgMzEtYml0IHNpZ25lZCBudW1iZXJzLlxuICAvLyBWYWx1ZXMgd2hpY2ggaGF2ZSBlaXRoZXIgMDAgb3IgMTEgYXMgdGhlIGhpZ2ggb3JkZXIgYml0cyBxdWFsaWZ5LlxuICAvLyBUaGlzIGZ1bmN0aW9uIGRyb3BzIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCBpbiBhIHNpZ25lZCBudW1iZXIsIG1haW50YWluaW5nXG4gIC8vIHRoZSBzaWduIGJpdC5cbiAgZnVuY3Rpb24gc21pKGkzMikge1xuICAgIHJldHVybiAoKGkzMiA+Pj4gMSkgJiAweDQwMDAwMDAwKSB8IChpMzIgJiAweEJGRkZGRkZGKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2gobykge1xuICAgIGlmIChvID09PSBmYWxzZSB8fCBvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygby52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvID0gby52YWx1ZU9mKCk7XG4gICAgICBpZiAobyA9PT0gZmFsc2UgfHwgbyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgbztcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChvICE9PSBvIHx8IG8gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgdmFyIGggPSBvIHwgMDtcbiAgICAgIGlmIChoICE9PSBvKSB7XG4gICAgICAgIGggXj0gbyAqIDB4RkZGRkZGRkY7XG4gICAgICB9XG4gICAgICB3aGlsZSAobyA+IDB4RkZGRkZGRkYpIHtcbiAgICAgICAgbyAvPSAweEZGRkZGRkZGO1xuICAgICAgICBoIF49IG87XG4gICAgICB9XG4gICAgICByZXR1cm4gc21pKGgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvLmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPyBjYWNoZWRIYXNoU3RyaW5nKG8pIDogaGFzaFN0cmluZyhvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gby5oYXNoQ29kZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBoYXNoSlNPYmoobyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygby50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGhhc2hTdHJpbmcoby50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSB0eXBlICcgKyB0eXBlICsgJyBjYW5ub3QgYmUgaGFzaGVkLicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVkSGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgICB2YXIgaGFzaCA9IHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddO1xuICAgIGlmIChoYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9PT0gU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUpIHtcbiAgICAgICAgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG4gICAgICAgIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSsrO1xuICAgICAgc3RyaW5nSGFzaENhY2hlW3N0cmluZ10gPSBoYXNoO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2hhc2hpbmctc3RyaW5nc1xuICBmdW5jdGlvbiBoYXNoU3RyaW5nKHN0cmluZykge1xuICAgIC8vIFRoaXMgaXMgdGhlIGhhc2ggZnJvbSBKVk1cbiAgICAvLyBUaGUgaGFzaCBjb2RlIGZvciBhIHN0cmluZyBpcyBjb21wdXRlZCBhc1xuICAgIC8vIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gICAgLy8gd2hlcmUgc1tpXSBpcyB0aGUgaXRoIGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIGFuZCBuIGlzIHRoZSBsZW5ndGggb2ZcbiAgICAvLyB0aGUgc3RyaW5nLiBXZSBcIm1vZFwiIHRoZSByZXN1bHQgdG8gbWFrZSBpdCBiZXR3ZWVuIDAgKGluY2x1c2l2ZSkgYW5kIDJeMzFcbiAgICAvLyAoZXhjbHVzaXZlKSBieSBkcm9wcGluZyBoaWdoIGJpdHMuXG4gICAgdmFyIGhhc2ggPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdHJpbmcubGVuZ3RoOyBpaSsrKSB7XG4gICAgICBoYXNoID0gMzEgKiBoYXNoICsgc3RyaW5nLmNoYXJDb2RlQXQoaWkpIHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHNtaShoYXNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hKU09iaihvYmopIHtcbiAgICB2YXIgaGFzaDtcbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICBoYXNoID0gd2Vha01hcC5nZXQob2JqKTtcbiAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaCA9IG9ialtVSURfSEFTSF9LRVldO1xuICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmICghY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIGhhc2ggPSBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgJiYgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV07XG4gICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuXG4gICAgICBoYXNoID0gZ2V0SUVOb2RlSGFzaChvYmopO1xuICAgICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoID0gKytvYmpIYXNoVUlEO1xuICAgIGlmIChvYmpIYXNoVUlEICYgMHg0MDAwMDAwMCkge1xuICAgICAgb2JqSGFzaFVJRCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgICAgd2Vha01hcC5zZXQob2JqLCBoYXNoKTtcbiAgICB9IGVsc2UgaWYgKGlzRXh0ZW5zaWJsZSAhPT0gdW5kZWZpbmVkICYmIGlzRXh0ZW5zaWJsZShvYmopID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tZXh0ZW5zaWJsZSBvYmplY3RzIGFyZSBub3QgYWxsb3dlZCBhcyBrZXlzLicpO1xuICAgIH0gZWxzZSBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFVJRF9IQVNIX0tFWSwge1xuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd3cml0YWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBoYXNoXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgPT09IG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpIHtcbiAgICAgIC8vIFNpbmNlIHdlIGNhbid0IGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICAgIC8vIHdlJ2xsIGhpamFjayBvbmUgb2YgdGhlIGxlc3MtdXNlZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRvXG4gICAgICAvLyBzYXZlIG91ciBoYXNoIG9uIGl0LiBTaW5jZSB0aGlzIGlzIGEgZnVuY3Rpb24gaXQgd2lsbCBub3Qgc2hvdyB1cCBpblxuICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV0gPSBoYXNoO1xuICAgIH0gZWxzZSBpZiAob2JqLm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAgIC8vIGFuZCB3ZSBjb3VsZG4ndCB1c2UgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSB0byBleHBsb2l0IHRoZVxuICAgICAgLy8gZG9udEVudW0gYnVnIHNvIHdlIHNpbXBseSBhZGQgdGhlIGBVSURfSEFTSF9LRVlgIG9uIHRoZSBub2RlXG4gICAgICAvLyBpdHNlbGYuXG4gICAgICBvYmpbVUlEX0hBU0hfS0VZXSA9IGhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNldCBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIC8vIEdldCByZWZlcmVuY2VzIHRvIEVTNSBvYmplY3QgbWV0aG9kcy5cbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiAgLy8gVHJ1ZSBpZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgd29ya3MgYXMgZXhwZWN0ZWQuIElFOCBmYWlscyB0aGlzIHRlc3QuXG4gIHZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnQCcsIHt9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0oKSk7XG5cbiAgLy8gSUUgaGFzIGEgYHVuaXF1ZUlEYCBwcm9wZXJ0eSBvbiBET00gbm9kZXMuIFdlIGNhbiBjb25zdHJ1Y3QgdGhlIGhhc2ggZnJvbSBpdFxuICAvLyBhbmQgYXZvaWQgbWVtb3J5IGxlYWtzIGZyb20gdGhlIElFIGNsb25lTm9kZSBidWcuXG4gIGZ1bmN0aW9uIGdldElFTm9kZUhhc2gobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPiAwKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAxOiAvLyBFbGVtZW50XG4gICAgICAgICAgcmV0dXJuIG5vZGUudW5pcXVlSUQ7XG4gICAgICAgIGNhc2UgOTogLy8gRG9jdW1lbnRcbiAgICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudEVsZW1lbnQgJiYgbm9kZS5kb2N1bWVudEVsZW1lbnQudW5pcXVlSUQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgcG9zc2libGUsIHVzZSBhIFdlYWtNYXAuXG4gIHZhciB1c2luZ1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIHdlYWtNYXA7XG4gIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICB3ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHZhciBvYmpIYXNoVUlEID0gMDtcblxuICB2YXIgVUlEX0hBU0hfS0VZID0gJ19faW1tdXRhYmxlaGFzaF9fJztcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICBVSURfSEFTSF9LRVkgPSBTeW1ib2woVUlEX0hBU0hfS0VZKTtcbiAgfVxuXG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOID0gMTY7XG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSA9IDI1NTtcbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuICB2YXIgc3RyaW5nSGFzaENhY2hlID0ge307XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSkge1xuICAgIGludmFyaWFudChcbiAgICAgIHNpemUgIT09IEluZmluaXR5LFxuICAgICAgJ0Nhbm5vdCBwZXJmb3JtIHRoaXMgYWN0aW9uIHdpdGggYW4gaW5maW5pdGUgc2l6ZS4nXG4gICAgKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE1hcCwgS2V5ZWRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlNYXAoKSA6XG4gICAgICAgIGlzTWFwKHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKG1hcCApIHtcbiAgICAgICAgICB2YXIgaXRlciA9IEtleWVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIG1hcC5zZXQoaywgdil9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgTWFwLm9mID0gZnVuY3Rpb24oKSB7dmFyIGtleVZhbHVlcyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihtYXAgKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgaWYgKGkgKyAxID49IGtleVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWx1ZSBmb3Iga2V5OiAnICsga2V5VmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLnNldChrZXlWYWx1ZXNbaV0sIGtleVZhbHVlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTWFwIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgP1xuICAgICAgICB0aGlzLl9yb290LmdldCgwLCB1bmRlZmluZWQsIGssIG5vdFNldFZhbHVlKSA6XG4gICAgICAgIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrLCB2KSB7XG4gICAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIHYpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNldEluID0gZnVuY3Rpb24oa2V5UGF0aCwgdikge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oa2V5UGF0aCwgTk9UX1NFVCwgZnVuY3Rpb24oKSAge3JldHVybiB2fSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5kZWxldGVJbiA9IGZ1bmN0aW9uKGtleVBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUluKGtleVBhdGgsIGZ1bmN0aW9uKCkgIHtyZXR1cm4gTk9UX1NFVH0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgIGsodGhpcykgOlxuICAgICAgICB0aGlzLnVwZGF0ZUluKFtrXSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnVwZGF0ZUluID0gZnVuY3Rpb24oa2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICAgIGlmICghdXBkYXRlcikge1xuICAgICAgICB1cGRhdGVyID0gbm90U2V0VmFsdWU7XG4gICAgICAgIG5vdFNldFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZUluRGVlcE1hcChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZm9yY2VJdGVyYXRvcihrZXlQYXRoKSxcbiAgICAgICAgbm90U2V0VmFsdWUsXG4gICAgICAgIHVwZGF0ZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdXBkYXRlZFZhbHVlID09PSBOT1RfU0VUID8gdW5kZWZpbmVkIDogdXBkYXRlZFZhbHVlO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eU1hcCgpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oLyouLi5pdGVycyovKSB7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCB1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBtZXJnZXIsIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZUluID0gZnVuY3Rpb24oa2V5UGF0aCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oXG4gICAgICAgIGtleVBhdGgsXG4gICAgICAgIGVtcHR5TWFwKCksXG4gICAgICAgIGZ1bmN0aW9uKG0gKSB7cmV0dXJuIHR5cGVvZiBtLm1lcmdlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICBtLm1lcmdlLmFwcGx5KG0sIGl0ZXJzKSA6XG4gICAgICAgICAgaXRlcnNbaXRlcnMubGVuZ3RoIC0gMV19XG4gICAgICApO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlRGVlcCA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuICAgICAgcmV0dXJuIG1lcmdlSW50b01hcFdpdGgodGhpcywgZGVlcE1lcmdlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpLCBpdGVycyk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBmdW5jdGlvbihrZXlQYXRoKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgZW1wdHlNYXAoKSxcbiAgICAgICAgZnVuY3Rpb24obSApIHtyZXR1cm4gdHlwZW9mIG0ubWVyZ2VEZWVwID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICBtLm1lcmdlRGVlcC5hcHBseShtLCBpdGVycykgOlxuICAgICAgICAgIGl0ZXJzW2l0ZXJzLmxlbmd0aCAtIDFdfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICAgIE1hcC5wcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB2YXIgbXV0YWJsZSA9IHRoaXMuYXNNdXRhYmxlKCk7XG4gICAgICBmbihtdXRhYmxlKTtcbiAgICAgIHJldHVybiBtdXRhYmxlLndhc0FsdGVyZWQoKSA/IG11dGFibGUuX19lbnN1cmVPd25lcih0aGlzLl9fb3duZXJJRCkgOiB0aGlzO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmFzTXV0YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IHRoaXMuX19lbnN1cmVPd25lcihuZXcgT3duZXJJRCgpKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19lbnN1cmVPd25lcigpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fYWx0ZXJlZDtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lml0ZXJhdGUoZnVuY3Rpb24oZW50cnkgKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQwKTtcbiAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VNYXAodGhpcy5zaXplLCB0aGlzLl9yb290LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzTWFwKG1heWJlTWFwKSB7XG4gICAgcmV0dXJuICEhKG1heWJlTWFwICYmIG1heWJlTWFwW0lTX01BUF9TRU5USU5FTF0pO1xuICB9XG5cbiAgTWFwLmlzTWFwID0gaXNNYXA7XG5cbiAgdmFyIElTX01BUF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX01BUF9fQEAnO1xuXG4gIHZhciBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuICBNYXBQcm90b3R5cGVbSVNfTUFQX1NFTlRJTkVMXSA9IHRydWU7XG4gIE1hcFByb3RvdHlwZVtERUxFVEVdID0gTWFwUHJvdG90eXBlLnJlbW92ZTtcbiAgTWFwUHJvdG90eXBlLnJlbW92ZUluID0gTWFwUHJvdG90eXBlLmRlbGV0ZUluO1xuXG5cbiAgLy8gI3ByYWdtYSBUcmllIE5vZGVzXG5cblxuXG4gICAgZnVuY3Rpb24gQXJyYXlNYXBOb2RlKG93bmVySUQsIGVudHJpZXMpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIH1cblxuICAgIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgICAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgZm9yICh2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gICAgICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgICAgIGlmIChyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmICghZXhpc3RzICYmICFyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID49IE1BWF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgIGlkeCA9PT0gbGVuIC0gMSA/IG5ld0VudHJpZXMucG9wKCkgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0VudHJpZXMpO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIG5vZGVzKSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuXG4gICAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgYml0ID0gKDEgPDwgKChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLKSk7XG4gICAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgICByZXR1cm4gKGJpdG1hcCAmIGJpdCkgPT09IDAgPyBub3RTZXRWYWx1ZSA6XG4gICAgICAgIHRoaXMubm9kZXNbcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKV0uZ2V0KHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpO1xuICAgIH07XG5cbiAgICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5SGFzaEZyYWcgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICAgIHZhciBiaXQgPSAxIDw8IGtleUhhc2hGcmFnO1xuICAgICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgICAgdmFyIGV4aXN0cyA9IChiaXRtYXAgJiBiaXQpICE9PSAwO1xuXG4gICAgICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGlkeCA9IHBvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgdmFyIG5vZGUgPSBleGlzdHMgPyBub2Rlc1tpZHhdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcblxuICAgICAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID49IE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFKSB7XG4gICAgICAgIHJldHVybiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBrZXlIYXNoRnJhZywgbmV3Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChleGlzdHMgJiYgIW5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAyICYmIGlzTGVhZk5vZGUobm9kZXNbaWR4IF4gMV0pKSB7XG4gICAgICAgIHJldHVybiBub2Rlc1tpZHggXiAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpc0xlYWZOb2RlKG5ld05vZGUpKSB7XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgICAgdmFyIG5ld0JpdG1hcCA9IGV4aXN0cyA/IG5ld05vZGUgPyBiaXRtYXAgOiBiaXRtYXAgXiBiaXQgOiBiaXRtYXAgfCBiaXQ7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBleGlzdHMgPyBuZXdOb2RlID9cbiAgICAgICAgc2V0SW4obm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSkgOlxuICAgICAgICBzcGxpY2VPdXQobm9kZXMsIGlkeCwgaXNFZGl0YWJsZSkgOlxuICAgICAgICBzcGxpY2VJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5iaXRtYXAgPSBuZXdCaXRtYXA7XG4gICAgICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgbmV3Qml0bWFwLCBuZXdOb2Rlcyk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cblxuICAgIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbaWR4XTtcbiAgICAgIHJldHVybiBub2RlID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaWR4XTtcblxuICAgICAgaWYgKHJlbW92ZWQgJiYgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcik7XG4gICAgICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0NvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBuZXdDb3VudCsrO1xuICAgICAgfSBlbHNlIGlmICghbmV3Tm9kZSkge1xuICAgICAgICBuZXdDb3VudC0tO1xuICAgICAgICBpZiAobmV3Q291bnQgPCBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgICAgIHJldHVybiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIG5ld0NvdW50LCBpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBzZXRJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IG5ld0NvdW50O1xuICAgICAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3Q291bnQsIG5ld05vZGVzKTtcbiAgICB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cmllcykge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIH1cblxuICAgIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gICAgICBpZiAoa2V5SGFzaCAhPT0gdGhpcy5rZXlIYXNoKSB7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICB2YXIgaWR4ID0gMDtcbiAgICAgIGZvciAodmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICAgICAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gICAgICBpZiAocmVtb3ZlZCAmJiBsZW4gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBlbnRyaWVzW2lkeCBeIDFdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICAgIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgaWR4ID09PSBsZW4gLSAxID8gbmV3RW50cmllcy5wb3AoKSA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIG5ld0VudHJpZXMpO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICAgICAgdGhpcy5lbnRyeSA9IGVudHJ5O1xuICAgIH1cblxuICAgIFZhbHVlTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiBpcyhrZXksIHRoaXMuZW50cnlbMF0pID8gdGhpcy5lbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBWYWx1ZU5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgICAgIHZhciBrZXlNYXRjaCA9IGlzKGtleSwgdGhpcy5lbnRyeVswXSk7XG4gICAgICBpZiAoa2V5TWF0Y2ggPyB2YWx1ZSA9PT0gdGhpcy5lbnRyeVsxXSA6IHJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG5cbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICAgIGlmIChvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRCkge1xuICAgICAgICAgIHRoaXMuZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gICAgfTtcblxuXG5cbiAgLy8gI3ByYWdtYSBJdGVyYXRvcnNcblxuICBBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPVxuICBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICBpZiAoZm4oZW50cmllc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBub2Rlcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgIGlmIChub2RlICYmIG5vZGUuaXRlcmF0ZShmbiwgcmV2ZXJzZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBWYWx1ZU5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICByZXR1cm4gZm4odGhpcy5lbnRyeSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhNYXBJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG4gICAgZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCB0eXBlLCByZXZlcnNlKSB7XG4gICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSByZXZlcnNlO1xuICAgICAgdGhpcy5fc3RhY2sgPSBtYXAuX3Jvb3QgJiYgbWFwSXRlcmF0b3JGcmFtZShtYXAuX3Jvb3QpO1xuICAgIH1cblxuICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICAgIHdoaWxlIChzdGFjaykge1xuICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLm5vZGU7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YWNrLmluZGV4Kys7XG4gICAgICAgIHZhciBtYXhJbmRleDtcbiAgICAgICAgaWYgKG5vZGUuZW50cnkpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIG5vZGUuZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICBtYXhJbmRleCA9IG5vZGUuZW50cmllcy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgbm9kZS5lbnRyaWVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc3ViTm9kZSA9IG5vZGUubm9kZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF07XG4gICAgICAgICAgICBpZiAoc3ViTm9kZSkge1xuICAgICAgICAgICAgICBpZiAoc3ViTm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIHN1Yk5vZGUuZW50cnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSBtYXBJdGVyYXRvckZyYW1lKHN1Yk5vZGUsIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gdGhpcy5fc3RhY2suX19wcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5KSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcEl0ZXJhdG9yRnJhbWUobm9kZSwgcHJldikge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgaW5kZXg6IDAsXG4gICAgICBfX3ByZXY6IHByZXZcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU1hcChzaXplLCByb290LCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlKTtcbiAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgbWFwLl9yb290ID0gcm9vdDtcbiAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBtYXAuX19oYXNoID0gaGFzaDtcbiAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9NQVA7XG4gIGZ1bmN0aW9uIGVtcHR5TWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9NQVAgfHwgKEVNUFRZX01BUCA9IG1ha2VNYXAoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICAgIHZhciBuZXdSb290O1xuICAgIHZhciBuZXdTaXplO1xuICAgIGlmICghbWFwLl9yb290KSB7XG4gICAgICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgICAgbmV3U2l6ZSA9IDE7XG4gICAgICBuZXdSb290ID0gbmV3IEFycmF5TWFwTm9kZShtYXAuX19vd25lcklELCBbW2ssIHZdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWRDaGFuZ2VTaXplID0gTWFrZVJlZihDSEFOR0VfTEVOR1RIKTtcbiAgICAgIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoRElEX0FMVEVSKTtcbiAgICAgIG5ld1Jvb3QgPSB1cGRhdGVOb2RlKG1hcC5fcm9vdCwgbWFwLl9fb3duZXJJRCwgMCwgdW5kZWZpbmVkLCBrLCB2LCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcik7XG4gICAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgICBuZXdTaXplID0gbWFwLnNpemUgKyAoZGlkQ2hhbmdlU2l6ZS52YWx1ZSA/IHYgPT09IE5PVF9TRVQgPyAtMSA6IDEgOiAwKTtcbiAgICB9XG4gICAgaWYgKG1hcC5fX293bmVySUQpIHtcbiAgICAgIG1hcC5zaXplID0gbmV3U2l6ZTtcbiAgICAgIG1hcC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBtYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbWFwLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Um9vdCA/IG1ha2VNYXAobmV3U2l6ZSwgbmV3Um9vdCkgOiBlbXB0eU1hcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS51cGRhdGUob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGVhZk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLmNvbnN0cnVjdG9yID09PSBWYWx1ZU5vZGUgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gSGFzaENvbGxpc2lvbk5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBlbnRyeSkge1xuICAgIGlmIChub2RlLmtleUhhc2ggPT09IGtleUhhc2gpIHtcbiAgICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgW25vZGUuZW50cnksIGVudHJ5XSk7XG4gICAgfVxuXG4gICAgdmFyIGlkeDEgPSAoc2hpZnQgPT09IDAgPyBub2RlLmtleUhhc2ggOiBub2RlLmtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIGlkeDIgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblxuICAgIHZhciBuZXdOb2RlO1xuICAgIHZhciBub2RlcyA9IGlkeDEgPT09IGlkeDIgP1xuICAgICAgW21lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwgZW50cnkpXSA6XG4gICAgICAoKG5ld05vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSksIGlkeDEgPCBpZHgyID8gW25vZGUsIG5ld05vZGVdIDogW25ld05vZGUsIG5vZGVdKTtcblxuICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgKDEgPDwgaWR4MSkgfCAoMSA8PCBpZHgyKSwgbm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSkge1xuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgb3duZXJJRCA9IG5ldyBPd25lcklEKCk7XG4gICAgfVxuICAgIHZhciBub2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGVudHJpZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2lpXTtcbiAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZShvd25lcklELCAwLCB1bmRlZmluZWQsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBjb3VudCwgZXhjbHVkaW5nKSB7XG4gICAgdmFyIGJpdG1hcCA9IDA7XG4gICAgdmFyIHBhY2tlZElJID0gMDtcbiAgICB2YXIgcGFja2VkTm9kZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGlpID0gMCwgYml0ID0gMSwgbGVuID0gbm9kZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKywgYml0IDw8PSAxKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2lpXTtcbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgaWkgIT09IGV4Y2x1ZGluZykge1xuICAgICAgICBiaXRtYXAgfD0gYml0O1xuICAgICAgICBwYWNrZWROb2Rlc1twYWNrZWRJSSsrXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgYml0bWFwLCBwYWNrZWROb2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBpbmNsdWRpbmcsIG5vZGUpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBleHBhbmRlZE5vZGVzID0gbmV3IEFycmF5KFNJWkUpO1xuICAgIGZvciAodmFyIGlpID0gMDsgYml0bWFwICE9PSAwOyBpaSsrLCBiaXRtYXAgPj4+PSAxKSB7XG4gICAgICBleHBhbmRlZE5vZGVzW2lpXSA9IGJpdG1hcCAmIDEgPyBub2Rlc1tjb3VudCsrXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZXhwYW5kZWROb2Rlc1tpbmNsdWRpbmddID0gbm9kZTtcbiAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQgKyAxLCBleHBhbmRlZE5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b01hcFdpdGgobWFwLCBtZXJnZXIsIGl0ZXJhYmxlcykge1xuICAgIHZhciBpdGVycyA9IFtdO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVyYWJsZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVyYWJsZXNbaWldO1xuICAgICAgdmFyIGl0ZXIgPSBLZXllZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgIGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgaXRlciA9IGl0ZXIubWFwKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZyb21KUyh2KX0pO1xuICAgICAgfVxuICAgICAgaXRlcnMucHVzaChpdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKG1hcCwgbWVyZ2VyLCBpdGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwTWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nICYmIGV4aXN0aW5nLm1lcmdlRGVlcCAmJiBpc0l0ZXJhYmxlKHZhbHVlKSA/XG4gICAgICBleGlzdGluZy5tZXJnZURlZXAodmFsdWUpIDpcbiAgICAgIGlzKGV4aXN0aW5nLCB2YWx1ZSkgPyBleGlzdGluZyA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcE1lcmdlcldpdGgobWVyZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV4aXN0aW5nLCB2YWx1ZSwga2V5KSAge1xuICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nLm1lcmdlRGVlcFdpdGggJiYgaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nLm1lcmdlRGVlcFdpdGgobWVyZ2VyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dFZhbHVlID0gbWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSwga2V5KTtcbiAgICAgIHJldHVybiBpcyhleGlzdGluZywgbmV4dFZhbHVlKSA/IGV4aXN0aW5nIDogbmV4dFZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9Db2xsZWN0aW9uV2l0aChjb2xsZWN0aW9uLCBtZXJnZXIsIGl0ZXJzKSB7XG4gICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24oeCApIHtyZXR1cm4geC5zaXplICE9PSAwfSk7XG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IDAgJiYgIWNvbGxlY3Rpb24uX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGNvbGxlY3Rpb24gKSB7XG4gICAgICB2YXIgbWVyZ2VJbnRvTWFwID0gbWVyZ2VyID9cbiAgICAgICAgZnVuY3Rpb24odmFsdWUsIGtleSkgIHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnVwZGF0ZShrZXksIE5PVF9TRVQsIGZ1bmN0aW9uKGV4aXN0aW5nIClcbiAgICAgICAgICAgIHtyZXR1cm4gZXhpc3RpbmcgPT09IE5PVF9TRVQgPyB2YWx1ZSA6IG1lcmdlcihleGlzdGluZywgdmFsdWUsIGtleSl9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlLCBrZXkpICB7XG4gICAgICAgICAgY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgaXRlcnNbaWldLmZvckVhY2gobWVyZ2VJbnRvTWFwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUluRGVlcE1hcChleGlzdGluZywga2V5UGF0aEl0ZXIsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgdmFyIGlzTm90U2V0ID0gZXhpc3RpbmcgPT09IE5PVF9TRVQ7XG4gICAgdmFyIHN0ZXAgPSBrZXlQYXRoSXRlci5uZXh0KCk7XG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSBpc05vdFNldCA/IG5vdFNldFZhbHVlIDogZXhpc3Rpbmc7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB1cGRhdGVyKGV4aXN0aW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlID09PSBleGlzdGluZ1ZhbHVlID8gZXhpc3RpbmcgOiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgaXNOb3RTZXQgfHwgKGV4aXN0aW5nICYmIGV4aXN0aW5nLnNldCksXG4gICAgICAnaW52YWxpZCBrZXlQYXRoJ1xuICAgICk7XG4gICAgdmFyIGtleSA9IHN0ZXAudmFsdWU7XG4gICAgdmFyIG5leHRFeGlzdGluZyA9IGlzTm90U2V0ID8gTk9UX1NFVCA6IGV4aXN0aW5nLmdldChrZXksIE5PVF9TRVQpO1xuICAgIHZhciBuZXh0VXBkYXRlZCA9IHVwZGF0ZUluRGVlcE1hcChcbiAgICAgIG5leHRFeGlzdGluZyxcbiAgICAgIGtleVBhdGhJdGVyLFxuICAgICAgbm90U2V0VmFsdWUsXG4gICAgICB1cGRhdGVyXG4gICAgKTtcbiAgICByZXR1cm4gbmV4dFVwZGF0ZWQgPT09IG5leHRFeGlzdGluZyA/IGV4aXN0aW5nIDpcbiAgICAgIG5leHRVcGRhdGVkID09PSBOT1RfU0VUID8gZXhpc3RpbmcucmVtb3ZlKGtleSkgOlxuICAgICAgKGlzTm90U2V0ID8gZW1wdHlNYXAoKSA6IGV4aXN0aW5nKS5zZXQoa2V5LCBuZXh0VXBkYXRlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BDb3VudCh4KSB7XG4gICAgeCA9IHggLSAoKHggPj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgICB4ID0gKHggJiAweDMzMzMzMzMzKSArICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICAgIHggPSAoeCArICh4ID4+IDQpKSAmIDB4MGYwZjBmMGY7XG4gICAgeCA9IHggKyAoeCA+PiA4KTtcbiAgICB4ID0geCArICh4ID4+IDE2KTtcbiAgICByZXR1cm4geCAmIDB4N2Y7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3QXJyYXkgPSBjYW5FZGl0ID8gYXJyYXkgOiBhcnJDb3B5KGFycmF5KTtcbiAgICBuZXdBcnJheVtpZHhdID0gdmFsO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGljZUluKGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggKyAxO1xuICAgIGlmIChjYW5FZGl0ICYmIGlkeCArIDEgPT09IG5ld0xlbikge1xuICAgICAgYXJyYXlbaWR4XSA9IHZhbDtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgdmFyIGFmdGVyID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgICBuZXdBcnJheVtpaV0gPSB2YWw7XG4gICAgICAgIGFmdGVyID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaWNlT3V0KGFycmF5LCBpZHgsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICBpZiAoY2FuRWRpdCAmJiBpZHggPT09IG5ld0xlbikge1xuICAgICAgYXJyYXkucG9wKCk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgIHZhciBhZnRlciA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgICAgYWZ0ZXIgPSAxO1xuICAgICAgfVxuICAgICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIHZhciBNQVhfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcbiAgdmFyIE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFID0gU0laRSAvIDI7XG4gIHZhciBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xuXG4gIGNyZWF0ZUNsYXNzKExpc3QsIEluZGV4ZWRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBMaXN0KHZhbHVlKSB7XG4gICAgICB2YXIgZW1wdHkgPSBlbXB0eUxpc3QoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xpc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyID0gSW5kZXhlZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgIHZhciBzaXplID0gaXRlci5zaXplO1xuICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgfVxuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSk7XG4gICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IFNJWkUpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VMaXN0KDAsIHNpemUsIFNISUZULCBudWxsLCBuZXcgVk5vZGUoaXRlci50b0FycmF5KCkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGxpc3QgKSB7XG4gICAgICAgIGxpc3Quc2V0U2l6ZShzaXplKTtcbiAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpICB7cmV0dXJuIGxpc3Quc2V0KGksIHYpfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBMaXN0Lm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ0xpc3QgWycsICddJyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgIGluZGV4ICs9IHRoaXMuX29yaWdpbjtcbiAgICAgICAgdmFyIG5vZGUgPSBsaXN0Tm9kZUZvcih0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUuYXJyYXlbaW5kZXggJiBNQVNLXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUxpc3QodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXMoaW5kZXgpID8gdGhpcyA6XG4gICAgICAgIGluZGV4ID09PSAwID8gdGhpcy5zaGlmdCgpIDpcbiAgICAgICAgaW5kZXggPT09IHRoaXMuc2l6ZSAtIDEgPyB0aGlzLnBvcCgpIDpcbiAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9vcmlnaW4gPSB0aGlzLl9jYXBhY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuX2xldmVsID0gU0hJRlQ7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGxpc3QgKSB7XG4gICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgb2xkU2l6ZSArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KG9sZFNpemUgKyBpaSwgdmFsdWVzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGxpc3QgKSB7XG4gICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgLXZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAxKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcbiAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCB1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIG1lcmdlciwgaXRlcnMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5tZXJnZURlZXAgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcbiAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCBkZWVwTWVyZ2VyLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTGlzdFdpdGgodGhpcywgZGVlcE1lcmdlcldpdGgobWVyZ2VyKSwgaXRlcnMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMCwgc2l6ZSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSxcbiAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpXG4gICAgICApO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBET05FID9cbiAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpbmRleCsrLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoKHZhbHVlID0gdmFsdWVzKCkpICE9PSBET05FKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgaW5kZXgrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VMaXN0KHRoaXMuX29yaWdpbiwgdGhpcy5fY2FwYWNpdHksIHRoaXMuX2xldmVsLCB0aGlzLl9yb290LCB0aGlzLl90YWlsLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzTGlzdChtYXliZUxpc3QpIHtcbiAgICByZXR1cm4gISEobWF5YmVMaXN0ICYmIG1heWJlTGlzdFtJU19MSVNUX1NFTlRJTkVMXSk7XG4gIH1cblxuICBMaXN0LmlzTGlzdCA9IGlzTGlzdDtcblxuICB2YXIgSVNfTElTVF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0xJU1RfX0BAJztcblxuICB2YXIgTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuICBMaXN0UHJvdG90eXBlW0lTX0xJU1RfU0VOVElORUxdID0gdHJ1ZTtcbiAgTGlzdFByb3RvdHlwZVtERUxFVEVdID0gTGlzdFByb3RvdHlwZS5yZW1vdmU7XG4gIExpc3RQcm90b3R5cGUuc2V0SW4gPSBNYXBQcm90b3R5cGUuc2V0SW47XG4gIExpc3RQcm90b3R5cGUuZGVsZXRlSW4gPVxuICBMaXN0UHJvdG90eXBlLnJlbW92ZUluID0gTWFwUHJvdG90eXBlLnJlbW92ZUluO1xuICBMaXN0UHJvdG90eXBlLnVwZGF0ZSA9IE1hcFByb3RvdHlwZS51cGRhdGU7XG4gIExpc3RQcm90b3R5cGUudXBkYXRlSW4gPSBNYXBQcm90b3R5cGUudXBkYXRlSW47XG4gIExpc3RQcm90b3R5cGUubWVyZ2VJbiA9IE1hcFByb3RvdHlwZS5tZXJnZUluO1xuICBMaXN0UHJvdG90eXBlLm1lcmdlRGVlcEluID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcEluO1xuICBMaXN0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcbiAgTGlzdFByb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuICBMaXN0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuICBMaXN0UHJvdG90eXBlLndhc0FsdGVyZWQgPSBNYXBQcm90b3R5cGUud2FzQWx0ZXJlZDtcblxuXG5cbiAgICBmdW5jdGlvbiBWTm9kZShhcnJheSwgb3duZXJJRCkge1xuICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBzZWVtcyBsaWtlIHRoZXNlIG1ldGhvZHMgYXJlIHZlcnkgc2ltaWxhclxuXG4gICAgVk5vZGUucHJvdG90eXBlLnJlbW92ZUJlZm9yZSA9IGZ1bmN0aW9uKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSBsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG9yaWdpbkluZGV4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgaWYgKG9yaWdpbkluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVk5vZGUoW10sIG93bmVySUQpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbW92aW5nRmlyc3QgPSBvcmlnaW5JbmRleCA9PT0gMDtcbiAgICAgIHZhciBuZXdDaGlsZDtcbiAgICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtvcmlnaW5JbmRleF07XG4gICAgICAgIG5ld0NoaWxkID0gb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQmVmb3JlKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICAgICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiByZW1vdmluZ0ZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmluZ0ZpcnN0ICYmICFuZXdDaGlsZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gICAgICBpZiAoIXJlbW92aW5nRmlyc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG9yaWdpbkluZGV4OyBpaSsrKSB7XG4gICAgICAgICAgZWRpdGFibGUuYXJyYXlbaWldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgZWRpdGFibGUuYXJyYXlbb3JpZ2luSW5kZXhdID0gbmV3Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdGFibGU7XG4gICAgfTtcblxuICAgIFZOb2RlLnByb3RvdHlwZS5yZW1vdmVBZnRlciA9IGZ1bmN0aW9uKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSAobGV2ZWwgPyAxIDw8IGxldmVsIDogMCkgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZUluZGV4ID0gKChpbmRleCAtIDEpID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgaWYgKHNpemVJbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0NoaWxkO1xuICAgICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W3NpemVJbmRleF07XG4gICAgICAgIG5ld0NoaWxkID0gb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQWZ0ZXIob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHNpemVJbmRleCA9PT0gdGhpcy5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICAgIGVkaXRhYmxlLmFycmF5LnNwbGljZShzaXplSW5kZXggKyAxKTtcbiAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICBlZGl0YWJsZS5hcnJheVtzaXplSW5kZXhdID0gbmV3Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdGFibGU7XG4gICAgfTtcblxuXG5cbiAgdmFyIERPTkUgPSB7fTtcblxuICBmdW5jdGlvbiBpdGVyYXRlTGlzdChsaXN0LCByZXZlcnNlKSB7XG4gICAgdmFyIGxlZnQgPSBsaXN0Ll9vcmlnaW47XG4gICAgdmFyIHJpZ2h0ID0gbGlzdC5fY2FwYWNpdHk7XG4gICAgdmFyIHRhaWxQb3MgPSBnZXRUYWlsT2Zmc2V0KHJpZ2h0KTtcbiAgICB2YXIgdGFpbCA9IGxpc3QuX3RhaWw7XG5cbiAgICByZXR1cm4gaXRlcmF0ZU5vZGVPckxlYWYobGlzdC5fcm9vdCwgbGlzdC5fbGV2ZWwsIDApO1xuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGVPckxlYWYobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGxldmVsID09PSAwID9cbiAgICAgICAgaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSA6XG4gICAgICAgIGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIGFycmF5ID0gb2Zmc2V0ID09PSB0YWlsUG9zID8gdGFpbCAmJiB0YWlsLmFycmF5IDogbm9kZSAmJiBub2RlLmFycmF5O1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IGxlZnQgLSBvZmZzZXQ7XG4gICAgICB2YXIgdG8gPSByaWdodCAtIG9mZnNldDtcbiAgICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgICAgdG8gPSBTSVpFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXlbaWR4XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgdmFyIHZhbHVlcztcbiAgICAgIHZhciBhcnJheSA9IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiAobGVmdCAtIG9mZnNldCkgPj4gbGV2ZWw7XG4gICAgICB2YXIgdG8gPSAoKHJpZ2h0IC0gb2Zmc2V0KSA+PiBsZXZlbCkgKyAxO1xuICAgICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgICB0byA9IFNJWkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSAge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IERPTkUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICAgIHZhbHVlcyA9IGl0ZXJhdGVOb2RlT3JMZWFmKFxuICAgICAgICAgICAgYXJyYXkgJiYgYXJyYXlbaWR4XSwgbGV2ZWwgLSBTSElGVCwgb2Zmc2V0ICsgKGlkeCA8PCBsZXZlbClcbiAgICAgICAgICApO1xuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUxpc3Qob3JpZ2luLCBjYXBhY2l0eSwgbGV2ZWwsIHJvb3QsIHRhaWwsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbGlzdCA9IE9iamVjdC5jcmVhdGUoTGlzdFByb3RvdHlwZSk7XG4gICAgbGlzdC5zaXplID0gY2FwYWNpdHkgLSBvcmlnaW47XG4gICAgbGlzdC5fb3JpZ2luID0gb3JpZ2luO1xuICAgIGxpc3QuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgbGlzdC5fbGV2ZWwgPSBsZXZlbDtcbiAgICBsaXN0Ll9yb290ID0gcm9vdDtcbiAgICBsaXN0Ll90YWlsID0gdGFpbDtcbiAgICBsaXN0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbGlzdC5fX2hhc2ggPSBoYXNoO1xuICAgIGxpc3QuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICB2YXIgRU1QVFlfTElTVDtcbiAgZnVuY3Rpb24gZW1wdHlMaXN0KCkge1xuICAgIHJldHVybiBFTVBUWV9MSVNUIHx8IChFTVBUWV9MSVNUID0gbWFrZUxpc3QoMCwgMCwgU0hJRlQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpc3QobGlzdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgobGlzdCwgaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4ICE9PSBpbmRleCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID49IGxpc3Quc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBsaXN0LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgaW5kZXggPCAwID9cbiAgICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIGluZGV4KS5zZXQoMCwgdmFsdWUpIDpcbiAgICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIGluZGV4ICsgMSkuc2V0KGluZGV4LCB2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGluZGV4ICs9IGxpc3QuX29yaWdpbjtcblxuICAgIHZhciBuZXdUYWlsID0gbGlzdC5fdGFpbDtcbiAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG4gICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZihESURfQUxURVIpO1xuICAgIGlmIChpbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgICAgbmV3VGFpbCA9IHVwZGF0ZVZOb2RlKG5ld1RhaWwsIGxpc3QuX19vd25lcklELCAwLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Um9vdCA9IHVwZGF0ZVZOb2RlKG5ld1Jvb3QsIGxpc3QuX19vd25lcklELCBsaXN0Ll9sZXZlbCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gICAgfVxuXG4gICAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KGxpc3QuX29yaWdpbiwgbGlzdC5fY2FwYWNpdHksIGxpc3QuX2xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZOb2RlKG5vZGUsIG93bmVySUQsIGxldmVsLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKSB7XG4gICAgdmFyIGlkeCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICB2YXIgbm9kZUhhcyA9IG5vZGUgJiYgaWR4IDwgbm9kZS5hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFub2RlSGFzICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBuZXdOb2RlO1xuXG4gICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgdmFyIGxvd2VyTm9kZSA9IG5vZGUgJiYgbm9kZS5hcnJheVtpZHhdO1xuICAgICAgdmFyIG5ld0xvd2VyTm9kZSA9IHVwZGF0ZVZOb2RlKGxvd2VyTm9kZSwgb3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gICAgICBpZiAobmV3TG93ZXJOb2RlID09PSBsb3dlck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IG5ld0xvd2VyTm9kZTtcbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cblxuICAgIGlmIChub2RlSGFzICYmIG5vZGUuYXJyYXlbaWR4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIFNldFJlZihkaWRBbHRlcik7XG5cbiAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpZHggPT09IG5ld05vZGUuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgbmV3Tm9kZS5hcnJheS5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgJiYgbm9kZSAmJiBvd25lcklEID09PSBub2RlLm93bmVySUQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGUgPyBub2RlLmFycmF5LnNsaWNlKCkgOiBbXSwgb3duZXJJRCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0Tm9kZUZvcihsaXN0LCByYXdJbmRleCkge1xuICAgIGlmIChyYXdJbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgICAgcmV0dXJuIGxpc3QuX3RhaWw7XG4gICAgfVxuICAgIGlmIChyYXdJbmRleCA8IDEgPDwgKGxpc3QuX2xldmVsICsgU0hJRlQpKSB7XG4gICAgICB2YXIgbm9kZSA9IGxpc3QuX3Jvb3Q7XG4gICAgICB2YXIgbGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICAgIHdoaWxlIChub2RlICYmIGxldmVsID4gMCkge1xuICAgICAgICBub2RlID0gbm9kZS5hcnJheVsocmF3SW5kZXggPj4+IGxldmVsKSAmIE1BU0tdO1xuICAgICAgICBsZXZlbCAtPSBTSElGVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExpc3RCb3VuZHMobGlzdCwgYmVnaW4sIGVuZCkge1xuICAgIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gICAgaWYgKGJlZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJlZ2luID0gYmVnaW4gfCAwO1xuICAgIH1cbiAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IGVuZCB8IDA7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGxpc3QuX19vd25lcklEIHx8IG5ldyBPd25lcklEKCk7XG4gICAgdmFyIG9sZE9yaWdpbiA9IGxpc3QuX29yaWdpbjtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgICB2YXIgbmV3T3JpZ2luID0gb2xkT3JpZ2luICsgYmVnaW47XG4gICAgdmFyIG5ld0NhcGFjaXR5ID0gZW5kID09PSB1bmRlZmluZWQgPyBvbGRDYXBhY2l0eSA6IGVuZCA8IDAgPyBvbGRDYXBhY2l0eSArIGVuZCA6IG9sZE9yaWdpbiArIGVuZDtcbiAgICBpZiAobmV3T3JpZ2luID09PSBvbGRPcmlnaW4gJiYgbmV3Q2FwYWNpdHkgPT09IG9sZENhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvLyBJZiBpdCdzIGdvaW5nIHRvIGVuZCBhZnRlciBpdCBzdGFydHMsIGl0J3MgZW1wdHkuXG4gICAgaWYgKG5ld09yaWdpbiA+PSBuZXdDYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIGxpc3QuY2xlYXIoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG5cbiAgICAvLyBOZXcgb3JpZ2luIG1pZ2h0IG5lZWQgY3JlYXRpbmcgYSBoaWdoZXIgcm9vdC5cbiAgICB2YXIgb2Zmc2V0U2hpZnQgPSAwO1xuICAgIHdoaWxlIChuZXdPcmlnaW4gKyBvZmZzZXRTaGlmdCA8IDApIHtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUobmV3Um9vdCAmJiBuZXdSb290LmFycmF5Lmxlbmd0aCA/IFt1bmRlZmluZWQsIG5ld1Jvb3RdIDogW10sIG93bmVyKTtcbiAgICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgICAgb2Zmc2V0U2hpZnQgKz0gMSA8PCBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgICBuZXdPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBvbGRPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBuZXdDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG9sZENhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICAgIH1cblxuICAgIHZhciBvbGRUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChvbGRDYXBhY2l0eSk7XG4gICAgdmFyIG5ld1RhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG5ld0NhcGFjaXR5KTtcblxuICAgIC8vIE5ldyBzaXplIG1pZ2h0IG5lZWQgY3JlYXRpbmcgYSBoaWdoZXIgcm9vdC5cbiAgICB3aGlsZSAobmV3VGFpbE9mZnNldCA+PSAxIDw8IChuZXdMZXZlbCArIFNISUZUKSkge1xuICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sIG93bmVyKTtcbiAgICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgIH1cblxuICAgIC8vIExvY2F0ZSBvciBjcmVhdGUgdGhlIG5ldyB0YWlsLlxuICAgIHZhciBvbGRUYWlsID0gbGlzdC5fdGFpbDtcbiAgICB2YXIgbmV3VGFpbCA9IG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0ID9cbiAgICAgIGxpc3ROb2RlRm9yKGxpc3QsIG5ld0NhcGFjaXR5IC0gMSkgOlxuICAgICAgbmV3VGFpbE9mZnNldCA+IG9sZFRhaWxPZmZzZXQgPyBuZXcgVk5vZGUoW10sIG93bmVyKSA6IG9sZFRhaWw7XG5cbiAgICAvLyBNZXJnZSBUYWlsIGludG8gdHJlZS5cbiAgICBpZiAob2xkVGFpbCAmJiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCAmJiBuZXdPcmlnaW4gPCBvbGRDYXBhY2l0eSAmJiBvbGRUYWlsLmFycmF5Lmxlbmd0aCkge1xuICAgICAgbmV3Um9vdCA9IGVkaXRhYmxlVk5vZGUobmV3Um9vdCwgb3duZXIpO1xuICAgICAgdmFyIG5vZGUgPSBuZXdSb290O1xuICAgICAgZm9yICh2YXIgbGV2ZWwgPSBuZXdMZXZlbDsgbGV2ZWwgPiBTSElGVDsgbGV2ZWwgLT0gU0hJRlQpIHtcbiAgICAgICAgdmFyIGlkeCA9IChvbGRUYWlsT2Zmc2V0ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgICBub2RlID0gbm9kZS5hcnJheVtpZHhdID0gZWRpdGFibGVWTm9kZShub2RlLmFycmF5W2lkeF0sIG93bmVyKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYXJyYXlbKG9sZFRhaWxPZmZzZXQgPj4+IFNISUZUKSAmIE1BU0tdID0gb2xkVGFpbDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2l6ZSBoYXMgYmVlbiByZWR1Y2VkLCB0aGVyZSdzIGEgY2hhbmNlIHRoZSB0YWlsIG5lZWRzIHRvIGJlIHRyaW1tZWQuXG4gICAgaWYgKG5ld0NhcGFjaXR5IDwgb2xkQ2FwYWNpdHkpIHtcbiAgICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQWZ0ZXIob3duZXIsIDAsIG5ld0NhcGFjaXR5KTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV3IG9yaWdpbiBpcyB3aXRoaW4gdGhlIHRhaWwsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSByb290LlxuICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3VGFpbE9mZnNldCkge1xuICAgICAgbmV3T3JpZ2luIC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgICBuZXdDYXBhY2l0eSAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICAgIG5ld1Jvb3QgPSBudWxsO1xuICAgICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVCZWZvcmUob3duZXIsIDAsIG5ld09yaWdpbik7XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSByb290IGhhcyBiZWVuIHRyaW1tZWQsIGdhcmJhZ2UgY29sbGVjdC5cbiAgICB9IGVsc2UgaWYgKG5ld09yaWdpbiA+IG9sZE9yaWdpbiB8fCBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgb2Zmc2V0U2hpZnQgPSAwO1xuXG4gICAgICAvLyBJZGVudGlmeSB0aGUgbmV3IHRvcCByb290IG5vZGUgb2YgdGhlIHN1YnRyZWUgb2YgdGhlIG9sZCByb290LlxuICAgICAgd2hpbGUgKG5ld1Jvb3QpIHtcbiAgICAgICAgdmFyIGJlZ2luSW5kZXggPSAobmV3T3JpZ2luID4+PiBuZXdMZXZlbCkgJiBNQVNLO1xuICAgICAgICBpZiAoYmVnaW5JbmRleCAhPT0gKG5ld1RhaWxPZmZzZXQgPj4+IG5ld0xldmVsKSAmIE1BU0spIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVnaW5JbmRleCkge1xuICAgICAgICAgIG9mZnNldFNoaWZ0ICs9ICgxIDw8IG5ld0xldmVsKSAqIGJlZ2luSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgbmV3TGV2ZWwgLT0gU0hJRlQ7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LmFycmF5W2JlZ2luSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmltIHRoZSBuZXcgc2lkZXMgb2YgdGhlIG5ldyByb290LlxuICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3T3JpZ2luID4gb2xkT3JpZ2luKSB7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LnJlbW92ZUJlZm9yZShvd25lciwgbmV3TGV2ZWwsIG5ld09yaWdpbiAtIG9mZnNldFNoaWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdSb290ICYmIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LnJlbW92ZUFmdGVyKG93bmVyLCBuZXdMZXZlbCwgbmV3VGFpbE9mZnNldCAtIG9mZnNldFNoaWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgICBuZXdPcmlnaW4gLT0gb2Zmc2V0U2hpZnQ7XG4gICAgICAgIG5ld0NhcGFjaXR5IC09IG9mZnNldFNoaWZ0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgICAgbGlzdC5zaXplID0gbmV3Q2FwYWNpdHkgLSBuZXdPcmlnaW47XG4gICAgICBsaXN0Ll9vcmlnaW4gPSBuZXdPcmlnaW47XG4gICAgICBsaXN0Ll9jYXBhY2l0eSA9IG5ld0NhcGFjaXR5O1xuICAgICAgbGlzdC5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUxpc3QobmV3T3JpZ2luLCBuZXdDYXBhY2l0eSwgbmV3TGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvTGlzdFdpdGgobGlzdCwgbWVyZ2VyLCBpdGVyYWJsZXMpIHtcbiAgICB2YXIgaXRlcnMgPSBbXTtcbiAgICB2YXIgbWF4U2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJhYmxlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhYmxlc1tpaV07XG4gICAgICB2YXIgaXRlciA9IEluZGV4ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICBpZiAoaXRlci5zaXplID4gbWF4U2l6ZSkge1xuICAgICAgICBtYXhTaXplID0gaXRlci5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICBpdGVyID0gaXRlci5tYXAoZnVuY3Rpb24odiApIHtyZXR1cm4gZnJvbUpTKHYpfSk7XG4gICAgICB9XG4gICAgICBpdGVycy5wdXNoKGl0ZXIpO1xuICAgIH1cbiAgICBpZiAobWF4U2l6ZSA+IGxpc3Quc2l6ZSkge1xuICAgICAgbGlzdCA9IGxpc3Quc2V0U2l6ZShtYXhTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKGxpc3QsIG1lcmdlciwgaXRlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFpbE9mZnNldChzaXplKSB7XG4gICAgcmV0dXJuIHNpemUgPCBTSVpFID8gMCA6ICgoKHNpemUgLSAxKSA+Pj4gU0hJRlQpIDw8IFNISUZUKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE9yZGVyZWRNYXAsIE1hcCk7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gT3JkZXJlZE1hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eU9yZGVyZWRNYXAoKSA6XG4gICAgICAgIGlzT3JkZXJlZE1hcCh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5T3JkZXJlZE1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwLnNldChrLCB2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBPcmRlcmVkTWFwLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRNYXAgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbWFwLmdldChrKTtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fbGlzdC5nZXQoaW5kZXgpWzFdIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaywgdikge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgdik7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKSB8fCB0aGlzLl9saXN0Lndhc0FsdGVyZWQoKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9saXN0Ll9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24oZW50cnkgKSB7cmV0dXJuIGVudHJ5ICYmIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQwKX0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGlzdC5mcm9tRW50cnlTZXEoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgdmFyIG5ld0xpc3QgPSB0aGlzLl9saXN0Ll9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkTWFwKG1heWJlT3JkZXJlZE1hcCkge1xuICAgIHJldHVybiBpc01hcChtYXliZU9yZGVyZWRNYXApICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRNYXApO1xuICB9XG5cbiAgT3JkZXJlZE1hcC5pc09yZGVyZWRNYXAgPSBpc09yZGVyZWRNYXA7XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuICBPcmRlcmVkTWFwLnByb3RvdHlwZVtERUxFVEVdID0gT3JkZXJlZE1hcC5wcm90b3R5cGUucmVtb3ZlO1xuXG5cblxuICBmdW5jdGlvbiBtYWtlT3JkZXJlZE1hcChtYXAsIGxpc3QsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgb21hcCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZE1hcC5wcm90b3R5cGUpO1xuICAgIG9tYXAuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBvbWFwLl9tYXAgPSBtYXA7XG4gICAgb21hcC5fbGlzdCA9IGxpc3Q7XG4gICAgb21hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG9tYXAuX19oYXNoID0gaGFzaDtcbiAgICByZXR1cm4gb21hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9PUkRFUkVEX01BUDtcbiAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkTWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9PUkRFUkVEX01BUCB8fCAoRU1QVFlfT1JERVJFRF9NQVAgPSBtYWtlT3JkZXJlZE1hcChlbXB0eU1hcCgpLCBlbXB0eUxpc3QoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlT3JkZXJlZE1hcChvbWFwLCBrLCB2KSB7XG4gICAgdmFyIG1hcCA9IG9tYXAuX21hcDtcbiAgICB2YXIgbGlzdCA9IG9tYXAuX2xpc3Q7XG4gICAgdmFyIGkgPSBtYXAuZ2V0KGspO1xuICAgIHZhciBoYXMgPSBpICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIG5ld01hcDtcbiAgICB2YXIgbmV3TGlzdDtcbiAgICBpZiAodiA9PT0gTk9UX1NFVCkgeyAvLyByZW1vdmVkXG4gICAgICBpZiAoIWhhcykge1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0LnNpemUgPj0gU0laRSAmJiBsaXN0LnNpemUgPj0gbWFwLnNpemUgKiAyKSB7XG4gICAgICAgIG5ld0xpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbihlbnRyeSwgaWR4KSAge3JldHVybiBlbnRyeSAhPT0gdW5kZWZpbmVkICYmIGkgIT09IGlkeH0pO1xuICAgICAgICBuZXdNYXAgPSBuZXdMaXN0LnRvS2V5ZWRTZXEoKS5tYXAoZnVuY3Rpb24oZW50cnkgKSB7cmV0dXJuIGVudHJ5WzBdfSkuZmxpcCgpLnRvTWFwKCk7XG4gICAgICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgICAgIG5ld01hcC5fX293bmVySUQgPSBuZXdMaXN0Ll9fb3duZXJJRCA9IG9tYXAuX19vd25lcklEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdNYXAgPSBtYXAucmVtb3ZlKGspO1xuICAgICAgICBuZXdMaXN0ID0gaSA9PT0gbGlzdC5zaXplIC0gMSA/IGxpc3QucG9wKCkgOiBsaXN0LnNldChpLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKSB7XG4gICAgICAgIGlmICh2ID09PSBsaXN0LmdldChpKVsxXSkge1xuICAgICAgICAgIHJldHVybiBvbWFwO1xuICAgICAgICB9XG4gICAgICAgIG5ld01hcCA9IG1hcDtcbiAgICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGksIFtrLCB2XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdNYXAgPSBtYXAuc2V0KGssIGxpc3Quc2l6ZSk7XG4gICAgICAgIG5ld0xpc3QgPSBsaXN0LnNldChsaXN0LnNpemUsIFtrLCB2XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgb21hcC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgICBvbWFwLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgIG9tYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVG9LZXllZFNlcXVlbmNlLCBLZXllZFNlcSk7XG4gICAgZnVuY3Rpb24gVG9LZXllZFNlcXVlbmNlKGluZGV4ZWQsIHVzZUtleXMpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpbmRleGVkO1xuICAgICAgdGhpcy5fdXNlS2V5cyA9IHVzZUtleXM7XG4gICAgICB0aGlzLnNpemUgPSBpbmRleGVkLnNpemU7XG4gICAgfVxuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5nZXQoa2V5LCBub3RTZXRWYWx1ZSk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5oYXMoa2V5KTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS52YWx1ZVNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudmFsdWVTZXEoKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpO1xuICAgICAgaWYgKCF0aGlzLl91c2VLZXlzKSB7XG4gICAgICAgIHJldmVyc2VkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbigpICB7cmV0dXJuIHRoaXMkMC5faXRlci50b1NlcSgpLnJldmVyc2UoKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgICBtYXBwZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gdGhpcyQwLl9pdGVyLnRvU2VxKCkubWFwKG1hcHBlciwgY29udGV4dCl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaWk7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoXG4gICAgICAgIHRoaXMuX3VzZUtleXMgP1xuICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZuKHYsIGssIHRoaXMkMCl9IDpcbiAgICAgICAgICAoKGlpID0gcmV2ZXJzZSA/IHJlc29sdmVTaXplKHRoaXMpIDogMCksXG4gICAgICAgICAgICBmdW5jdGlvbih2ICkge3JldHVybiBmbih2LCByZXZlcnNlID8gLS1paSA6IGlpKyssIHRoaXMkMCl9KSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaWkgPSByZXZlcnNlID8gcmVzb2x2ZVNpemUodGhpcykgOiAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gLS1paSA6IGlpKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuXG4gIGNyZWF0ZUNsYXNzKFRvSW5kZXhlZFNlcXVlbmNlLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBUb0luZGV4ZWRTZXF1ZW5jZShpdGVyKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICB9XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuaW5jbHVkZXModmFsdWUpO1xuICAgIH07XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbih2ICkge3JldHVybiBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMCl9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApXG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhUb1NldFNlcXVlbmNlLCBTZXRTZXEpO1xuICAgIGZ1bmN0aW9uIFRvU2V0U2VxdWVuY2UoaXRlcikge1xuICAgICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gICAgfVxuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZuKHYsIHYsIHRoaXMkMCl9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIHN0ZXAudmFsdWUsIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoRnJvbUVudHJpZXNTZXF1ZW5jZSwgS2V5ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIEZyb21FbnRyaWVzU2VxdWVuY2UoZW50cmllcykge1xuICAgICAgdGhpcy5faXRlciA9IGVudHJpZXM7XG4gICAgICB0aGlzLnNpemUgPSBlbnRyaWVzLnNpemU7XG4gICAgfVxuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuZW50cnlTZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLnRvU2VxKCk7XG4gICAgfTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24oZW50cnkgKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgICAgLy8gaW4gdGhlIHBhcmVudCBpdGVyYXRpb24uXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICAgIHZhciBpbmRleGVkSXRlcmFibGUgPSBpc0l0ZXJhYmxlKGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgICBpbmRleGVkSXRlcmFibGUgPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgdGhpcyQwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhlZEl0ZXJhYmxlID0gaXNJdGVyYWJsZShlbnRyeSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgICBzdGVwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgICBjYWNoZVJlc3VsdFRocm91Z2g7XG5cblxuICBmdW5jdGlvbiBmbGlwRmFjdG9yeShpdGVyYWJsZSkge1xuICAgIHZhciBmbGlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGZsaXBTZXF1ZW5jZS5faXRlciA9IGl0ZXJhYmxlO1xuICAgIGZsaXBTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZTtcbiAgICBmbGlwU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGV9O1xuICAgIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBpdGVyYWJsZS5yZXZlcnNlLmFwcGx5KHRoaXMpOyAvLyBzdXBlci5yZXZlcnNlKClcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGUucmV2ZXJzZSgpfTtcbiAgICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICAgIH07XG4gICAgZmxpcFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uKGtleSApIHtyZXR1cm4gaXRlcmFibGUuaW5jbHVkZXMoa2V5KX07XG4gICAgZmxpcFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5oYXMoa2V5KX07XG4gICAgZmxpcFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge3JldHVybiBmbihrLCB2LCB0aGlzJDApICE9PSBmYWxzZX0sIHJldmVyc2UpO1xuICAgIH1cbiAgICBmbGlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGsgPSBzdGVwLnZhbHVlWzBdO1xuICAgICAgICAgICAgc3RlcC52YWx1ZVswXSA9IHN0ZXAudmFsdWVbMV07XG4gICAgICAgICAgICBzdGVwLnZhbHVlWzFdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0b3IoXG4gICAgICAgIHR5cGUgPT09IElURVJBVEVfVkFMVUVTID8gSVRFUkFURV9LRVlTIDogSVRFUkFURV9WQUxVRVMsXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1hcEZhY3RvcnkoaXRlcmFibGUsIG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgbWFwcGVkU2VxdWVuY2Uuc2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG4gICAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5oYXMoa2V5KX07XG4gICAgbWFwcGVkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkgIHtcbiAgICAgIHZhciB2ID0gaXRlcmFibGUuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICByZXR1cm4gdiA9PT0gTk9UX1NFVCA/XG4gICAgICAgIG5vdFNldFZhbHVlIDpcbiAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgdiwga2V5LCBpdGVyYWJsZSk7XG4gICAgfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24odiwgaywgYykgIHtyZXR1cm4gZm4obWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgYyksIGssIHRoaXMkMCkgIT09IGZhbHNlfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9XG4gICAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGtleSwgaXRlcmFibGUpLFxuICAgICAgICAgIHN0ZXBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJldmVyc2VGYWN0b3J5KGl0ZXJhYmxlLCB1c2VLZXlzKSB7XG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX2l0ZXIgPSBpdGVyYWJsZTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLnNpemUgPSBpdGVyYWJsZS5zaXplO1xuICAgIHJldmVyc2VkU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGV9O1xuICAgIGlmIChpdGVyYWJsZS5mbGlwKSB7XG4gICAgICByZXZlcnNlZFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbGlwU2VxdWVuY2UgPSBmbGlwRmFjdG9yeShpdGVyYWJsZSk7XG4gICAgICAgIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZS5mbGlwKCl9O1xuICAgICAgICByZXR1cm4gZmxpcFNlcXVlbmNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSBcbiAgICAgIHtyZXR1cm4gaXRlcmFibGUuZ2V0KHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSwgbm90U2V0VmFsdWUpfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uKGtleSApXG4gICAgICB7cmV0dXJuIGl0ZXJhYmxlLmhhcyh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXkpfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGl0ZXJhYmxlLmluY2x1ZGVzKHZhbHVlKX07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge3JldHVybiBmbih2LCBrLCB0aGlzJDApfSwgIXJldmVyc2UpO1xuICAgIH07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yID1cbiAgICAgIGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpICB7cmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgIXJldmVyc2UpfTtcbiAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZmlsdGVyRmFjdG9yeShpdGVyYWJsZSwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIGZpbHRlclNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBpZiAodXNlS2V5cykge1xuICAgICAgZmlsdGVyU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge1xuICAgICAgICB2YXIgdiA9IGl0ZXJhYmxlLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgICByZXR1cm4gdiAhPT0gTk9UX1NFVCAmJiAhIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgaXRlcmFibGUpO1xuICAgICAgfTtcbiAgICAgIGZpbHRlclNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpICB7XG4gICAgICAgIHZhciB2ID0gaXRlcmFibGUuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgaXRlcmFibGUpID9cbiAgICAgICAgICB2IDogbm90U2V0VmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbMV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIGl0ZXJhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgdXNlS2V5cyA/IGtleSA6IGl0ZXJhdGlvbnMrKywgdmFsdWUsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY291bnRCeUZhY3RvcnkoaXRlcmFibGUsIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgZ3JvdXBzID0gTWFwKCkuYXNNdXRhYmxlKCk7XG4gICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICBncm91cHMudXBkYXRlKFxuICAgICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgaXRlcmFibGUpLFxuICAgICAgICAwLFxuICAgICAgICBmdW5jdGlvbihhICkge3JldHVybiBhICsgMX1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5hc0ltbXV0YWJsZSgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBncm91cEJ5RmFjdG9yeShpdGVyYWJsZSwgZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHZhciBpc0tleWVkSXRlciA9IGlzS2V5ZWQoaXRlcmFibGUpO1xuICAgIHZhciBncm91cHMgPSAoaXNPcmRlcmVkKGl0ZXJhYmxlKSA/IE9yZGVyZWRNYXAoKSA6IE1hcCgpKS5hc011dGFibGUoKTtcbiAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgIGdyb3Vwcy51cGRhdGUoXG4gICAgICAgIGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBpdGVyYWJsZSksXG4gICAgICAgIGZ1bmN0aW9uKGEgKSB7cmV0dXJuIChhID0gYSB8fCBbXSwgYS5wdXNoKGlzS2V5ZWRJdGVyID8gW2ssIHZdIDogdiksIGEpfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICB2YXIgY29lcmNlID0gaXRlcmFibGVDbGFzcyhpdGVyYWJsZSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24oYXJyICkge3JldHVybiByZWlmeShpdGVyYWJsZSwgY29lcmNlKGFycikpfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNsaWNlRmFjdG9yeShpdGVyYWJsZSwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuICAgIHZhciBvcmlnaW5hbFNpemUgPSBpdGVyYWJsZS5zaXplO1xuXG4gICAgLy8gU2FuaXRpemUgYmVnaW4gJiBlbmQgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmVnaW4gPSBiZWdpbiB8IDA7XG4gICAgfVxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgZW5kID0gb3JpZ2luYWxTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gZW5kIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBvcmlnaW5hbFNpemUpKSB7XG4gICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIG9yaWdpbmFsU2l6ZSk7XG4gICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIG9yaWdpbmFsU2l6ZSk7XG5cbiAgICAvLyBiZWdpbiBvciBlbmQgd2lsbCBiZSBOYU4gaWYgdGhleSB3ZXJlIHByb3ZpZGVkIGFzIG5lZ2F0aXZlIG51bWJlcnMgYW5kXG4gICAgLy8gdGhpcyBpdGVyYWJsZSdzIHNpemUgaXMgdW5rbm93bi4gSW4gdGhhdCBjYXNlLCBjYWNoZSBmaXJzdCBzbyB0aGVyZSBpc1xuICAgIC8vIGEga25vd24gc2l6ZSBhbmQgdGhlc2UgZG8gbm90IHJlc29sdmUgdG8gTmFOLlxuICAgIGlmIChyZXNvbHZlZEJlZ2luICE9PSByZXNvbHZlZEJlZ2luIHx8IHJlc29sdmVkRW5kICE9PSByZXNvbHZlZEVuZCkge1xuICAgICAgcmV0dXJuIHNsaWNlRmFjdG9yeShpdGVyYWJsZS50b1NlcSgpLmNhY2hlUmVzdWx0KCksIGJlZ2luLCBlbmQsIHVzZUtleXMpO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHJlc29sdmVkRW5kIGlzIHVuZGVmaW5lZCB3aGVuIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSdzIGxlbmd0aCBpc1xuICAgIC8vIHVua25vd24gYW5kIHRoaXMgc2xpY2UgZGlkIG5vdCBzdXBwbHkgYW4gZW5kIGFuZCBzaG91bGQgY29udGFpbiBhbGxcbiAgICAvLyBlbGVtZW50cyBhZnRlciByZXNvbHZlZEJlZ2luLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgcmVzb2x2ZWRTaXplIHdpbGwgYmUgTmFOIGFuZCBzbGljZVNpemUgd2lsbCByZW1haW4gdW5kZWZpbmVkLlxuICAgIHZhciByZXNvbHZlZFNpemUgPSByZXNvbHZlZEVuZCAtIHJlc29sdmVkQmVnaW47XG4gICAgdmFyIHNsaWNlU2l6ZTtcbiAgICBpZiAocmVzb2x2ZWRTaXplID09PSByZXNvbHZlZFNpemUpIHtcbiAgICAgIHNsaWNlU2l6ZSA9IHJlc29sdmVkU2l6ZSA8IDAgPyAwIDogcmVzb2x2ZWRTaXplO1xuICAgIH1cblxuICAgIHZhciBzbGljZVNlcSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG5cbiAgICAvLyBJZiBpdGVyYWJsZS5zaXplIGlzIHVuZGVmaW5lZCwgdGhlIHNpemUgb2YgdGhlIHJlYWxpemVkIHNsaWNlU2VxIGlzXG4gICAgLy8gdW5rbm93biBhdCB0aGlzIHBvaW50IHVubGVzcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNsaWNlIGlzIDBcbiAgICBzbGljZVNlcS5zaXplID0gc2xpY2VTaXplID09PSAwID8gc2xpY2VTaXplIDogaXRlcmFibGUuc2l6ZSAmJiBzbGljZVNpemUgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCF1c2VLZXlzICYmIGlzU2VxKGl0ZXJhYmxlKSAmJiBzbGljZVNpemUgPj0gMCkge1xuICAgICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgc2xpY2VTaXplID9cbiAgICAgICAgICBpdGVyYWJsZS5nZXQoaW5kZXggKyByZXNvbHZlZEJlZ2luLCBub3RTZXRWYWx1ZSkgOlxuICAgICAgICAgIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNsaWNlU2VxLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgaXRlcmF0aW9ucyAhPT0gc2xpY2VTaXplO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBzbGljZVNlcS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAoc2xpY2VTaXplICE9PSAwICYmIHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgYm90aGVyIGluc3RhbnRpYXRpbmcgcGFyZW50IGl0ZXJhdG9yIGlmIHRha2luZyAwLlxuICAgICAgdmFyIGl0ZXJhdG9yID0gc2xpY2VTaXplICE9PSAwICYmIGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pIHtcbiAgICAgICAgICBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCsraXRlcmF0aW9ucyA+IHNsaWNlU2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzbGljZVNlcTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdGFrZVdoaWxlRmFjdG9yeShpdGVyYWJsZSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHRha2VTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSBcbiAgICAgICAge3JldHVybiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSAmJiArK2l0ZXJhdGlvbnMgJiYgZm4odiwgaywgdGhpcyQwKX1cbiAgICAgICk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAoIWl0ZXJhdGluZykge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrID0gZW50cnlbMF07XG4gICAgICAgIHZhciB2ID0gZW50cnlbMV07XG4gICAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQwKSkge1xuICAgICAgICAgIGl0ZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc2tpcFdoaWxlRmFjdG9yeShpdGVyYWJsZSwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIHNraXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgc2tpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSkpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHNraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCwgaywgdjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGsgPSBlbnRyeVswXTtcbiAgICAgICAgICB2ID0gZW50cnlbMV07XG4gICAgICAgICAgc2tpcHBpbmcgJiYgKHNraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQwKSk7XG4gICAgICAgIH0gd2hpbGUgKHNraXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IElURVJBVEVfRU5UUklFUyA/IHN0ZXAgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBza2lwU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNvbmNhdEZhY3RvcnkoaXRlcmFibGUsIHZhbHVlcykge1xuICAgIHZhciBpc0tleWVkSXRlcmFibGUgPSBpc0tleWVkKGl0ZXJhYmxlKTtcbiAgICB2YXIgaXRlcnMgPSBbaXRlcmFibGVdLmNvbmNhdCh2YWx1ZXMpLm1hcChmdW5jdGlvbih2ICkge1xuICAgICAgaWYgKCFpc0l0ZXJhYmxlKHYpKSB7XG4gICAgICAgIHYgPSBpc0tleWVkSXRlcmFibGUgP1xuICAgICAgICAgIGtleWVkU2VxRnJvbVZhbHVlKHYpIDpcbiAgICAgICAgICBpbmRleGVkU2VxRnJvbVZhbHVlKEFycmF5LmlzQXJyYXkodikgPyB2IDogW3ZdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNLZXllZEl0ZXJhYmxlKSB7XG4gICAgICAgIHYgPSBLZXllZEl0ZXJhYmxlKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHYuc2l6ZSAhPT0gMH0pO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgIH1cblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBzaW5nbGV0b24gPSBpdGVyc1swXTtcbiAgICAgIGlmIChzaW5nbGV0b24gPT09IGl0ZXJhYmxlIHx8XG4gICAgICAgICAgaXNLZXllZEl0ZXJhYmxlICYmIGlzS2V5ZWQoc2luZ2xldG9uKSB8fFxuICAgICAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgJiYgaXNJbmRleGVkKHNpbmdsZXRvbikpIHtcbiAgICAgICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29uY2F0U2VxID0gbmV3IEFycmF5U2VxKGl0ZXJzKTtcbiAgICBpZiAoaXNLZXllZEl0ZXJhYmxlKSB7XG4gICAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9LZXllZFNlcSgpO1xuICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChpdGVyYWJsZSkpIHtcbiAgICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b1NldFNlcSgpO1xuICAgIH1cbiAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEuZmxhdHRlbih0cnVlKTtcbiAgICBjb25jYXRTZXEuc2l6ZSA9IGl0ZXJzLnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKHN1bSwgc2VxKSAge1xuICAgICAgICBpZiAoc3VtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHNlcS5zaXplO1xuICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiBjb25jYXRTZXE7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5GYWN0b3J5KGl0ZXJhYmxlLCBkZXB0aCwgdXNlS2V5cykge1xuICAgIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gZmxhdERlZXAoaXRlciwgY3VycmVudERlcHRoKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICAgICAgaWYgKCghZGVwdGggfHwgY3VycmVudERlcHRoIDwgZGVwdGgpICYmIGlzSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgIGZsYXREZWVwKHYsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zKyssIHRoaXMkMCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFzdG9wcGVkO1xuICAgICAgICB9LCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIGZsYXREZWVwKGl0ZXJhYmxlLCAwKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH1cbiAgICBmbGF0U2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvcikge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgICAgICB2ID0gdlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCghZGVwdGggfHwgc3RhY2subGVuZ3RoIDwgZGVwdGgpICYmIGlzSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSB2Ll9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmbGF0U2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZsYXRNYXBGYWN0b3J5KGl0ZXJhYmxlLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgY29lcmNlID0gaXRlcmFibGVDbGFzcyhpdGVyYWJsZSk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlLnRvU2VxKCkubWFwKFxuICAgICAgZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gY29lcmNlKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGl0ZXJhYmxlKSl9XG4gICAgKS5mbGF0dGVuKHRydWUpO1xuICB9XG5cblxuICBmdW5jdGlvbiBpbnRlcnBvc2VGYWN0b3J5KGl0ZXJhYmxlLCBzZXBhcmF0b3IpIHtcbiAgICB2YXIgaW50ZXJwb3NlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2Uuc2l6ZSA9IGl0ZXJhYmxlLnNpemUgJiYgaXRlcmFibGUuc2l6ZSAqIDIgLTE7XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSBcbiAgICAgICAge3JldHVybiAoIWl0ZXJhdGlvbnMgfHwgZm4oc2VwYXJhdG9yLCBpdGVyYXRpb25zKyssIHRoaXMkMCkgIT09IGZhbHNlKSAmJlxuICAgICAgICBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMCkgIT09IGZhbHNlfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKCFzdGVwIHx8IGl0ZXJhdGlvbnMgJSAyKSB7XG4gICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdGlvbnMgJSAyID9cbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc2VwYXJhdG9yKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW50ZXJwb3NlZFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBzb3J0RmFjdG9yeShpdGVyYWJsZSwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gICAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gICAgfVxuICAgIHZhciBpc0tleWVkSXRlcmFibGUgPSBpc0tleWVkKGl0ZXJhYmxlKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyaWVzID0gaXRlcmFibGUudG9TZXEoKS5tYXAoXG4gICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBbaywgdiwgaW5kZXgrKywgbWFwcGVyID8gbWFwcGVyKHYsIGssIGl0ZXJhYmxlKSA6IHZdfVxuICAgICkudG9BcnJheSgpO1xuICAgIGVudHJpZXMuc29ydChmdW5jdGlvbihhLCBiKSAge3JldHVybiBjb21wYXJhdG9yKGFbM10sIGJbM10pIHx8IGFbMl0gLSBiWzJdfSkuZm9yRWFjaChcbiAgICAgIGlzS2V5ZWRJdGVyYWJsZSA/XG4gICAgICBmdW5jdGlvbih2LCBpKSAgeyBlbnRyaWVzW2ldLmxlbmd0aCA9IDI7IH0gOlxuICAgICAgZnVuY3Rpb24odiwgaSkgIHsgZW50cmllc1tpXSA9IHZbMV07IH1cbiAgICApO1xuICAgIHJldHVybiBpc0tleWVkSXRlcmFibGUgPyBLZXllZFNlcShlbnRyaWVzKSA6XG4gICAgICBpc0luZGV4ZWQoaXRlcmFibGUpID8gSW5kZXhlZFNlcShlbnRyaWVzKSA6XG4gICAgICBTZXRTZXEoZW50cmllcyk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1heEZhY3RvcnkoaXRlcmFibGUsIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICAgIGlmICghY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIH1cbiAgICBpZiAobWFwcGVyKSB7XG4gICAgICB2YXIgZW50cnkgPSBpdGVyYWJsZS50b1NlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gW3YsIG1hcHBlcih2LCBrLCBpdGVyYWJsZSldfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbihhLCBiKSAge3JldHVybiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGFbMV0sIGJbMV0pID8gYiA6IGF9KTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLnJlZHVjZShmdW5jdGlvbihhLCBiKSAge3JldHVybiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpID8gYiA6IGF9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpIHtcbiAgICB2YXIgY29tcCA9IGNvbXBhcmF0b3IoYiwgYSk7XG4gICAgLy8gYiBpcyBjb25zaWRlcmVkIHRoZSBuZXcgbWF4IGlmIHRoZSBjb21wYXJhdG9yIGRlY2xhcmVzIHRoZW0gZXF1YWwsIGJ1dFxuICAgIC8vIHRoZXkgYXJlIG5vdCBlcXVhbCBhbmQgYiBpcyBpbiBmYWN0IGEgbnVsbGlzaCB2YWx1ZS5cbiAgICByZXR1cm4gKGNvbXAgPT09IDAgJiYgYiAhPT0gYSAmJiAoYiA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiAhPT0gYikpIHx8IGNvbXAgPiAwO1xuICB9XG5cblxuICBmdW5jdGlvbiB6aXBXaXRoRmFjdG9yeShrZXlJdGVyLCB6aXBwZXIsIGl0ZXJzKSB7XG4gICAgdmFyIHppcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGtleUl0ZXIpO1xuICAgIHppcFNlcXVlbmNlLnNpemUgPSBuZXcgQXJyYXlTZXEoaXRlcnMpLm1hcChmdW5jdGlvbihpICkge3JldHVybiBpLnNpemV9KS5taW4oKTtcbiAgICAvLyBOb3RlOiB0aGlzIGEgZ2VuZXJpYyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIF9faXRlcmF0ZSBpbiB0ZXJtcyBvZlxuICAgIC8vIF9faXRlcmF0b3Igd2hpY2ggbWF5IGJlIG1vcmUgZ2VuZXJpY2FsbHkgdXNlZnVsIGluIHRoZSBmdXR1cmUuXG4gICAgemlwU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIC8qIGdlbmVyaWM6XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChmbihzdGVwLnZhbHVlWzFdLCBzdGVwLnZhbHVlWzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgICAqL1xuICAgICAgLy8gaW5kZXhlZDpcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgemlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9ycyA9IGl0ZXJzLm1hcChmdW5jdGlvbihpIClcbiAgICAgICAge3JldHVybiAoaSA9IEl0ZXJhYmxlKGkpLCBnZXRJdGVyYXRvcihyZXZlcnNlID8gaS5yZXZlcnNlKCkgOiBpKSl9XG4gICAgICApO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIGlzRG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwcztcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICBzdGVwcyA9IGl0ZXJhdG9ycy5tYXAoZnVuY3Rpb24oaSApIHtyZXR1cm4gaS5uZXh0KCl9KTtcbiAgICAgICAgICBpc0RvbmUgPSBzdGVwcy5zb21lKGZ1bmN0aW9uKHMgKSB7cmV0dXJuIHMuZG9uZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBpdGVyYXRpb25zKyssXG4gICAgICAgICAgemlwcGVyLmFwcGx5KG51bGwsIHN0ZXBzLm1hcChmdW5jdGlvbihzICkge3JldHVybiBzLnZhbHVlfSkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB6aXBTZXF1ZW5jZVxuICB9XG5cblxuICAvLyAjcHJhZ21hIEhlbHBlciBGdW5jdGlvbnNcblxuICBmdW5jdGlvbiByZWlmeShpdGVyLCBzZXEpIHtcbiAgICByZXR1cm4gaXNTZXEoaXRlcikgPyBzZXEgOiBpdGVyLmNvbnN0cnVjdG9yKHNlcSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUVudHJ5KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5ICE9PSBPYmplY3QoZW50cnkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBbSywgVl0gdHVwbGU6ICcgKyBlbnRyeSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNpemUoaXRlcikge1xuICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgcmV0dXJuIGVuc3VyZVNpemUoaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYWJsZUNsYXNzKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIGlzS2V5ZWQoaXRlcmFibGUpID8gS2V5ZWRJdGVyYWJsZSA6XG4gICAgICBpc0luZGV4ZWQoaXRlcmFibGUpID8gSW5kZXhlZEl0ZXJhYmxlIDpcbiAgICAgIFNldEl0ZXJhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoXG4gICAgICAoXG4gICAgICAgIGlzS2V5ZWQoaXRlcmFibGUpID8gS2V5ZWRTZXEgOlxuICAgICAgICBpc0luZGV4ZWQoaXRlcmFibGUpID8gSW5kZXhlZFNlcSA6XG4gICAgICAgIFNldFNlcVxuICAgICAgKS5wcm90b3R5cGVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVSZXN1bHRUaHJvdWdoKCkge1xuICAgIGlmICh0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KSB7XG4gICAgICB0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KCk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9pdGVyLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VJdGVyYXRvcihrZXlQYXRoKSB7XG4gICAgdmFyIGl0ZXIgPSBnZXRJdGVyYXRvcihrZXlQYXRoKTtcbiAgICBpZiAoIWl0ZXIpIHtcbiAgICAgIC8vIEFycmF5IG1pZ2h0IG5vdCBiZSBpdGVyYWJsZSBpbiB0aGlzIGVudmlyb25tZW50LCBzbyB3ZSBuZWVkIGEgZmFsbGJhY2tcbiAgICAgIC8vIHRvIG91ciB3cmFwcGVkIHR5cGUuXG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKGtleVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2U6ICcgKyBrZXlQYXRoKTtcbiAgICAgIH1cbiAgICAgIGl0ZXIgPSBnZXRJdGVyYXRvcihJdGVyYWJsZShrZXlQYXRoKSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVyO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoUmVjb3JkLCBLZXllZENvbGxlY3Rpb24pO1xuXG4gICAgZnVuY3Rpb24gUmVjb3JkKGRlZmF1bHRWYWx1ZXMsIG5hbWUpIHtcbiAgICAgIHZhciBoYXNJbml0aWFsaXplZDtcblxuICAgICAgdmFyIFJlY29yZFR5cGUgPSBmdW5jdGlvbiBSZWNvcmQodmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlY29yZFR5cGUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFZhbHVlcyk7XG4gICAgICAgICAgc2V0UHJvcHMoUmVjb3JkVHlwZVByb3RvdHlwZSwga2V5cyk7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5zaXplID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fbmFtZSA9IG5hbWU7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fa2V5cyA9IGtleXM7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwID0gTWFwKHZhbHVlcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgUmVjb3JkVHlwZVByb3RvdHlwZSA9IFJlY29yZFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWNvcmRQcm90b3R5cGUpO1xuICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29yZFR5cGU7XG5cbiAgICAgIHJldHVybiBSZWNvcmRUeXBlO1xuICAgIH1cblxuICAgIFJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcocmVjb3JkTmFtZSh0aGlzKSArICcgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBSZWNvcmQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWVzLmhhc093blByb3BlcnR5KGspO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWZhdWx0VmFsID0gdGhpcy5fZGVmYXVsdFZhbHVlc1trXTtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAgPyB0aGlzLl9tYXAuZ2V0KGssIGRlZmF1bHRWYWwpIDogZGVmYXVsdFZhbDtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFJlY29yZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIFJlY29yZFR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIFJlY29yZFR5cGUuX2VtcHR5IHx8IChSZWNvcmRUeXBlLl9lbXB0eSA9IG1ha2VSZWNvcmQodGhpcywgZW1wdHlNYXAoKSkpO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHVua25vd24ga2V5IFwiJyArIGsgKyAnXCIgb24gJyArIHJlY29yZE5hbWUodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLmhhcyhrKSkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbCA9IHRoaXMuX2RlZmF1bHRWYWx1ZXNba107XG4gICAgICAgIGlmICh2ID09PSBkZWZhdWx0VmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLnNldChrLCB2KTtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCB8fCBuZXdNYXAgPT09IHRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld01hcCk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLnJlbW92ZShrKTtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCB8fCBuZXdNYXAgPT09IHRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld01hcCk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiBLZXllZEl0ZXJhYmxlKHRoaXMuX2RlZmF1bHRWYWx1ZXMpLm1hcChmdW5jdGlvbihfLCBrKSAge3JldHVybiB0aGlzJDAuZ2V0KGspfSkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIEtleWVkSXRlcmFibGUodGhpcy5fZGVmYXVsdFZhbHVlcykubWFwKGZ1bmN0aW9uKF8sIGspICB7cmV0dXJuIHRoaXMkMC5nZXQoayl9KS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwICYmIHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld01hcCwgb3duZXJJRCk7XG4gICAgfTtcblxuXG4gIHZhciBSZWNvcmRQcm90b3R5cGUgPSBSZWNvcmQucHJvdG90eXBlO1xuICBSZWNvcmRQcm90b3R5cGVbREVMRVRFXSA9IFJlY29yZFByb3RvdHlwZS5yZW1vdmU7XG4gIFJlY29yZFByb3RvdHlwZS5kZWxldGVJbiA9XG4gIFJlY29yZFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5yZW1vdmVJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlID0gTWFwUHJvdG90eXBlLm1lcmdlO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VXaXRoID0gTWFwUHJvdG90eXBlLm1lcmdlV2l0aDtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IE1hcFByb3RvdHlwZS5tZXJnZURlZXA7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcFdpdGg7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IE1hcFByb3RvdHlwZS5tZXJnZURlZXBJbjtcbiAgUmVjb3JkUHJvdG90eXBlLnNldEluID0gTWFwUHJvdG90eXBlLnNldEluO1xuICBSZWNvcmRQcm90b3R5cGUudXBkYXRlID0gTWFwUHJvdG90eXBlLnVwZGF0ZTtcbiAgUmVjb3JkUHJvdG90eXBlLnVwZGF0ZUluID0gTWFwUHJvdG90eXBlLnVwZGF0ZUluO1xuICBSZWNvcmRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBSZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcbiAgUmVjb3JkUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuXG5cbiAgZnVuY3Rpb24gbWFrZVJlY29yZChsaWtlUmVjb3JkLCBtYXAsIG93bmVySUQpIHtcbiAgICB2YXIgcmVjb3JkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YobGlrZVJlY29yZCkpO1xuICAgIHJlY29yZC5fbWFwID0gbWFwO1xuICAgIHJlY29yZC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmROYW1lKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQuX25hbWUgfHwgcmVjb3JkLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ1JlY29yZCc7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wcyhwcm90b3R5cGUsIG5hbWVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5hbWVzLmZvckVhY2goc2V0UHJvcC5iaW5kKHVuZGVmaW5lZCwgcHJvdG90eXBlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmYWlsZWQuIFByb2JhYmx5IElFOC5cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wKHByb3RvdHlwZSwgbmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLl9fb3duZXJJRCwgJ0Nhbm5vdCBzZXQgb24gYW4gaW1tdXRhYmxlIHJlY29yZC4nKTtcbiAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU2V0LCBTZXRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXQoKSA6XG4gICAgICAgIGlzU2V0KHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlTZXQoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgICB2YXIgaXRlciA9IFNldEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbih2ICkge3JldHVybiBzZXQuYWRkKHYpfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIFNldC5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcyhLZXllZEl0ZXJhYmxlKHZhbHVlKS5rZXlTZXEoKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NldCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnNldCh2YWx1ZSwgdHJ1ZSkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5yZW1vdmUodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbigpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIGl0ZXJzID0gaXRlcnMuZmlsdGVyKGZ1bmN0aW9uKHggKSB7cmV0dXJuIHguc2l6ZSAhPT0gMH0pO1xuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIFNldEl0ZXJhYmxlKGl0ZXJzW2lpXSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gc2V0LmFkZCh2YWx1ZSl9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24oKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24oaXRlciApIHtyZXR1cm4gU2V0SXRlcmFibGUoaXRlcil9KTtcbiAgICAgIHZhciBvcmlnaW5hbFNldCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgb3JpZ2luYWxTZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSApIHtcbiAgICAgICAgICBpZiAoIWl0ZXJzLmV2ZXJ5KGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpfSkpIHtcbiAgICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uKCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIFNldEl0ZXJhYmxlKGl0ZXIpfSk7XG4gICAgICB2YXIgb3JpZ2luYWxTZXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgIG9yaWdpbmFsU2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7XG4gICAgICAgICAgaWYgKGl0ZXJzLnNvbWUoZnVuY3Rpb24oaXRlciApIHtyZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSl9KSkge1xuICAgICAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMudW5pb24uYXBwbHkodGhpcywgaXRlcnMpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRlKGZ1bmN0aW9uKF8sIGspICB7cmV0dXJuIGZuKGssIGssIHRoaXMkMCl9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5tYXAoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4ga30pLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNTZXQobWF5YmVTZXQpIHtcbiAgICByZXR1cm4gISEobWF5YmVTZXQgJiYgbWF5YmVTZXRbSVNfU0VUX1NFTlRJTkVMXSk7XG4gIH1cblxuICBTZXQuaXNTZXQgPSBpc1NldDtcblxuICB2YXIgSVNfU0VUX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfU0VUX19AQCc7XG5cbiAgdmFyIFNldFByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XG4gIFNldFByb3RvdHlwZVtJU19TRVRfU0VOVElORUxdID0gdHJ1ZTtcbiAgU2V0UHJvdG90eXBlW0RFTEVURV0gPSBTZXRQcm90b3R5cGUucmVtb3ZlO1xuICBTZXRQcm90b3R5cGUubWVyZ2VEZWVwID0gU2V0UHJvdG90eXBlLm1lcmdlO1xuICBTZXRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IFNldFByb3RvdHlwZS5tZXJnZVdpdGg7XG4gIFNldFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnM7XG4gIFNldFByb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuICBTZXRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5cbiAgU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eVNldDtcbiAgU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VTZXQ7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2V0KHNldCwgbmV3TWFwKSB7XG4gICAgaWYgKHNldC5fX293bmVySUQpIHtcbiAgICAgIHNldC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgICBzZXQuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXAgPT09IHNldC5fbWFwID8gc2V0IDpcbiAgICAgIG5ld01hcC5zaXplID09PSAwID8gc2V0Ll9fZW1wdHkoKSA6XG4gICAgICBzZXQuX19tYWtlKG5ld01hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2V0KG1hcCwgb3duZXJJRCkge1xuICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKFNldFByb3RvdHlwZSk7XG4gICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgc2V0Ll9tYXAgPSBtYXA7XG4gICAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuXG4gIHZhciBFTVBUWV9TRVQ7XG4gIGZ1bmN0aW9uIGVtcHR5U2V0KCkge1xuICAgIHJldHVybiBFTVBUWV9TRVQgfHwgKEVNUFRZX1NFVCA9IG1ha2VTZXQoZW1wdHlNYXAoKSkpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoT3JkZXJlZFNldCwgU2V0KTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBPcmRlcmVkU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5T3JkZXJlZFNldCgpIDpcbiAgICAgICAgaXNPcmRlcmVkU2V0KHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlPcmRlcmVkU2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBTZXRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiApIHtyZXR1cm4gc2V0LmFkZCh2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBPcmRlcmVkU2V0Lm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcyhLZXllZEl0ZXJhYmxlKHZhbHVlKS5rZXlTZXEoKSk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkU2V0IHsnLCAnfScpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc09yZGVyZWRTZXQobWF5YmVPcmRlcmVkU2V0KSB7XG4gICAgcmV0dXJuIGlzU2V0KG1heWJlT3JkZXJlZFNldCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZFNldCk7XG4gIH1cblxuICBPcmRlcmVkU2V0LmlzT3JkZXJlZFNldCA9IGlzT3JkZXJlZFNldDtcblxuICB2YXIgT3JkZXJlZFNldFByb3RvdHlwZSA9IE9yZGVyZWRTZXQucHJvdG90eXBlO1xuICBPcmRlcmVkU2V0UHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuICBPcmRlcmVkU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eU9yZGVyZWRTZXQ7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZU9yZGVyZWRTZXQ7XG5cbiAgZnVuY3Rpb24gbWFrZU9yZGVyZWRTZXQobWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZFNldFByb3RvdHlwZSk7XG4gICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgc2V0Ll9tYXAgPSBtYXA7XG4gICAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuXG4gIHZhciBFTVBUWV9PUkRFUkVEX1NFVDtcbiAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkU2V0KCkge1xuICAgIHJldHVybiBFTVBUWV9PUkRFUkVEX1NFVCB8fCAoRU1QVFlfT1JERVJFRF9TRVQgPSBtYWtlT3JkZXJlZFNldChlbXB0eU9yZGVyZWRNYXAoKSkpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU3RhY2ssIEluZGV4ZWRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBTdGFjayh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVN0YWNrKCkgOlxuICAgICAgICBpc1N0YWNrKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlTdGFjaygpLnVuc2hpZnRBbGwodmFsdWUpO1xuICAgIH1cblxuICAgIFN0YWNrLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTdGFjayBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHdoaWxlIChoZWFkICYmIGluZGV4LS0pIHtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWFkID8gaGVhZC52YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgJiYgdGhpcy5faGVhZC52YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBmb3IgKHZhciBpaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IGFyZ3VtZW50c1tpaV0sXG4gICAgICAgICAgbmV4dDogaGVhZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoQWxsID0gZnVuY3Rpb24oaXRlcikge1xuICAgICAgaXRlciA9IEluZGV4ZWRJdGVyYWJsZShpdGVyKTtcbiAgICAgIGlmIChpdGVyLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBpdGVyLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlICkge1xuICAgICAgICBuZXdTaXplKys7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5leHQ6IGhlYWRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnVuc2hpZnRBbGwgPSBmdW5jdGlvbihpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoQWxsKGl0ZXIpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgdGhpcy5zaXplKTtcbiAgICAgIGlmIChyZXNvbHZlZEVuZCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgIC8vIHN1cGVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSAtIHJlc29sdmVkQmVnaW47XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICB3aGlsZSAocmVzb2x2ZWRCZWdpbi0tKSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayh0aGlzLnNpemUsIHRoaXMuX2hlYWQsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLl9faXRlcmF0ZShmbik7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoZm4obm9kZS52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLl9faXRlcmF0b3IodHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzU3RhY2sobWF5YmVTdGFjaykge1xuICAgIHJldHVybiAhIShtYXliZVN0YWNrICYmIG1heWJlU3RhY2tbSVNfU1RBQ0tfU0VOVElORUxdKTtcbiAgfVxuXG4gIFN0YWNrLmlzU3RhY2sgPSBpc1N0YWNrO1xuXG4gIHZhciBJU19TVEFDS19TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NUQUNLX19AQCc7XG5cbiAgdmFyIFN0YWNrUHJvdG90eXBlID0gU3RhY2sucHJvdG90eXBlO1xuICBTdGFja1Byb3RvdHlwZVtJU19TVEFDS19TRU5USU5FTF0gPSB0cnVlO1xuICBTdGFja1Byb3RvdHlwZS53aXRoTXV0YXRpb25zID0gTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnM7XG4gIFN0YWNrUHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG4gIFN0YWNrUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuICBTdGFja1Byb3RvdHlwZS53YXNBbHRlcmVkID0gTWFwUHJvdG90eXBlLndhc0FsdGVyZWQ7XG5cblxuICBmdW5jdGlvbiBtYWtlU3RhY2soc2l6ZSwgaGVhZCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKFN0YWNrUHJvdG90eXBlKTtcbiAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgbWFwLl9oZWFkID0gaGVhZDtcbiAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBtYXAuX19oYXNoID0gaGFzaDtcbiAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9TVEFDSztcbiAgZnVuY3Rpb24gZW1wdHlTdGFjaygpIHtcbiAgICByZXR1cm4gRU1QVFlfU1RBQ0sgfHwgKEVNUFRZX1NUQUNLID0gbWFrZVN0YWNrKDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cmlidXRlcyBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuICAgIHZhciBrZXlDb3BpZXIgPSBmdW5jdGlvbihrZXkgKSB7IGN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07IH07XG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiZcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIHJldHVybiBjdG9yO1xuICB9XG5cbiAgSXRlcmFibGUuSXRlcmF0b3IgPSBJdGVyYXRvcjtcblxuICBtaXhpbihJdGVyYWJsZSwge1xuXG4gICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheSh0aGlzLnNpemUgfHwgMCk7XG4gICAgICB0aGlzLnZhbHVlU2VxKCkuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGkpICB7IGFycmF5W2ldID0gdjsgfSk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIHRvSW5kZXhlZFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvSW5kZXhlZFNlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b0pTOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKFxuICAgICAgICBmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlMgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b0pTKCkgOiB2YWx1ZX1cbiAgICAgICkuX190b0pTKCk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChcbiAgICAgICAgZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b0pTT04oKSA6IHZhbHVlfVxuICAgICAgKS5fX3RvSlMoKTtcbiAgICB9LFxuXG4gICAgdG9LZXllZFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgdG9NYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gICAgfSxcblxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAgeyBvYmplY3Rba10gPSB2OyB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIHRvT3JkZXJlZE1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gICAgfSxcblxuICAgIHRvT3JkZXJlZFNldDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NldFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvU2V0U2VxdWVuY2UodGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc0luZGV4ZWQodGhpcykgPyB0aGlzLnRvSW5kZXhlZFNlcSgpIDpcbiAgICAgICAgaXNLZXllZCh0aGlzKSA/IHRoaXMudG9LZXllZFNlcSgpIDpcbiAgICAgICAgdGhpcy50b1NldFNlcSgpO1xuICAgIH0sXG5cbiAgICB0b1N0YWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBTdGFjayhpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gTGlzdChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIENvbW1vbiBKYXZhU2NyaXB0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnW0l0ZXJhYmxlXSc7XG4gICAgfSxcblxuICAgIF9fdG9TdHJpbmc6IGZ1bmN0aW9uKGhlYWQsIHRhaWwpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlYWQgKyAnICcgKyB0aGlzLnRvU2VxKCkubWFwKHRoaXMuX190b1N0cmluZ01hcHBlcikuam9pbignLCAnKSArICcgJyArIHRhaWw7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgY29uY2F0OiBmdW5jdGlvbigpIHt2YXIgdmFsdWVzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgY29uY2F0RmFjdG9yeSh0aGlzLCB2YWx1ZXMpKTtcbiAgICB9LFxuXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpfSk7XG4gICAgfSxcblxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICAgIH0sXG5cbiAgICBldmVyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG4gICAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgZmluZDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKHNpZGVFZmZlY3QsIGNvbnRleHQpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGUoY29udGV4dCA/IHNpZGVFZmZlY3QuYmluZChjb250ZXh0KSA6IHNpZGVFZmZlY3QpO1xuICAgIH0sXG5cbiAgICBqb2luOiBmdW5jdGlvbihzZXBhcmF0b3IpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/ICcnICsgc2VwYXJhdG9yIDogJywnO1xuICAgICAgdmFyIGpvaW5lZCA9ICcnO1xuICAgICAgdmFyIGlzRmlyc3QgPSB0cnVlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtcbiAgICAgICAgaXNGaXJzdCA/IChpc0ZpcnN0ID0gZmFsc2UpIDogKGpvaW5lZCArPSBzZXBhcmF0b3IpO1xuICAgICAgICBqb2luZWQgKz0gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQgPyB2LnRvU3RyaW5nKCkgOiAnJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGpvaW5lZDtcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfS0VZUyk7XG4gICAgfSxcblxuICAgIG1hcDogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgcmVkdWNlOiBmdW5jdGlvbihyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIHJlZHVjdGlvbjtcbiAgICAgIHZhciB1c2VGaXJzdDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB1c2VGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y3Rpb24gPSBpbml0aWFsUmVkdWN0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKHVzZUZpcnN0KSB7XG4gICAgICAgICAgdXNlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICByZWR1Y3Rpb24gPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZHVjdGlvbiA9IHJlZHVjZXIuY2FsbChjb250ZXh0LCByZWR1Y3Rpb24sIHYsIGssIGMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWR1Y3Rpb247XG4gICAgfSxcblxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbihyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmV2ZXJzZWQgPSB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gcmV2ZXJzZWQucmVkdWNlLmFwcGx5KHJldmVyc2VkLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc29tZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gIXRoaXMuZXZlcnkobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzb3J0OiBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICAgIH0sXG5cbiAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUyk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBidXRMYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIC0xKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplICE9PSB1bmRlZmluZWQgPyB0aGlzLnNpemUgPT09IDAgOiAhdGhpcy5zb21lKGZ1bmN0aW9uKCkgIHtyZXR1cm4gdHJ1ZX0pO1xuICAgIH0sXG5cbiAgICBjb3VudDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZW5zdXJlU2l6ZShcbiAgICAgICAgcHJlZGljYXRlID8gdGhpcy50b1NlcSgpLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIDogdGhpc1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgY291bnRCeTogZnVuY3Rpb24oZ3JvdXBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNvdW50QnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgICB9LFxuXG4gICAgZW50cnlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcztcbiAgICAgIGlmIChpdGVyYWJsZS5fY2FjaGUpIHtcbiAgICAgICAgLy8gV2UgY2FjaGUgYXMgYW4gZW50cmllcyBhcnJheSwgc28gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBjYWNoZSFcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcShpdGVyYWJsZS5fY2FjaGUpO1xuICAgICAgfVxuICAgICAgdmFyIGVudHJpZXNTZXF1ZW5jZSA9IGl0ZXJhYmxlLnRvU2VxKCkubWFwKGVudHJ5TWFwcGVyKS50b0luZGV4ZWRTZXEoKTtcbiAgICAgIGVudHJpZXNTZXF1ZW5jZS5mcm9tRW50cnlTZXEgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlLnRvU2VxKCl9O1xuICAgICAgcmV0dXJuIGVudHJpZXNTZXF1ZW5jZTtcbiAgICB9LFxuXG4gICAgZmlsdGVyTm90OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGZpbmRFbnRyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGZvdW5kID0gbm90U2V0VmFsdWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICBmb3VuZCA9IFtrLCB2XTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICBmaW5kS2V5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gICAgfSxcblxuICAgIGZpbmRMYXN0OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZpbmRMYXN0RW50cnk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdEtleTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChyZXR1cm5UcnVlKTtcbiAgICB9LFxuXG4gICAgZmxhdE1hcDogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdE1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgZnJvbUVudHJ5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRnJvbUVudHJpZXNTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKF8sIGtleSkgIHtyZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGdldEluOiBmdW5jdGlvbihzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIG5lc3RlZCA9IHRoaXM7XG4gICAgICAvLyBOb3RlOiBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIHdlIHdvdWxkIHByZWZlcjpcbiAgICAgIC8vIGZvciAodmFyIGtleSBvZiBzZWFyY2hLZXlQYXRoKSB7XG4gICAgICB2YXIgaXRlciA9IGZvcmNlSXRlcmF0b3Ioc2VhcmNoS2V5UGF0aCk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIga2V5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkICYmIG5lc3RlZC5nZXQgPyBuZXN0ZWQuZ2V0KGtleSwgTk9UX1NFVCkgOiBOT1RfU0VUO1xuICAgICAgICBpZiAobmVzdGVkID09PSBOT1RfU0VUKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmVzdGVkO1xuICAgIH0sXG5cbiAgICBncm91cEJ5OiBmdW5jdGlvbihncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24oc2VhcmNoS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoc2VhcmNoS2V5LCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgICB9LFxuXG4gICAgaGFzSW46IGZ1bmN0aW9uKHNlYXJjaEtleVBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluKHNlYXJjaEtleVBhdGgsIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuICAgIH0sXG5cbiAgICBpc1N1YnNldDogZnVuY3Rpb24oaXRlcikge1xuICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmluY2x1ZGVzID09PSAnZnVuY3Rpb24nID8gaXRlciA6IEl0ZXJhYmxlKGl0ZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpfSk7XG4gICAgfSxcblxuICAgIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uKGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pc1N1YnNldCA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBJdGVyYWJsZShpdGVyKTtcbiAgICAgIHJldHVybiBpdGVyLmlzU3Vic2V0KHRoaXMpO1xuICAgIH0sXG5cbiAgICBrZXlPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRLZXkoZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSl9KTtcbiAgICB9LFxuXG4gICAga2V5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKGtleU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkuZmlyc3QoKTtcbiAgICB9LFxuXG4gICAgbGFzdEtleU9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvcik7XG4gICAgfSxcblxuICAgIG1heEJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcik7XG4gICAgfSxcblxuICAgIG1pbjogZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgbWluQnk6IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yLCBtYXBwZXIpO1xuICAgIH0sXG5cbiAgICByZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbihhbW91bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICBza2lwTGFzdDogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgdGhpcy50b1NlcSgpLnJldmVyc2UoKS5za2lwKGFtb3VudCkucmV2ZXJzZSgpKTtcbiAgICB9LFxuXG4gICAgc2tpcFdoaWxlOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBza2lwVW50aWw6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcFdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgc29ydEJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9LFxuXG4gICAgdGFrZTogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgdGFrZUxhc3Q6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkudGFrZShhbW91bnQpLnJldmVyc2UoKSk7XG4gICAgfSxcblxuICAgIHRha2VXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgdGFrZVdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgdGFrZVVudGlsOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2VXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHZhbHVlU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvSW5kZXhlZFNlcSgpO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBIYXNoYWJsZSBPYmplY3RcblxuICAgIGhhc2hDb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faGFzaCB8fCAodGhpcy5fX2hhc2ggPSBoYXNoSXRlcmFibGUodGhpcykpO1xuICAgIH1cblxuXG4gICAgLy8gIyMjIEludGVybmFsXG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGUoZm4sIHJldmVyc2UpXG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpXG4gIH0pO1xuXG4gIC8vIHZhciBJU19JVEVSQUJMRV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCc7XG4gIC8vIHZhciBJU19LRVlFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCc7XG4gIC8vIHZhciBJU19JTkRFWEVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnO1xuICAvLyB2YXIgSVNfT1JERVJFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJztcblxuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIEl0ZXJhYmxlUHJvdG90eXBlW0lTX0lURVJBQkxFX1NFTlRJTkVMXSA9IHRydWU7XG4gIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBJdGVyYWJsZVByb3RvdHlwZS52YWx1ZXM7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLl9fdG9KUyA9IEl0ZXJhYmxlUHJvdG90eXBlLnRvQXJyYXk7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBxdW90ZVN0cmluZztcbiAgSXRlcmFibGVQcm90b3R5cGUuaW5zcGVjdCA9XG4gIEl0ZXJhYmxlUHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH07XG4gIEl0ZXJhYmxlUHJvdG90eXBlLmNoYWluID0gSXRlcmFibGVQcm90b3R5cGUuZmxhdE1hcDtcbiAgSXRlcmFibGVQcm90b3R5cGUuY29udGFpbnMgPSBJdGVyYWJsZVByb3RvdHlwZS5pbmNsdWRlcztcblxuICBtaXhpbihLZXllZEl0ZXJhYmxlLCB7XG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGZsaXA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsaXBGYWN0b3J5KHRoaXMpKTtcbiAgICB9LFxuXG4gICAgbWFwRW50cmllczogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpLm1hcChcbiAgICAgICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBtYXBwZXIuY2FsbChjb250ZXh0LCBbaywgdl0sIGl0ZXJhdGlvbnMrKywgdGhpcyQwKX1cbiAgICAgICAgKS5mcm9tRW50cnlTZXEoKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgbWFwS2V5czogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpLmZsaXAoKS5tYXAoXG4gICAgICAgICAgZnVuY3Rpb24oaywgdikgIHtyZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgaywgdiwgdGhpcyQwKX1cbiAgICAgICAgKS5mbGlwKClcbiAgICAgICk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHZhciBLZXllZEl0ZXJhYmxlUHJvdG90eXBlID0gS2V5ZWRJdGVyYWJsZS5wcm90b3R5cGU7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGVbSVNfS0VZRURfU0VOVElORUxdID0gdHJ1ZTtcbiAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcztcbiAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZS5fX3RvSlMgPSBJdGVyYWJsZVByb3RvdHlwZS50b09iamVjdDtcbiAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoaykgKyAnOiAnICsgcXVvdGVTdHJpbmcodil9O1xuXG5cblxuICBtaXhpbihJbmRleGVkSXRlcmFibGUsIHtcblxuICAgIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgICB0b0tleWVkU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIGZhbHNlKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gICAgfSxcblxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgICB9LFxuXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5sYXN0S2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNwbGljZTogZnVuY3Rpb24oaW5kZXgsIHJlbW92ZU51bSAvKiwgLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHJlbW92ZU51bSA9IE1hdGgubWF4KHJlbW92ZU51bSB8IDAsIDApO1xuICAgICAgaWYgKG51bUFyZ3MgPT09IDAgfHwgKG51bUFyZ3MgPT09IDIgJiYgIXJlbW92ZU51bSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBJZiBpbmRleCBpcyBuZWdhdGl2ZSwgaXQgc2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHNpemUgb2YgdGhlXG4gICAgICAvLyBjb2xsZWN0aW9uLiBIb3dldmVyIHNpemUgbWF5IGJlIGV4cGVuc2l2ZSB0byBjb21wdXRlIGlmIG5vdCBjYWNoZWQsIHNvXG4gICAgICAvLyBvbmx5IGNhbGwgY291bnQoKSBpZiB0aGUgbnVtYmVyIGlzIGluIGZhY3QgbmVnYXRpdmUuXG4gICAgICBpbmRleCA9IHJlc29sdmVCZWdpbihpbmRleCwgaW5kZXggPCAwID8gdGhpcy5jb3VudCgpIDogdGhpcy5zaXplKTtcbiAgICAgIHZhciBzcGxpY2VkID0gdGhpcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICByZXR1cm4gcmVpZnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG51bUFyZ3MgPT09IDEgP1xuICAgICAgICAgIHNwbGljZWQgOlxuICAgICAgICAgIHNwbGljZWQuY29uY2F0KGFyckNvcHkoYXJndW1lbnRzLCAyKSwgdGhpcy5zbGljZShpbmRleCArIHJlbW92ZU51bSkpXG4gICAgICApO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBNb3JlIGNvbGxlY3Rpb24gbWV0aG9kc1xuXG4gICAgZmluZExhc3RJbmRleDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgwKTtcbiAgICB9LFxuXG4gICAgZmxhdHRlbjogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiAoaW5kZXggPCAwIHx8ICh0aGlzLnNpemUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID4gdGhpcy5zaXplKSkpID9cbiAgICAgICAgbm90U2V0VmFsdWUgOlxuICAgICAgICB0aGlzLmZpbmQoZnVuY3Rpb24oXywga2V5KSAge3JldHVybiBrZXkgPT09IGluZGV4fSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBpbmRleCA+PSAwICYmICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemUgOlxuICAgICAgICB0aGlzLmluZGV4T2YoaW5kZXgpICE9PSAtMVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJwb3NlOiBmdW5jdGlvbihzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcnBvc2VGYWN0b3J5KHRoaXMsIHNlcGFyYXRvcikpO1xuICAgIH0sXG5cbiAgICBpbnRlcmxlYXZlOiBmdW5jdGlvbigvKi4uLml0ZXJhYmxlcyovKSB7XG4gICAgICB2YXIgaXRlcmFibGVzID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgdmFyIHppcHBlZCA9IHppcFdpdGhGYWN0b3J5KHRoaXMudG9TZXEoKSwgSW5kZXhlZFNlcS5vZiwgaXRlcmFibGVzKTtcbiAgICAgIHZhciBpbnRlcmxlYXZlZCA9IHppcHBlZC5mbGF0dGVuKHRydWUpO1xuICAgICAgaWYgKHppcHBlZC5zaXplKSB7XG4gICAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGl0ZXJhYmxlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJsZWF2ZWQpO1xuICAgIH0sXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFJhbmdlKDAsIHRoaXMuc2l6ZSk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KC0xKTtcbiAgICB9LFxuXG4gICAgc2tpcFdoaWxlOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgemlwOiBmdW5jdGlvbigvKiwgLi4uaXRlcmFibGVzICovKSB7XG4gICAgICB2YXIgaXRlcmFibGVzID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGl0ZXJhYmxlcykpO1xuICAgIH0sXG5cbiAgICB6aXBXaXRoOiBmdW5jdGlvbih6aXBwZXIvKiwgLi4uaXRlcmFibGVzICovKSB7XG4gICAgICB2YXIgaXRlcmFibGVzID0gYXJyQ29weShhcmd1bWVudHMpO1xuICAgICAgaXRlcmFibGVzWzBdID0gdGhpcztcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCB6aXBwZXIsIGl0ZXJhYmxlcykpO1xuICAgIH1cblxuICB9KTtcblxuICBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlW0lTX0lOREVYRURfU0VOVElORUxdID0gdHJ1ZTtcbiAgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuXG4gIG1peGluKFNldEl0ZXJhYmxlLCB7XG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKHZhbHVlLCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKSA/IHZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGtleVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZVNlcSgpO1xuICAgIH1cblxuICB9KTtcblxuICBTZXRJdGVyYWJsZS5wcm90b3R5cGUuaGFzID0gSXRlcmFibGVQcm90b3R5cGUuaW5jbHVkZXM7XG4gIFNldEl0ZXJhYmxlLnByb3RvdHlwZS5jb250YWlucyA9IFNldEl0ZXJhYmxlLnByb3RvdHlwZS5pbmNsdWRlcztcblxuXG4gIC8vIE1peGluIHN1YmNsYXNzZXNcblxuICBtaXhpbihLZXllZFNlcSwgS2V5ZWRJdGVyYWJsZS5wcm90b3R5cGUpO1xuICBtaXhpbihJbmRleGVkU2VxLCBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlKTtcbiAgbWl4aW4oU2V0U2VxLCBTZXRJdGVyYWJsZS5wcm90b3R5cGUpO1xuXG4gIG1peGluKEtleWVkQ29sbGVjdGlvbiwgS2V5ZWRJdGVyYWJsZS5wcm90b3R5cGUpO1xuICBtaXhpbihJbmRleGVkQ29sbGVjdGlvbiwgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG4gIG1peGluKFNldENvbGxlY3Rpb24sIFNldEl0ZXJhYmxlLnByb3RvdHlwZSk7XG5cblxuICAvLyAjcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBrZXlNYXBwZXIodiwgaykge1xuICAgIHJldHVybiBrO1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuICAgIHJldHVybiBbaywgdl07XG4gIH1cblxuICBmdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZWcocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC1wcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBxdW90ZVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRaaXBwZXIoKSB7XG4gICAgcmV0dXJuIGFyckNvcHkoYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHROZWdDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAxIDogYSA+IGIgPyAtMSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUuc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgb3JkZXJlZCA9IGlzT3JkZXJlZChpdGVyYWJsZSk7XG4gICAgdmFyIGtleWVkID0gaXNLZXllZChpdGVyYWJsZSk7XG4gICAgdmFyIGggPSBvcmRlcmVkID8gMSA6IDA7XG4gICAgdmFyIHNpemUgPSBpdGVyYWJsZS5fX2l0ZXJhdGUoXG4gICAgICBrZXllZCA/XG4gICAgICAgIG9yZGVyZWQgP1xuICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7IGggPSAzMSAqIGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkgfCAwOyB9IDpcbiAgICAgICAgICBmdW5jdGlvbih2LCBrKSAgeyBoID0gaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSB8IDA7IH0gOlxuICAgICAgICBvcmRlcmVkID9cbiAgICAgICAgICBmdW5jdGlvbih2ICkgeyBoID0gMzEgKiBoICsgaGFzaCh2KSB8IDA7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uKHYgKSB7IGggPSBoICsgaGFzaCh2KSB8IDA7IH1cbiAgICApO1xuICAgIHJldHVybiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKSB7XG4gICAgaCA9IGltdWwoaCwgMHhDQzlFMkQ1MSk7XG4gICAgaCA9IGltdWwoaCA8PCAxNSB8IGggPj4+IC0xNSwgMHgxQjg3MzU5Myk7XG4gICAgaCA9IGltdWwoaCA8PCAxMyB8IGggPj4+IC0xMywgNSk7XG4gICAgaCA9IChoICsgMHhFNjU0NkI2NCB8IDApIF4gc2l6ZTtcbiAgICBoID0gaW11bChoIF4gaCA+Pj4gMTYsIDB4ODVFQkNBNkIpO1xuICAgIGggPSBpbXVsKGggXiBoID4+PiAxMywgMHhDMkIyQUUzNSk7XG4gICAgaCA9IHNtaShoIF4gaCA+Pj4gMTYpO1xuICAgIHJldHVybiBoO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaE1lcmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYSBeIGIgKyAweDlFMzc3OUI5ICsgKGEgPDwgNikgKyAoYSA+PiAyKSB8IDA7IC8vIGludFxuICB9XG5cbiAgdmFyIEltbXV0YWJsZSA9IHtcblxuICAgIEl0ZXJhYmxlOiBJdGVyYWJsZSxcblxuICAgIFNlcTogU2VxLFxuICAgIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXG4gICAgTWFwOiBNYXAsXG4gICAgT3JkZXJlZE1hcDogT3JkZXJlZE1hcCxcbiAgICBMaXN0OiBMaXN0LFxuICAgIFN0YWNrOiBTdGFjayxcbiAgICBTZXQ6IFNldCxcbiAgICBPcmRlcmVkU2V0OiBPcmRlcmVkU2V0LFxuXG4gICAgUmVjb3JkOiBSZWNvcmQsXG4gICAgUmFuZ2U6IFJhbmdlLFxuICAgIFJlcGVhdDogUmVwZWF0LFxuXG4gICAgaXM6IGlzLFxuICAgIGZyb21KUzogZnJvbUpTXG5cbiAgfTtcblxuICByZXR1cm4gSW1tdXRhYmxlO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImNvbnN0IFZlY3RvciA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG5cbmV4cG9ydCBjb25zdCBOT1JUSCA9ICdOJztcbmV4cG9ydCBjb25zdCBTT1VUSCA9ICdTJztcbmV4cG9ydCBjb25zdCBFQVNUID0gJ0UnO1xuZXhwb3J0IGNvbnN0IFdFU1QgPSAnVyc7XG5cbmNvbnN0IEFMTCA9IHtcbiAgW05PUlRIXTogbmV3IFZlY3Rvcih7eDogMCwgeTogLTF9KSxcbiAgW1NPVVRIXTogbmV3IFZlY3Rvcih7eDogMCwgeTogMX0pLFxuICBbRUFTVF06IG5ldyBWZWN0b3Ioe3g6IDEsIHk6IDB9KSxcbiAgW1dFU1RdOiBuZXcgVmVjdG9yKHt4OiAtMSwgeTogMH0pLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbCgpIHtcbiAgcmV0dXJuIG5hbWVzKCkubWFwKChuKSA9PiBBTExbbl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZXMoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhBTEwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPcHBvc2l0ZShkMSwgZDIpIHtcbiAgcmV0dXJuIGQxLmRvdChkMikgPCAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9OYW1lKGRpcmVjdGlvbikge1xuICByZXR1cm4gbmFtZXMoKS5maW5kKChuYW1lKSA9PiBBTExbbmFtZV0uZXF1YWxzKGRpcmVjdGlvbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EaXJlY3Rpb24obmFtZSkge1xuICByZXR1cm4gQUxMW25hbWVdO1xufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbHMvZGlyZWN0aW9uLmpzeFxuICoqLyIsImNvbnN0IHtSZWNvcmR9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5jb25zdCBDaGFuY2UgPSByZXF1aXJlKCdjaGFuY2UnKTtcblxuY29uc3QgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcblxuY29uc3QgR2FtZVN0YXR1cyA9IHJlcXVpcmUoJy4vZ2FtZVN0YXR1cycpO1xuY29uc3QgU25ha2UgPSByZXF1aXJlKCcuL3NuYWtlJyk7XG5cbmNvbnN0IEVNUFRZID0gMDtcbmNvbnN0IFNOQUtFID0gMTtcbmNvbnN0IEdPQUwgPSAyO1xuXG5jb25zdCBjaGFuY2UgPSBuZXcgQ2hhbmNlKCk7XG5cbmNvbnN0IFNuYWtlR2FtZVJlY29yZCA9IFJlY29yZCh7XG4gIHJvd3M6IHVuZGVmaW5lZCxcbiAgY29sczogdW5kZWZpbmVkLFxuICBnb2FsOiB1bmRlZmluZWQsXG4gIHNuYWtlOiB1bmRlZmluZWQsXG4gIHN0YXR1czogbmV3IEdhbWVTdGF0dXMoKSxcbn0pO1xuXG5jbGFzcyBTbmFrZUdhbWUgZXh0ZW5kcyBTbmFrZUdhbWVSZWNvcmQge1xuICBzdGF0aWMgZnJvbURpbWVuc2lvbnMoe3Jvd3MsIGNvbHN9KSB7XG4gICAgcmV0dXJuIG5ldyBTbmFrZUdhbWUoe1xuICAgICAgcm93czogcm93cyxcbiAgICAgIGNvbHM6IGNvbHMsXG4gICAgfSkucGxhY2VTbmFrZSh7XG4gICAgICB4OiBNYXRoLmZsb29yKGNvbHMgLyAyKSxcbiAgICAgIHk6IE1hdGguZmxvb3Iocm93cyAvIDIpLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGlzRnVsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zbmFrZS5sZW5ndGggPj0gdGhpcy5yb3dzICogdGhpcy5jb2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGdpdmVuIHRpbGUgY2FuIGJlICpzYWZlbHkqIG1vdmVkIGludG8gYnkgdGhlIHNuYWtlXG4gICAqIFRoaXMgbWVhbnMgdGhhdCB0aGVyZSBpcyBubyBvdGhlciBwYXJ0IG9mIHRoZSBzbmFrZSBvbiB0aGlzIHRpbGVcbiAgICogYW5kIHRoYXQgdGhlIHBvc2l0aW9uIGlzIG5vdCBvdXQgb2YgYm91bmRzXG4gICAqL1xuICBpc1RyYXZlcnNhYmxlKHt4LCB5fSkge1xuICAgIHJldHVybiAhdGhpcy5pc091dE9mQm91bmRzKHt4LCB5fSkgJiYgIXRoaXMuaXNTbmFrZSh7eCwgeX0pO1xuICB9XG5cbiAgaXNTbmFrZSh7eCwgeX0pIHtcbiAgICByZXR1cm4gdGhpcy5zbmFrZS5jb250YWlucyh7eCwgeX0pO1xuICB9XG5cbiAgaXNHb2FsKHt4LCB5fSkge1xuICAgIHJldHVybiB0aGlzLmdvYWwgPyB0aGlzLmdvYWwuZXF1YWxzKG5ldyBWZWN0b3Ioe3gsIHl9KSkgOiBmYWxzZTtcbiAgfVxuXG4gIGlzT3V0T2ZCb3VuZHMoe3gsIHl9KSB7XG4gICAgcmV0dXJuIHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5jb2xzIHx8IHkgPj0gdGhpcy5yb3dzO1xuICB9XG5cbiAgcGxhY2VTbmFrZSh7eCwgeX0pIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJ3NuYWtlJywgU25ha2UuZnJvbVN0YXJ0UG9zaXRpb24oe3gsIHl9KSk7XG4gIH1cblxuICBwbGFjZVJhbmRvbUdvYWwoKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoJ2dvYWwnLCBudWxsKTtcbiAgICB9XG5cbiAgICBsZXQgZ29hbDtcbiAgICBkbyB7XG4gICAgICBnb2FsID0gbmV3IFZlY3Rvcih7XG4gICAgICAgIHg6IGNoYW5jZS5pbnRlZ2VyKHttaW46IDAsIG1heDogdGhpcy5jb2xzIC0gMX0pLFxuICAgICAgICB5OiBjaGFuY2UuaW50ZWdlcih7bWluOiAwLCBtYXg6IHRoaXMucm93cyAtIDF9KSxcbiAgICAgIH0pO1xuICAgIH0gd2hpbGUgKHRoaXMuaXNTbmFrZShnb2FsKSk7XG5cbiAgICByZXR1cm4gdGhpcy5wbGFjZUdvYWwoZ29hbCk7XG4gIH1cblxuICBwbGFjZUdvYWwoZ29hbCkge1xuICAgIHJldHVybiB0aGlzLnNldCgnZ29hbCcsIGdvYWwpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU25ha2VHYW1lO1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbHMvc25ha2VHYW1lLmpzeFxuICoqLyIsIi8vICBDaGFuY2UuanMgMS4wLjNcbi8vICBodHRwOi8vY2hhbmNlanMuY29tXG4vLyAgKGMpIDIwMTMgVmljdG9yIFF1aW5uXG4vLyAgQ2hhbmNlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgb3IgbW9kaWZpZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQ29uc3RhbnRzXG4gICAgdmFyIE1BWF9JTlQgPSA5MDA3MTk5MjU0NzQwOTkyO1xuICAgIHZhciBNSU5fSU5UID0gLU1BWF9JTlQ7XG4gICAgdmFyIE5VTUJFUlMgPSAnMDEyMzQ1Njc4OSc7XG4gICAgdmFyIENIQVJTX0xPV0VSID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcbiAgICB2YXIgQ0hBUlNfVVBQRVIgPSBDSEFSU19MT1dFUi50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBIRVhfUE9PTCAgPSBOVU1CRVJTICsgXCJhYmNkZWZcIjtcblxuICAgIC8vIENhY2hlZCBhcnJheSBoZWxwZXJzXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBDaGFuY2UgKHNlZWQpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENoYW5jZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWVkID09IG51bGwgPyBuZXcgQ2hhbmNlKCkgOiBuZXcgQ2hhbmNlKHNlZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdXNlciBoYXMgcHJvdmlkZWQgYSBmdW5jdGlvbiwgdXNlIHRoYXQgYXMgdGhlIGdlbmVyYXRvclxuICAgICAgICBpZiAodHlwZW9mIHNlZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZG9tID0gc2VlZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNldCBhIHN0YXJ0aW5nIHZhbHVlIG9mIHplcm8gc28gd2UgY2FuIGFkZCB0byBpdFxuICAgICAgICAgICAgdGhpcy5zZWVkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgbGVhdmUgdGhpcy5zZWVkIGJsYW5rIHNvIHRoYXQgTVQgd2lsbCByZWNlaXZlIGEgYmxhbmtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlZWRsaW5nID0gMDtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzW2ldKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyZ3VtZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBudW1lcmljIGhhc2ggZm9yIGVhY2ggYXJndW1lbnQsIGFkZCB0byBzZWVkbGluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXJndW1lbnRzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gYXJndW1lbnRzW2ldLmNoYXJDb2RlQXQoaykgKyAoaGFzaCA8PCA2KSArIChoYXNoIDw8IDE2KSAtIGhhc2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VlZGxpbmcgKz0gaGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlZWRsaW5nID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWVkICs9IChhcmd1bWVudHMubGVuZ3RoIC0gaSkgKiBzZWVkbGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGdlbmVyYXRvciBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIHVzZSBvdXIgTVRcbiAgICAgICAgdGhpcy5tdCA9IHRoaXMubWVyc2VubmVfdHdpc3Rlcih0aGlzLnNlZWQpO1xuICAgICAgICB0aGlzLmJpbWQ1ID0gdGhpcy5ibHVlaW1wX21kNSgpO1xuICAgICAgICB0aGlzLnJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm10LnJhbmRvbSh0aGlzLnNlZWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIENoYW5jZS5wcm90b3R5cGUuVkVSU0lPTiA9IFwiMS4wLjNcIjtcblxuICAgIC8vIFJhbmRvbSBoZWxwZXIgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gaW5pdE9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbaV0gPSBkZWZhdWx0c1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0UmFuZ2UodGVzdCwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGlmICh0ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBpbnB1dCBzdHJpbmcgd2l0aCBCYXNlNjQuXG4gICAgICovXG4gICAgdmFyIGJhc2U2NCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEJhc2U2NCBlbmNvZGVyIGF2YWlsYWJsZS4nKTtcbiAgICB9O1xuXG4gICAgLy8gU2VsZWN0IHByb3BlciBCYXNlNjQgZW5jb2Rlci5cbiAgICAoZnVuY3Rpb24gZGV0ZXJtaW5lQmFzZTY0RW5jb2RlcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSBidG9hO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGJhc2U2NCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoaW5wdXQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLy8gLS0gQmFzaWNzIC0tXG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgcmFuZG9tIGJvb2wsIGVpdGhlciB0cnVlIG9yIGZhbHNlXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXsgbGlrZWxpaG9vZDogNTAgfV0gYWx0ZXIgdGhlIGxpa2VsaWhvb2Qgb2ZcbiAgICAgKiAgICByZWNlaXZpbmcgYSB0cnVlIG9yIGZhbHNlIHZhbHVlIGJhY2suXG4gICAgICogIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGlmIHRoZSBsaWtlbGlob29kIGlzIG91dCBvZiBib3VuZHNcbiAgICAgKiAgQHJldHVybnMge0Jvb2x9IGVpdGhlciB0cnVlIG9yIGZhbHNlXG4gICAgICovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbGlrZWxpaG9vZCBvZiBzdWNjZXNzICh0cnVlKVxuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2xpa2VsaWhvb2QgOiA1MH0pO1xuXG4gICAgICAgIC8vIE5vdGUsIHdlIGNvdWxkIGdldCBzb21lIG1pbm9yIHBlcmYgb3B0aW1pemF0aW9ucyBieSBjaGVja2luZyByYW5nZVxuICAgICAgICAvLyBwcmlvciB0byBpbml0aWFsaXppbmcgZGVmYXVsdHMsIGJ1dCB0aGF0IG1ha2VzIGNvZGUgYSBiaXQgbWVzc2llclxuICAgICAgICAvLyBhbmQgdGhlIGNoZWNrIG1vcmUgY29tcGxpY2F0ZWQgYXMgd2UgaGF2ZSB0byBjaGVjayBleGlzdGVuY2Ugb2ZcbiAgICAgICAgLy8gdGhlIG9iamVjdCB0aGVuIGV4aXN0ZW5jZSBvZiB0aGUga2V5IGJlZm9yZSBjaGVja2luZyBjb25zdHJhaW50cy5cbiAgICAgICAgLy8gU2luY2UgdGhlIG9wdGlvbnMgaW5pdGlhbGl6YXRpb24gc2hvdWxkIGJlIG1pbm9yIGNvbXB1dGF0aW9uYWxseSxcbiAgICAgICAgLy8gZGVjaXNpb24gbWFkZSBmb3IgY29kZSBjbGVhbmxpbmVzcyBpbnRlbnRpb25hbGx5LiBUaGlzIGlzIG1lbnRpb25lZFxuICAgICAgICAvLyBoZXJlIGFzIGl0J3MgdGhlIGZpcnN0IG9jY3VycmVuY2UsIHdpbGwgbm90IGJlIG1lbnRpb25lZCBhZ2Fpbi5cbiAgICAgICAgdGVzdFJhbmdlKFxuICAgICAgICAgICAgb3B0aW9ucy5saWtlbGlob29kIDwgMCB8fCBvcHRpb25zLmxpa2VsaWhvb2QgPiAxMDAsXG4gICAgICAgICAgICBcIkNoYW5jZTogTGlrZWxpaG9vZCBhY2NlcHRzIHZhbHVlcyBmcm9tIDAgdG8gMTAwLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZG9tKCkgKiAxMDAgPCBvcHRpb25zLmxpa2VsaWhvb2Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSByYW5kb20gY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gY2FuIHNwZWNpZnkgYSBjaGFyYWN0ZXIgcG9vbCwgb25seSBhbHBoYSxcbiAgICAgKiAgICBvbmx5IHN5bWJvbHMsIGFuZCBjYXNpbmcgKGxvd2VyIG9yIHVwcGVyKVxuICAgICAqICBAcmV0dXJucyB7U3RyaW5nfSBhIHNpbmdsZSByYW5kb20gY2hhcmFjdGVyXG4gICAgICogIEB0aHJvd3Mge1JhbmdlRXJyb3J9IENhbiBvbmx5IHNwZWNpZnkgYWxwaGEgb3Igc3ltYm9scywgbm90IGJvdGhcbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLmNoYXJhY3RlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGVzdFJhbmdlKFxuICAgICAgICAgICAgb3B0aW9ucy5hbHBoYSAmJiBvcHRpb25zLnN5bWJvbHMsXG4gICAgICAgICAgICBcIkNoYW5jZTogQ2Fubm90IHNwZWNpZnkgYm90aCBhbHBoYSBhbmQgc3ltYm9scy5cIlxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBzeW1ib2xzID0gXCIhQCMkJV4mKigpW11cIixcbiAgICAgICAgICAgIGxldHRlcnMsIHBvb2w7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FzaW5nID09PSAnbG93ZXInKSB7XG4gICAgICAgICAgICBsZXR0ZXJzID0gQ0hBUlNfTE9XRVI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jYXNpbmcgPT09ICd1cHBlcicpIHtcbiAgICAgICAgICAgIGxldHRlcnMgPSBDSEFSU19VUFBFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldHRlcnMgPSBDSEFSU19MT1dFUiArIENIQVJTX1VQUEVSO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucG9vbCkge1xuICAgICAgICAgICAgcG9vbCA9IG9wdGlvbnMucG9vbDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFscGhhKSB7XG4gICAgICAgICAgICBwb29sID0gbGV0dGVycztcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnN5bWJvbHMpIHtcbiAgICAgICAgICAgIHBvb2wgPSBzeW1ib2xzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9vbCA9IGxldHRlcnMgKyBOVU1CRVJTICsgc3ltYm9scztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb29sLmNoYXJBdCh0aGlzLm5hdHVyYWwoe21heDogKHBvb2wubGVuZ3RoIC0gMSl9KSk7XG4gICAgfTtcblxuICAgIC8vIE5vdGUsIHdhbnRlZCB0byB1c2UgXCJmbG9hdFwiIG9yIFwiZG91YmxlXCIgYnV0IHRob3NlIGFyZSBib3RoIEpTIHJlc2VydmVkIHdvcmRzLlxuXG4gICAgLy8gTm90ZSwgZml4ZWQgbWVhbnMgTiBPUiBMRVNTIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbC4gVGhpcyBiZWNhdXNlXG4gICAgLy8gSXQgY291bGQgYmUgMTQuOTAwMCBidXQgaW4gSmF2YVNjcmlwdCwgd2hlbiB0aGlzIGlzIGNhc3QgYXMgYSBudW1iZXIsXG4gICAgLy8gdGhlIHRyYWlsaW5nIHplcm9lcyBhcmUgZHJvcHBlZC4gTGVmdCB0byB0aGUgY29uc3VtZXIgaWYgdHJhaWxpbmcgemVyb2VzIGFyZVxuICAgIC8vIG5lZWRlZFxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSByYW5kb20gZmxvYXRpbmcgcG9pbnQgbnVtYmVyXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBjYW4gc3BlY2lmeSBhIGZpeGVkIHByZWNpc2lvbiwgbWluLCBtYXhcbiAgICAgKiAgQHJldHVybnMge051bWJlcn0gYSBzaW5nbGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyXG4gICAgICogIEB0aHJvd3Mge1JhbmdlRXJyb3J9IENhbiBvbmx5IHNwZWNpZnkgZml4ZWQgb3IgcHJlY2lzaW9uLCBub3QgYm90aC4gQWxzb1xuICAgICAqICAgIG1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG1heFxuICAgICAqL1xuICAgIENoYW5jZS5wcm90b3R5cGUuZmxvYXRpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2ZpeGVkIDogNH0pO1xuICAgICAgICB0ZXN0UmFuZ2UoXG4gICAgICAgICAgICBvcHRpb25zLmZpeGVkICYmIG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgXCJDaGFuY2U6IENhbm5vdCBzcGVjaWZ5IGJvdGggZml4ZWQgYW5kIHByZWNpc2lvbi5cIlxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBudW07XG4gICAgICAgIHZhciBmaXhlZCA9IE1hdGgucG93KDEwLCBvcHRpb25zLmZpeGVkKTtcblxuICAgICAgICB2YXIgbWF4ID0gTUFYX0lOVCAvIGZpeGVkO1xuICAgICAgICB2YXIgbWluID0gLW1heDtcblxuICAgICAgICB0ZXN0UmFuZ2UoXG4gICAgICAgICAgICBvcHRpb25zLm1pbiAmJiBvcHRpb25zLmZpeGVkICYmIG9wdGlvbnMubWluIDwgbWluLFxuICAgICAgICAgICAgXCJDaGFuY2U6IE1pbiBzcGVjaWZpZWQgaXMgb3V0IG9mIHJhbmdlIHdpdGggZml4ZWQuIE1pbiBzaG91bGQgYmUsIGF0IGxlYXN0LCBcIiArIG1pblxuICAgICAgICApO1xuICAgICAgICB0ZXN0UmFuZ2UoXG4gICAgICAgICAgICBvcHRpb25zLm1heCAmJiBvcHRpb25zLmZpeGVkICYmIG9wdGlvbnMubWF4ID4gbWF4LFxuICAgICAgICAgICAgXCJDaGFuY2U6IE1heCBzcGVjaWZpZWQgaXMgb3V0IG9mIHJhbmdlIHdpdGggZml4ZWQuIE1heCBzaG91bGQgYmUsIGF0IG1vc3QsIFwiICsgbWF4XG4gICAgICAgICk7XG5cbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHsgbWluIDogbWluLCBtYXggOiBtYXggfSk7XG5cbiAgICAgICAgLy8gVG9kbyAtIE1ha2UgdGhpcyB3b3JrIVxuICAgICAgICAvLyBvcHRpb25zLnByZWNpc2lvbiA9ICh0eXBlb2Ygb3B0aW9ucy5wcmVjaXNpb24gIT09IFwidW5kZWZpbmVkXCIpID8gb3B0aW9ucy5wcmVjaXNpb24gOiBmYWxzZTtcblxuICAgICAgICBudW0gPSB0aGlzLmludGVnZXIoe21pbjogb3B0aW9ucy5taW4gKiBmaXhlZCwgbWF4OiBvcHRpb25zLm1heCAqIGZpeGVkfSk7XG4gICAgICAgIHZhciBudW1fZml4ZWQgPSAobnVtIC8gZml4ZWQpLnRvRml4ZWQob3B0aW9ucy5maXhlZCk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtX2ZpeGVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyXG4gICAgICpcbiAgICAgKiAgTk9URSB0aGUgbWF4IGFuZCBtaW4gYXJlIElOQ0xVREVEIGluIHRoZSByYW5nZS4gU286XG4gICAgICogIGNoYW5jZS5pbnRlZ2VyKHttaW46IDEsIG1heDogM30pO1xuICAgICAqICB3b3VsZCByZXR1cm4gZWl0aGVyIDEsIDIsIG9yIDMuXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBjYW4gc3BlY2lmeSBhIG1pbiBhbmQvb3IgbWF4XG4gICAgICogIEByZXR1cm5zIHtOdW1iZXJ9IGEgc2luZ2xlIHJhbmRvbSBpbnRlZ2VyIG51bWJlclxuICAgICAqICBAdGhyb3dzIHtSYW5nZUVycm9yfSBtaW4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXhcbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLmludGVnZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyA5MDA3MTk5MjU0NzQwOTkyICgyXjUzKSBpcyB0aGUgbWF4IGludGVnZXIgbnVtYmVyIGluIEphdmFTY3JpcHRcbiAgICAgICAgLy8gU2VlOiBodHRwOi8vdnEuaW8vMTMyc2EyalxuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge21pbjogTUlOX0lOVCwgbWF4OiBNQVhfSU5UfSk7XG4gICAgICAgIHRlc3RSYW5nZShvcHRpb25zLm1pbiA+IG9wdGlvbnMubWF4LCBcIkNoYW5jZTogTWluIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gTWF4LlwiKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnJhbmRvbSgpICogKG9wdGlvbnMubWF4IC0gb3B0aW9ucy5taW4gKyAxKSArIG9wdGlvbnMubWluKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHJhbmRvbSBuYXR1cmFsXG4gICAgICpcbiAgICAgKiAgTk9URSB0aGUgbWF4IGFuZCBtaW4gYXJlIElOQ0xVREVEIGluIHRoZSByYW5nZS4gU286XG4gICAgICogIGNoYW5jZS5uYXR1cmFsKHttaW46IDEsIG1heDogM30pO1xuICAgICAqICB3b3VsZCByZXR1cm4gZWl0aGVyIDEsIDIsIG9yIDMuXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBjYW4gc3BlY2lmeSBhIG1pbiBhbmQvb3IgbWF4XG4gICAgICogIEByZXR1cm5zIHtOdW1iZXJ9IGEgc2luZ2xlIHJhbmRvbSBpbnRlZ2VyIG51bWJlclxuICAgICAqICBAdGhyb3dzIHtSYW5nZUVycm9yfSBtaW4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXhcbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLm5hdHVyYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge21pbjogMCwgbWF4OiBNQVhfSU5UfSk7XG4gICAgICAgIHRlc3RSYW5nZShvcHRpb25zLm1pbiA8IDAsIFwiQ2hhbmNlOiBNaW4gY2Fubm90IGJlIGxlc3MgdGhhbiB6ZXJvLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcihvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHJhbmRvbSBzdHJpbmdcbiAgICAgKlxuICAgICAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIGNhbiBzcGVjaWZ5IGEgbGVuZ3RoXG4gICAgICogIEByZXR1cm5zIHtTdHJpbmd9IGEgc3RyaW5nIG9mIHJhbmRvbSBsZW5ndGhcbiAgICAgKiAgQHRocm93cyB7UmFuZ2VFcnJvcn0gbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYW4gemVyb1xuICAgICAqL1xuICAgIENoYW5jZS5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHsgbGVuZ3RoOiB0aGlzLm5hdHVyYWwoe21pbjogNSwgbWF4OiAyMH0pIH0pO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5sZW5ndGggPCAwLCBcIkNoYW5jZTogTGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYW4gemVyby5cIik7XG4gICAgICAgIHZhciBsZW5ndGggPSBvcHRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLm4odGhpcy5jaGFyYWN0ZXIsIGxlbmd0aCwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbiAgICB9O1xuXG4gICAgLy8gLS0gRW5kIEJhc2ljcyAtLVxuXG4gICAgLy8gLS0gSGVscGVycyAtLVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jYXBpdGFsaXplID0gZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnN1YnN0cigxKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5taXhpbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgZm9yICh2YXIgZnVuY19uYW1lIGluIG9iaikge1xuICAgICAgICAgICAgQ2hhbmNlLnByb3RvdHlwZVtmdW5jX25hbWVdID0gb2JqW2Z1bmNfbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHNvbWV0aGluZyByYW5kb20gYW5kIGEgbnVtYmVyIG9mIGl0ZW1zIHRvIGdlbmVyYXRlLFxuICAgICAqICAgIHJldHVybiBhbiBhcnJheSBvZiBpdGVtcyB3aGVyZSBub25lIHJlcGVhdC5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgc29tZXRoaW5nIHJhbmRvbVxuICAgICAqICBAcGFyYW0ge051bWJlcn0gbnVtIG51bWJlciBvZiB0ZXJtcyB0byBnZW5lcmF0ZVxuICAgICAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbnkgb3B0aW9ucyB0byBwYXNzIG9uIHRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb25cbiAgICAgKiAgQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBsZW5ndGggYG51bWAgd2l0aCBldmVyeSBpdGVtIGdlbmVyYXRlZCBieSBgZm5gIGFuZCB1bmlxdWVcbiAgICAgKlxuICAgICAqICBUaGVyZSBjYW4gYmUgbW9yZSBwYXJhbWV0ZXJzIGFmdGVyIHRoZXNlLiBBbGwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZCB0byB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLnVuaXF1ZSA9IGZ1bmN0aW9uKGZuLCBudW0sIG9wdGlvbnMpIHtcbiAgICAgICAgdGVzdFJhbmdlKFxuICAgICAgICAgICAgdHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBcIkNoYW5jZTogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbi5cIlxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gZnVuY3Rpb24oYXJyLCB2YWwpIHsgcmV0dXJuIGFyci5pbmRleE9mKHZhbCkgIT09IC0xOyB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yIHx8IGNvbXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJyID0gW10sIGNvdW50ID0gMCwgcmVzdWx0LCBNQVhfRFVQTElDQVRFUyA9IG51bSAqIDUwLCBwYXJhbXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cbiAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWRQYXJhbXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcmFtcykpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgY2xvbmVkUGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghY29tcGFyYXRvcihhcnIsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGNvdW50IHdoZW4gdW5pcXVlIGZvdW5kXG4gICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKytjb3VudCA+IE1BWF9EVVBMSUNBVEVTKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDaGFuY2U6IG51bSBpcyBsaWtlbHkgdG9vIGxhcmdlIGZvciBzYW1wbGUgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBHaXZlcyBhbiBhcnJheSBvZiBuIHJhbmRvbSB0ZXJtc1xuICAgICAqXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBzb21ldGhpbmcgcmFuZG9tXG4gICAgICogIEBwYXJhbSB7TnVtYmVyfSBuIG51bWJlciBvZiB0ZXJtcyB0byBnZW5lcmF0ZVxuICAgICAqICBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGxlbmd0aCBgbmAgd2l0aCBpdGVtcyBnZW5lcmF0ZWQgYnkgYGZuYFxuICAgICAqXG4gICAgICogIFRoZXJlIGNhbiBiZSBtb3JlIHBhcmFtZXRlcnMgYWZ0ZXIgdGhlc2UuIEFsbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkIHRvIHRoZSBnaXZlbiBmdW5jdGlvblxuICAgICAqL1xuICAgIENoYW5jZS5wcm90b3R5cGUubiA9IGZ1bmN0aW9uKGZuLCBuKSB7XG4gICAgICAgIHRlc3RSYW5nZShcbiAgICAgICAgICAgIHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgXCJDaGFuY2U6IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24uXCJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIG4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBuID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IG4sIGFyciA9IFtdLCBwYXJhbXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cbiAgICAgICAgLy8gUHJvdmlkaW5nIGEgbmVnYXRpdmUgY291bnQgc2hvdWxkIHJlc3VsdCBpbiBhIG5vb3AuXG4gICAgICAgIGkgPSBNYXRoLm1heCggMCwgaSApO1xuXG4gICAgICAgIGZvciAobnVsbDsgaS0tOyBudWxsKSB7XG4gICAgICAgICAgICBhcnIucHVzaChmbi5hcHBseSh0aGlzLCBwYXJhbXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIC8vIEgvVCB0byBTTyBmb3IgdGhpcyBvbmU6IGh0dHA6Ly92cS5pby9PdFVyWjVcbiAgICBDaGFuY2UucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uIChudW1iZXIsIHdpZHRoLCBwYWQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBwYWQgdG8gMCBpZiBub25lIHByb3ZpZGVkXG4gICAgICAgIHBhZCA9IHBhZCB8fCAnMCc7XG4gICAgICAgIC8vIENvbnZlcnQgbnVtYmVyIHRvIGEgc3RyaW5nXG4gICAgICAgIG51bWJlciA9IG51bWJlciArICcnO1xuICAgICAgICByZXR1cm4gbnVtYmVyLmxlbmd0aCA+PSB3aWR0aCA/IG51bWJlciA6IG5ldyBBcnJheSh3aWR0aCAtIG51bWJlci5sZW5ndGggKyAxKS5qb2luKHBhZCkgKyBudW1iZXI7XG4gICAgfTtcblxuICAgIC8vIERFUFJFQ0FURUQgb24gMjAxNS0xMC0wMVxuICAgIENoYW5jZS5wcm90b3R5cGUucGljayA9IGZ1bmN0aW9uIChhcnIsIGNvdW50KSB7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNoYW5jZTogQ2Fubm90IHBpY2soKSBmcm9tIGFuIGVtcHR5IGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY291bnQgfHwgY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJbdGhpcy5uYXR1cmFsKHttYXg6IGFyci5sZW5ndGggLSAxfSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2h1ZmZsZShhcnIpLnNsaWNlKDAsIGNvdW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBHaXZlbiBhbiBhcnJheSwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudFxuICAgIENoYW5jZS5wcm90b3R5cGUucGlja29uZSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNoYW5jZTogQ2Fubm90IHBpY2tvbmUoKSBmcm9tIGFuIGVtcHR5IGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJbdGhpcy5uYXR1cmFsKHttYXg6IGFyci5sZW5ndGggLSAxfSldO1xuICAgIH07XG5cbiAgICAvLyBHaXZlbiBhbiBhcnJheSwgcmV0dXJucyBhIHJhbmRvbSBzZXQgd2l0aCAnY291bnQnIGVsZW1lbnRzXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5waWNrc2V0ID0gZnVuY3Rpb24gKGFyciwgY291bnQpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2hhbmNlOiBDYW5ub3QgcGlja3NldCgpIGZyb20gYW4gZW1wdHkgYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDaGFuY2U6IGNvdW50IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY291bnQgfHwgY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbIHRoaXMucGlja29uZShhcnIpIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaHVmZmxlKGFycikuc2xpY2UoMCwgY291bnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgdmFyIG9sZF9hcnJheSA9IGFyci5zbGljZSgwKSxcbiAgICAgICAgICAgIG5ld19hcnJheSA9IFtdLFxuICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBOdW1iZXIob2xkX2FycmF5Lmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gUGljayBhIHJhbmRvbSBpbmRleCBmcm9tIHRoZSBhcnJheVxuICAgICAgICAgICAgaiA9IHRoaXMubmF0dXJhbCh7bWF4OiBvbGRfYXJyYXkubGVuZ3RoIC0gMX0pO1xuICAgICAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBuZXcgYXJyYXlcbiAgICAgICAgICAgIG5ld19hcnJheVtpXSA9IG9sZF9hcnJheVtqXTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGF0IGVsZW1lbnQgZnJvbSB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICAgICAgICAgIG9sZF9hcnJheS5zcGxpY2UoaiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3X2FycmF5O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGEgc2luZ2xlIGl0ZW0gZnJvbSBhbiBhcnJheSB3aXRoIHJlbGF0aXZlIHdlaWdodGluZyBvZiBvZGRzXG4gICAgQ2hhbmNlLnByb3RvdHlwZS53ZWlnaHRlZCA9IGZ1bmN0aW9uIChhcnIsIHdlaWdodHMsIHRyaW0pIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggIT09IHdlaWdodHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNoYW5jZTogbGVuZ3RoIG9mIGFycmF5IGFuZCB3ZWlnaHRzIG11c3QgbWF0Y2hcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FuIHdlaWdodHMgYXJyYXkgYW5kIHN1bSB2YWxpZCBlbnRyaWVzXG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgdmFsO1xuICAgICAgICBmb3IgKHZhciB3ZWlnaHRJbmRleCA9IDA7IHdlaWdodEluZGV4IDwgd2VpZ2h0cy5sZW5ndGg7ICsrd2VpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhbCA9IHdlaWdodHNbd2VpZ2h0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1bSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDaGFuY2U6IG5vIHZhbGlkIGVudHJpZXMgaW4gYXJyYXkgd2VpZ2h0c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlbGVjdCBhIHZhbHVlIHdpdGhpbiByYW5nZVxuICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLnJhbmRvbSgpICogc3VtO1xuXG4gICAgICAgIC8vIGZpbmQgYXJyYXkgZW50cnkgY29ycmVzcG9uZGluZyB0byBzZWxlY3RlZCB2YWx1ZVxuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICB2YXIgbGFzdEdvb2RJZHggPSAtMTtcbiAgICAgICAgdmFyIGNob3NlbklkeDtcbiAgICAgICAgZm9yICh3ZWlnaHRJbmRleCA9IDA7IHdlaWdodEluZGV4IDwgd2VpZ2h0cy5sZW5ndGg7ICsrd2VpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhbCA9IHdlaWdodHNbd2VpZ2h0SW5kZXhdO1xuICAgICAgICAgICAgdG90YWwgKz0gdmFsO1xuICAgICAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPD0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvc2VuSWR4ID0gd2VpZ2h0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0R29vZElkeCA9IHdlaWdodEluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgYW55IHBvc3NpYmxlIHJvdW5kaW5nIGVycm9yIGNvbXBhcmlzb24gdG8gZW5zdXJlIHNvbWV0aGluZyBpcyBwaWNrZWRcbiAgICAgICAgICAgIGlmICh3ZWlnaHRJbmRleCA9PT0gKHdlaWdodHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICBjaG9zZW5JZHggPSBsYXN0R29vZElkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaG9zZW4gPSBhcnJbY2hvc2VuSWR4XTtcbiAgICAgICAgdHJpbSA9ICh0eXBlb2YgdHJpbSA9PT0gJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiB0cmltO1xuICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShjaG9zZW5JZHgsIDEpO1xuICAgICAgICAgICAgd2VpZ2h0cy5zcGxpY2UoY2hvc2VuSWR4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9zZW47XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBIZWxwZXJzIC0tXG5cbiAgICAvLyAtLSBUZXh0IC0tXG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB2YXIgc2VudGVuY2VzID0gb3B0aW9ucy5zZW50ZW5jZXMgfHwgdGhpcy5uYXR1cmFsKHttaW46IDMsIG1heDogN30pLFxuICAgICAgICAgICAgc2VudGVuY2VfYXJyYXkgPSB0aGlzLm4odGhpcy5zZW50ZW5jZSwgc2VudGVuY2VzKTtcblxuICAgICAgICByZXR1cm4gc2VudGVuY2VfYXJyYXkuam9pbignICcpO1xuICAgIH07XG5cbiAgICAvLyBDb3VsZCBnZXQgc21hcnRlciBhYm91dCB0aGlzIHRoYW4gZ2VuZXJhdGluZyByYW5kb20gd29yZHMgYW5kXG4gICAgLy8gY2hhaW5pbmcgdGhlbSB0b2dldGhlci4gU3VjaCBhczogaHR0cDovL3ZxLmlvLzFhNWNlT2hcbiAgICBDaGFuY2UucHJvdG90eXBlLnNlbnRlbmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB3b3JkcyA9IG9wdGlvbnMud29yZHMgfHwgdGhpcy5uYXR1cmFsKHttaW46IDEyLCBtYXg6IDE4fSksXG4gICAgICAgICAgICBwdW5jdHVhdGlvbiA9IG9wdGlvbnMucHVuY3R1YXRpb24sXG4gICAgICAgICAgICB0ZXh0LCB3b3JkX2FycmF5ID0gdGhpcy5uKHRoaXMud29yZCwgd29yZHMpO1xuXG4gICAgICAgIHRleHQgPSB3b3JkX2FycmF5LmpvaW4oJyAnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIHNlbnRlbmNlXG4gICAgICAgIHRleHQgPSB0aGlzLmNhcGl0YWxpemUodGV4dCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgcHVuY3R1YXRpb24gaGFzIGEgdXNhYmxlIHZhbHVlXG4gICAgICAgIGlmIChwdW5jdHVhdGlvbiAhPT0gZmFsc2UgJiYgIS9eW1xcLlxcPzshOl0kLy50ZXN0KHB1bmN0dWF0aW9uKSkge1xuICAgICAgICAgICAgcHVuY3R1YXRpb24gPSAnLic7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBwdW5jdHVhdGlvbiBtYXJrXG4gICAgICAgIGlmIChwdW5jdHVhdGlvbikge1xuICAgICAgICAgICAgdGV4dCArPSBwdW5jdHVhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnN5bGxhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCB0aGlzLm5hdHVyYWwoe21pbjogMiwgbWF4OiAzfSksXG4gICAgICAgICAgICBjb25zb25hbnRzID0gJ2JjZGZnaGprbG1ucHJzdHZ3eicsIC8vIGNvbnNvbmFudHMgZXhjZXB0IGhhcmQgdG8gc3BlYWsgb25lc1xuICAgICAgICAgICAgdm93ZWxzID0gJ2FlaW91JywgLy8gdm93ZWxzXG4gICAgICAgICAgICBhbGwgPSBjb25zb25hbnRzICsgdm93ZWxzLCAvLyBhbGxcbiAgICAgICAgICAgIHRleHQgPSAnJyxcbiAgICAgICAgICAgIGNocjtcblxuICAgICAgICAvLyBJJ20gc3VyZSB0aGVyZSdzIGEgbW9yZSBlbGVnYW50IHdheSB0byBkbyB0aGlzLCBidXQgdGhpcyB3b3Jrc1xuICAgICAgICAvLyBkZWNlbnRseSB3ZWxsLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGNoYXJhY3RlciBjYW4gYmUgYW55dGhpbmdcbiAgICAgICAgICAgICAgICBjaHIgPSB0aGlzLmNoYXJhY3Rlcih7cG9vbDogYWxsfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbmFudHMuaW5kZXhPZihjaHIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIExhc3QgY2hhcmFjdGVyIHdhcyBhIHZvd2VsLCBub3cgd2Ugd2FudCBhIGNvbnNvbmFudFxuICAgICAgICAgICAgICAgIGNociA9IHRoaXMuY2hhcmFjdGVyKHtwb29sOiBjb25zb25hbnRzfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExhc3QgY2hhcmFjdGVyIHdhcyBhIGNvbnNvbmFudCwgbm93IHdlIHdhbnQgYSB2b3dlbFxuICAgICAgICAgICAgICAgIGNociA9IHRoaXMuY2hhcmFjdGVyKHtwb29sOiB2b3dlbHN9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dCArPSBjaHI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5jYXBpdGFsaXplKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5jYXBpdGFsaXplKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUud29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB0ZXN0UmFuZ2UoXG4gICAgICAgICAgICBvcHRpb25zLnN5bGxhYmxlcyAmJiBvcHRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIFwiQ2hhbmNlOiBDYW5ub3Qgc3BlY2lmeSBib3RoIHN5bGxhYmxlcyBBTkQgbGVuZ3RoLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHN5bGxhYmxlcyA9IG9wdGlvbnMuc3lsbGFibGVzIHx8IHRoaXMubmF0dXJhbCh7bWluOiAxLCBtYXg6IDN9KSxcbiAgICAgICAgICAgIHRleHQgPSAnJztcblxuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEVpdGhlciBib3VuZCB3b3JkIGJ5IGxlbmd0aFxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdGhpcy5zeWxsYWJsZSgpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGV4dC5sZW5ndGggPCBvcHRpb25zLmxlbmd0aCk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgb3B0aW9ucy5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3IgYnkgbnVtYmVyIG9mIHN5bGxhYmxlc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeWxsYWJsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdGhpcy5zeWxsYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FwaXRhbGl6ZSkge1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuY2FwaXRhbGl6ZSh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgVGV4dCAtLVxuXG4gICAgLy8gLS0gUGVyc29uIC0tXG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGFnZVJhbmdlO1xuXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjaGlsZCc6XG4gICAgICAgICAgICAgICAgYWdlUmFuZ2UgPSB7bWluOiAxLCBtYXg6IDEyfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RlZW4nOlxuICAgICAgICAgICAgICAgIGFnZVJhbmdlID0ge21pbjogMTMsIG1heDogMTl9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWR1bHQnOlxuICAgICAgICAgICAgICAgIGFnZVJhbmdlID0ge21pbjogMTgsIG1heDogNjV9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VuaW9yJzpcbiAgICAgICAgICAgICAgICBhZ2VSYW5nZSA9IHttaW46IDY1LCBtYXg6IDEwMH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgICAgICAgIGFnZVJhbmdlID0ge21pbjogMSwgbWF4OiAxMDB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhZ2VSYW5nZSA9IHttaW46IDE4LCBtYXg6IDY1fTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm5hdHVyYWwoYWdlUmFuZ2UpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmJpcnRoZGF5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHllYXI6IChuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSB0aGlzLmFnZShvcHRpb25zKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLy8gQ1BGOyBJRCB0byBpZGVudGlmeSB0YXhwYXllcnMgaW4gQnJhemlsXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jcGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5uKHRoaXMubmF0dXJhbCwgOSwgeyBtYXg6IDkgfSk7XG4gICAgICAgIHZhciBkMSA9IG5bOF0qMituWzddKjMrbls2XSo0K25bNV0qNStuWzRdKjYrblszXSo3K25bMl0qOCtuWzFdKjkrblswXSoxMDtcbiAgICAgICAgZDEgPSAxMSAtIChkMSAlIDExKTtcbiAgICAgICAgaWYgKGQxPj0xMCkge1xuICAgICAgICAgICAgZDEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkMiA9IGQxKjIrbls4XSozK25bN10qNCtuWzZdKjUrbls1XSo2K25bNF0qNytuWzNdKjgrblsyXSo5K25bMV0qMTArblswXSoxMTtcbiAgICAgICAgZDIgPSAxMSAtIChkMiAlIDExKTtcbiAgICAgICAgaWYgKGQyPj0xMCkge1xuICAgICAgICAgICAgZDIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJytuWzBdK25bMV0rblsyXSsnLicrblszXStuWzRdK25bNV0rJy4nK25bNl0rbls3XStuWzhdKyctJytkMStkMjtcbiAgICB9O1xuXG4gICAgLy8gQ05QSjogSUQgdG8gaWRlbnRpZnkgY29tcGFuaWVzIGluIEJyYXppbFxuICAgIENoYW5jZS5wcm90b3R5cGUuY25waiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLm4odGhpcy5uYXR1cmFsLCAxMiwgeyBtYXg6IDEyIH0pO1xuICAgICAgICB2YXIgZDEgPSBuWzExXSoyK25bMTBdKjMrbls5XSo0K25bOF0qNStuWzddKjYrbls2XSo3K25bNV0qOCtuWzRdKjkrblszXSoyK25bMl0qMytuWzFdKjQrblswXSo1O1xuICAgICAgICBkMSA9IDExIC0gKGQxICUgMTEpO1xuICAgICAgICBpZiAoZDE8Mikge1xuICAgICAgICAgICAgZDEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkMiA9IGQxKjIrblsxMV0qMytuWzEwXSo0K25bOV0qNStuWzhdKjYrbls3XSo3K25bNl0qOCtuWzVdKjkrbls0XSoyK25bM10qMytuWzJdKjQrblsxXSo1K25bMF0qNjtcbiAgICAgICAgZDIgPSAxMSAtIChkMiAlIDExKTtcbiAgICAgICAgaWYgKGQyPDIpIHtcbiAgICAgICAgICAgIGQyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJycrblswXStuWzFdKycuJytuWzJdK25bM10rbls0XSsnLicrbls1XStuWzZdK25bN10rJy8nK25bOF0rbls5XStuWzEwXStuWzExXSsnLScrZDErZDI7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2dlbmRlcjogdGhpcy5nZW5kZXIoKSwgbmF0aW9uYWxpdHk6ICdlbid9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGljayh0aGlzLmdldChcImZpcnN0TmFtZXNcIilbb3B0aW9ucy5nZW5kZXIudG9Mb3dlckNhc2UoKV1bb3B0aW9ucy5uYXRpb25hbGl0eS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZ2VuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrKFsnTWFsZScsICdGZW1hbGUnXSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7bmF0aW9uYWxpdHk6ICdlbid9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGljayh0aGlzLmdldChcImxhc3ROYW1lc1wiKVtvcHRpb25zLm5hdGlvbmFsaXR5LnRvTG93ZXJDYXNlKCldKTtcbiAgICB9O1xuICAgIFxuICAgIENoYW5jZS5wcm90b3R5cGUuaXNyYWVsSWQ9ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHg9dGhpcy5zdHJpbmcoe3Bvb2w6ICcwMTIzNDU2Nzg5JyxsZW5ndGg6OH0pO1xuICAgICAgICB2YXIgeT0wO1xuICAgICAgICBmb3IgKHZhciBpPTA7aTx4Lmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgdmFyIHRoaXNEaWdpdD0gIHhbaV0gKiAgKGkvMj09PXBhcnNlSW50KGkvMikgPyAxIDogMik7XG4gICAgICAgICAgICB0aGlzRGlnaXQ9dGhpcy5wYWQodGhpc0RpZ2l0LDIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzRGlnaXQ9cGFyc2VJbnQodGhpc0RpZ2l0WzBdKSArIHBhcnNlSW50KHRoaXNEaWdpdFsxXSk7XG4gICAgICAgICAgICB5PXkrdGhpc0RpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIHg9eCsoMTAtcGFyc2VJbnQoeS50b1N0cmluZygpLnNsaWNlKC0xKSkpLnRvU3RyaW5nKCkuc2xpY2UoLTEpO1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5tcnogPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgY2hlY2tEaWdpdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gXCI8QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVhaXCIuc3BsaXQoJycpLFxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXJzID0gWyA3LCAzLCAxIF0sXG4gICAgICAgICAgICAgICAgcnVubmluZ1RvdGFsID0gMDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlucHV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGNoYXJhY3RlciwgaWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGFscGhhLmluZGV4T2YoY2hhcmFjdGVyKTtcblxuICAgICAgICAgICAgICAgIGlmKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyID0gcG9zID09PSAwID8gMCA6IHBvcyArIDk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyID0gcGFyc2VJbnQoY2hhcmFjdGVyLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJhY3RlciAqPSBtdWx0aXBsaWVyc1tpZHggJSBtdWx0aXBsaWVycy5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdUb3RhbCArPSBjaGFyYWN0ZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nVG90YWwgJSAxMDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdlbmVyYXRlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBwYWQgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShsZW5ndGggKyAxKS5qb2luKCc8Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IFsgJ1A8JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuaXNzdWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5sYXN0LnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnPDwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5maXJzdC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkKDM5IC0gKG9wdHMubGFzdC5sZW5ndGggKyBvcHRzLmZpcnN0Lmxlbmd0aCArIDIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMucGFzc3BvcnROdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0RpZ2l0KG9wdHMucGFzc3BvcnROdW1iZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5uYXRpb25hbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZG9iLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tEaWdpdChvcHRzLmRvYiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmdlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZXhwaXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tEaWdpdChvcHRzLmV4cGlyeSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwYWQoMTQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tEaWdpdChwYWQoMTQpKSBdLmpvaW4oJycpO1xuXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICtcbiAgICAgICAgICAgICAgICAoY2hlY2tEaWdpdChudW1iZXIuc3Vic3RyKDQ0LCAxMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlci5zdWJzdHIoNTcsIDcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIuc3Vic3RyKDY1LCA3KSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QoKSxcbiAgICAgICAgICAgIGxhc3Q6IHRoaXMubGFzdCgpLFxuICAgICAgICAgICAgcGFzc3BvcnROdW1iZXI6IHRoaXMuaW50ZWdlcih7bWluOiAxMDAwMDAwMDAsIG1heDogOTk5OTk5OTk5fSksXG4gICAgICAgICAgICBkb2I6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGF0LmJpcnRoZGF5KHt0eXBlOiAnYWR1bHQnfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtkYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKS5zdWJzdHIoMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFkKGRhdGUuZ2V0RGF0ZSgpLCAyKV0uam9pbignJyk7XG4gICAgICAgICAgICB9KCkpLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyhkYXRlLmdldEZ1bGxZZWFyKCkgKyA1KS50b1N0cmluZygpLnN1YnN0cigyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFkKGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wYWQoZGF0ZS5nZXREYXRlKCksIDIpXS5qb2luKCcnKTtcbiAgICAgICAgICAgIH0oKSksXG4gICAgICAgICAgICBnZW5kZXI6IHRoaXMuZ2VuZGVyKCkgPT09ICdGZW1hbGUnID8gJ0YnOiAnTScsXG4gICAgICAgICAgICBpc3N1ZXI6ICdHQlInLFxuICAgICAgICAgICAgbmF0aW9uYWxpdHk6ICdHQlInXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGUgKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5maXJzdChvcHRpb25zKSxcbiAgICAgICAgICAgIGxhc3QgPSB0aGlzLmxhc3Qob3B0aW9ucyksXG4gICAgICAgICAgICBuYW1lO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm1pZGRsZSkge1xuICAgICAgICAgICAgbmFtZSA9IGZpcnN0ICsgJyAnICsgdGhpcy5maXJzdChvcHRpb25zKSArICcgJyArIGxhc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5taWRkbGVfaW5pdGlhbCkge1xuICAgICAgICAgICAgbmFtZSA9IGZpcnN0ICsgJyAnICsgdGhpcy5jaGFyYWN0ZXIoe2FscGhhOiB0cnVlLCBjYXNpbmc6ICd1cHBlcid9KSArICcuICcgKyBsYXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IGZpcnN0ICsgJyAnICsgbGFzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeCkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMucHJlZml4KG9wdGlvbnMpICsgJyAnICsgbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnN1ZmZpeCkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUgKyAnICcgKyB0aGlzLnN1ZmZpeChvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIG5hbWUgcHJlZml4ZXMgYmFzZWQgb24gc3VwcGxpZWQgZ2VuZGVyLlxuICAgIC8vIEB0b2RvIGludHJvZHVjZSBpbnRlcm5hdGlvbmFsaXphdGlvblxuICAgIENoYW5jZS5wcm90b3R5cGUubmFtZV9wcmVmaXhlcyA9IGZ1bmN0aW9uIChnZW5kZXIpIHtcbiAgICAgICAgZ2VuZGVyID0gZ2VuZGVyIHx8IFwiYWxsXCI7XG4gICAgICAgIGdlbmRlciA9IGdlbmRlci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHZhciBwcmVmaXhlcyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ0RvY3RvcicsIGFiYnJldmlhdGlvbjogJ0RyLicgfVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChnZW5kZXIgPT09IFwibWFsZVwiIHx8IGdlbmRlciA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgcHJlZml4ZXMucHVzaCh7IG5hbWU6ICdNaXN0ZXInLCBhYmJyZXZpYXRpb246ICdNci4nIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlbmRlciA9PT0gXCJmZW1hbGVcIiB8fCBnZW5kZXIgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIHByZWZpeGVzLnB1c2goeyBuYW1lOiAnTWlzcycsIGFiYnJldmlhdGlvbjogJ01pc3MnIH0pO1xuICAgICAgICAgICAgcHJlZml4ZXMucHVzaCh7IG5hbWU6ICdNaXNzZXMnLCBhYmJyZXZpYXRpb246ICdNcnMuJyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmVmaXhlcztcbiAgICB9O1xuXG4gICAgLy8gQWxpYXMgZm9yIG5hbWVfcHJlZml4XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5wcmVmaXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lX3ByZWZpeChvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5uYW1lX3ByZWZpeCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGdlbmRlcjogXCJhbGxcIiB9KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZnVsbCA/XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5uYW1lX3ByZWZpeGVzKG9wdGlvbnMuZ2VuZGVyKSkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5uYW1lX3ByZWZpeGVzKG9wdGlvbnMuZ2VuZGVyKSkuYWJicmV2aWF0aW9uO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnNzbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7c3NuRm91cjogZmFsc2UsIGRhc2hlczogdHJ1ZX0pO1xuICAgICAgICB2YXIgc3NuX3Bvb2wgPSBcIjEyMzQ1Njc4OTBcIixcbiAgICAgICAgICAgIHNzbixcbiAgICAgICAgICAgIGRhc2ggPSBvcHRpb25zLmRhc2hlcyA/ICctJyA6ICcnO1xuXG4gICAgICAgIGlmKCFvcHRpb25zLnNzbkZvdXIpIHtcbiAgICAgICAgICAgIHNzbiA9IHRoaXMuc3RyaW5nKHtwb29sOiBzc25fcG9vbCwgbGVuZ3RoOiAzfSkgKyBkYXNoICtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nKHtwb29sOiBzc25fcG9vbCwgbGVuZ3RoOiAyfSkgKyBkYXNoICtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nKHtwb29sOiBzc25fcG9vbCwgbGVuZ3RoOiA0fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzc24gPSB0aGlzLnN0cmluZyh7cG9vbDogc3NuX3Bvb2wsIGxlbmd0aDogNH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzc247XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbmFtZSBzdWZmaXhlc1xuICAgIC8vIEB0b2RvIGludHJvZHVjZSBpbnRlcm5hdGlvbmFsaXphdGlvblxuICAgIENoYW5jZS5wcm90b3R5cGUubmFtZV9zdWZmaXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1ZmZpeGVzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnRG9jdG9yIG9mIE9zdGVvcGF0aGljIE1lZGljaW5lJywgYWJicmV2aWF0aW9uOiAnRC5PLicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0RvY3RvciBvZiBQaGlsb3NvcGh5JywgYWJicmV2aWF0aW9uOiAnUGguRC4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdFc3F1aXJlJywgYWJicmV2aWF0aW9uOiAnRXNxLicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0p1bmlvcicsIGFiYnJldmlhdGlvbjogJ0pyLicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0p1cmlzIERvY3RvcicsIGFiYnJldmlhdGlvbjogJ0ouRC4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNYXN0ZXIgb2YgQXJ0cycsIGFiYnJldmlhdGlvbjogJ00uQS4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNYXN0ZXIgb2YgQnVzaW5lc3MgQWRtaW5pc3RyYXRpb24nLCBhYmJyZXZpYXRpb246ICdNLkIuQS4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNYXN0ZXIgb2YgU2NpZW5jZScsIGFiYnJldmlhdGlvbjogJ00uUy4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNZWRpY2FsIERvY3RvcicsIGFiYnJldmlhdGlvbjogJ00uRC4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdTZW5pb3InLCBhYmJyZXZpYXRpb246ICdTci4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdUaGUgVGhpcmQnLCBhYmJyZXZpYXRpb246ICdJSUknIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdUaGUgRm91cnRoJywgYWJicmV2aWF0aW9uOiAnSVYnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdCYWNoZWxvciBvZiBFbmdpbmVlcmluZycsIGFiYnJldmlhdGlvbjogJ0IuRScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0JhY2hlbG9yIG9mIFRlY2hub2xvZ3knLCBhYmJyZXZpYXRpb246ICdCLlRFQ0gnIH1cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHN1ZmZpeGVzO1xuICAgIH07XG5cbiAgICAvLyBBbGlhcyBmb3IgbmFtZV9zdWZmaXhcbiAgICBDaGFuY2UucHJvdG90eXBlLnN1ZmZpeCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVfc3VmZml4KG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm5hbWVfc3VmZml4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5mdWxsID9cbiAgICAgICAgICAgIHRoaXMucGljayh0aGlzLm5hbWVfc3VmZml4ZXMoKSkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5uYW1lX3N1ZmZpeGVzKCkpLmFiYnJldmlhdGlvbjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5uYXRpb25hbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJuYXRpb25hbGl0aWVzXCIpO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSByYW5kb20gbmF0aW9uYWxpdHkgYmFzZWQgb24ganNvbiBsaXN0XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5uYXRpb25hbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hdGlvbmFsaXR5ID0gdGhpcy5waWNrKHRoaXMubmF0aW9uYWxpdGllcygpKTtcbiAgICAgICAgcmV0dXJuIG5hdGlvbmFsaXR5Lm5hbWU7XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBQZXJzb24gLS1cblxuICAgIC8vIC0tIE1vYmlsZSAtLVxuICAgIC8vIEFuZHJvaWQgR0NNIFJlZ2lzdHJhdGlvbiBJRFxuICAgIENoYW5jZS5wcm90b3R5cGUuYW5kcm9pZF9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQVBBOTFcIiArIHRoaXMuc3RyaW5nKHsgcG9vbDogXCIwMTIzNDU2Nzg5YWJjZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLV9cIiwgbGVuZ3RoOiAxNzggfSk7XG4gICAgfTtcblxuICAgIC8vIEFwcGxlIFB1c2ggVG9rZW5cbiAgICBDaGFuY2UucHJvdG90eXBlLmFwcGxlX3Rva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcoeyBwb29sOiBcImFiY2RlZjEyMzQ1Njc4OTBcIiwgbGVuZ3RoOiA2NCB9KTtcbiAgICB9O1xuXG4gICAgLy8gV2luZG93cyBQaG9uZSA4IEFOSUQyXG4gICAgQ2hhbmNlLnByb3RvdHlwZS53cDhfYW5pZDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQoIHRoaXMuaGFzaCggeyBsZW5ndGggOiAzMiB9ICkgKTtcbiAgICB9O1xuXG4gICAgLy8gV2luZG93cyBQaG9uZSA3IEFOSURcbiAgICBDaGFuY2UucHJvdG90eXBlLndwN19hbmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0E9JyArIHRoaXMuZ3VpZCgpLnJlcGxhY2UoLy0vZywgJycpLnRvVXBwZXJDYXNlKCkgKyAnJkU9JyArIHRoaXMuaGFzaCh7IGxlbmd0aDozIH0pICsgJyZXPScgKyB0aGlzLmludGVnZXIoeyBtaW46MCwgbWF4OjkgfSk7XG4gICAgfTtcblxuICAgIC8vIEJsYWNrQmVycnkgRGV2aWNlIFBJTlxuICAgIENoYW5jZS5wcm90b3R5cGUuYmJfcGluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoKHsgbGVuZ3RoOiA4IH0pO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgTW9iaWxlIC0tXG5cbiAgICAvLyAtLSBXZWIgLS1cbiAgICBDaGFuY2UucHJvdG90eXBlLmF2YXRhciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cmwgPSBudWxsO1xuICAgICAgICB2YXIgVVJMX0JBU0UgPSAnLy93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci8nO1xuICAgICAgICB2YXIgUFJPVE9DT0xTID0ge1xuICAgICAgICAgICAgaHR0cDogJ2h0dHAnLFxuICAgICAgICAgICAgaHR0cHM6ICdodHRwcydcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEZJTEVfVFlQRVMgPSB7XG4gICAgICAgICAgICBibXA6ICdibXAnLFxuICAgICAgICAgICAgZ2lmOiAnZ2lmJyxcbiAgICAgICAgICAgIGpwZzogJ2pwZycsXG4gICAgICAgICAgICBwbmc6ICdwbmcnXG4gICAgICAgIH07XG4gICAgICAgIHZhciBGQUxMQkFDS1MgPSB7XG4gICAgICAgICAgICAnNDA0JzogJzQwNCcsIC8vIFJldHVybiA0MDQgaWYgbm90IGZvdW5kXG4gICAgICAgICAgICBtbTogJ21tJywgLy8gTXlzdGVyeSBtYW5cbiAgICAgICAgICAgIGlkZW50aWNvbjogJ2lkZW50aWNvbicsIC8vIEdlb21ldHJpYyBwYXR0ZXJuIGJhc2VkIG9uIGhhc2hcbiAgICAgICAgICAgIG1vbnN0ZXJpZDogJ21vbnN0ZXJpZCcsIC8vIEEgZ2VuZXJhdGVkIG1vbnN0ZXIgaWNvblxuICAgICAgICAgICAgd2F2YXRhcjogJ3dhdmF0YXInLCAvLyBBIGdlbmVyYXRlZCBmYWNlXG4gICAgICAgICAgICByZXRybzogJ3JldHJvJywgLy8gOC1iaXQgaWNvblxuICAgICAgICAgICAgYmxhbms6ICdibGFuaycgLy8gQSB0cmFuc3BhcmVudCBwbmdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFJBVElOR1MgPSB7XG4gICAgICAgICAgICBnOiAnZycsXG4gICAgICAgICAgICBwZzogJ3BnJyxcbiAgICAgICAgICAgIHI6ICdyJyxcbiAgICAgICAgICAgIHg6ICd4J1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHByb3RvY29sOiBudWxsLFxuICAgICAgICAgICAgZW1haWw6IG51bGwsXG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBudWxsLFxuICAgICAgICAgICAgc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGZhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgcmF0aW5nOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBTZXQgdG8gYSByYW5kb20gZW1haWxcbiAgICAgICAgICAgIG9wdHMuZW1haWwgPSB0aGlzLmVtYWlsKCk7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRzLmVtYWlsID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29uc3RydWN0b3IgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIG9wdHMpO1xuXG4gICAgICAgIGlmICghb3B0cy5lbWFpbCkge1xuICAgICAgICAgICAgLy8gU2V0IHRvIGEgcmFuZG9tIGVtYWlsXG4gICAgICAgICAgICBvcHRzLmVtYWlsID0gdGhpcy5lbWFpbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2FmZSBjaGVja2luZyBmb3IgcGFyYW1zXG4gICAgICAgIG9wdHMucHJvdG9jb2wgPSBQUk9UT0NPTFNbb3B0cy5wcm90b2NvbF0gPyBvcHRzLnByb3RvY29sICsgJzonIDogJyc7XG4gICAgICAgIG9wdHMuc2l6ZSA9IHBhcnNlSW50KG9wdHMuc2l6ZSwgMCkgPyBvcHRzLnNpemUgOiAnJztcbiAgICAgICAgb3B0cy5yYXRpbmcgPSBSQVRJTkdTW29wdHMucmF0aW5nXSA/IG9wdHMucmF0aW5nIDogJyc7XG4gICAgICAgIG9wdHMuZmFsbGJhY2sgPSBGQUxMQkFDS1Nbb3B0cy5mYWxsYmFja10gPyBvcHRzLmZhbGxiYWNrIDogJyc7XG4gICAgICAgIG9wdHMuZmlsZUV4dGVuc2lvbiA9IEZJTEVfVFlQRVNbb3B0cy5maWxlRXh0ZW5zaW9uXSA/IG9wdHMuZmlsZUV4dGVuc2lvbiA6ICcnO1xuXG4gICAgICAgIHVybCA9XG4gICAgICAgICAgICBvcHRzLnByb3RvY29sICtcbiAgICAgICAgICAgIFVSTF9CQVNFICtcbiAgICAgICAgICAgIHRoaXMuYmltZDUubWQ1KG9wdHMuZW1haWwpICtcbiAgICAgICAgICAgIChvcHRzLmZpbGVFeHRlbnNpb24gPyAnLicgKyBvcHRzLmZpbGVFeHRlbnNpb24gOiAnJykgK1xuICAgICAgICAgICAgKG9wdHMuc2l6ZSB8fCBvcHRzLnJhdGluZyB8fCBvcHRzLmZhbGxiYWNrID8gJz8nIDogJycpICtcbiAgICAgICAgICAgIChvcHRzLnNpemUgPyAnJnM9JyArIG9wdHMuc2l6ZS50b1N0cmluZygpIDogJycpICtcbiAgICAgICAgICAgIChvcHRzLnJhdGluZyA/ICcmcj0nICsgb3B0cy5yYXRpbmcgOiAnJykgK1xuICAgICAgICAgICAgKG9wdHMuZmFsbGJhY2sgPyAnJmQ9JyArIG9wdHMuZmFsbGJhY2sgOiAnJylcbiAgICAgICAgICAgIDtcblxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjRGVzY3JpcHRpb246XG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKiBHZW5lcmF0ZSByYW5kb20gY29sb3IgdmFsdWUgYmFzZSBvbiBjb2xvciB0eXBlOlxuICAgICAqIC0+IGhleFxuICAgICAqIC0+IHJnYlxuICAgICAqIC0+IHJnYmFcbiAgICAgKiAtPiAweFxuICAgICAqIC0+IG5hbWVkIGNvbG9yXG4gICAgICpcbiAgICAgKiAjRXhhbXBsZXM6IFxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICogKiBHZWVyYXRlIHJhbmRvbSBoZXggY29sb3JcbiAgICAgKiBjaGFuY2UuY29sb3IoKSA9PiAnIzc5YzE1NycgLyAncmdiKDExMCw1MiwxNjQpJyAvICcweDY3YWUwYicgLyAnI2UyZTJlMicgLyAnIzI5Q0ZBNydcbiAgICAgKiBcbiAgICAgKiAqIEdlbmVyYXRlIEhleCBiYXNlZCBjb2xvciB2YWx1ZVxuICAgICAqIGNoYW5jZS5jb2xvcih7Zm9ybWF0OiAnaGV4J30pICAgID0+ICcjZDY3MTE4J1xuICAgICAqXG4gICAgICogKiBHZW5lcmF0ZSBzaW1wbGUgcmdiIHZhbHVlXG4gICAgICogY2hhbmNlLmNvbG9yKHtmb3JtYXQ6ICdyZ2InfSkgICAgPT4gJ3JnYigxMTAsNTIsMTY0KSdcbiAgICAgKlxuICAgICAqICogR2VuZXJhdGUgT3ggYmFzZWQgY29sb3IgdmFsdWVcbiAgICAgKiBjaGFuY2UuY29sb3Ioe2Zvcm1hdDogJzB4J30pICAgICA9PiAnMHg2N2FlMGInIFxuICAgICAqXG4gICAgICogKiBHZW5lcmF0ZSBncmFpc2NhbGUgYmFzZWQgdmFsdWVcbiAgICAgKiBjaGFuY2UuY29sb3Ioe2dyYXlzY2FsZTogdHJ1ZX0pICA9PiAnI2UyZTJlMidcbiAgICAgKlxuICAgICAqICogUmV0dXJuIHZhbGlkZSBjb2xvciBuYW1lXG4gICAgICogY2hhbmNlLmNvbG9yKHtmb3JtYXQ6ICduYW1lJ30pICAgPT4gJ3JlZCdcbiAgICAgKiBcbiAgICAgKiAqIE1ha2UgY29sb3IgdXBwZXJjYXNlXG4gICAgICogY2hhbmNlLmNvbG9yKHtjYXNpbmc6ICd1cHBlcid9KSAgPT4gJyMyOUNGQTcnXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIFtvYmplY3RdIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIFtzdHJpbmddIGNvbG9yIHZhbHVlXG4gICAgICovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jb2xvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gZ3JheSh2YWx1ZSwgZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gW3ZhbHVlLCB2YWx1ZSwgdmFsdWVdLmpvaW4oZGVsaW1pdGVyIHx8ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJnYihoYXNBbHBoYSkge1xuXG4gICAgICAgICAgICB2YXIgcmdiVmFsdWUgICAgPSAoaGFzQWxwaGEpICAgID8gJ3JnYmEnIDogJ3JnYic7IFxuICAgICAgICAgICAgdmFyIGFscGhhQ2hhbmFsID0gKGhhc0FscGhhKSAgICA/ICgnLCcgKyB0aGlzLmZsb2F0aW5nKHttaW46MCwgbWF4OjF9KSkgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIGNvbG9yVmFsdWUgID0gKGlzR3JheXNjYWxlKSA/IChncmF5KHRoaXMubmF0dXJhbCh7bWF4OiAyNTV9KSwgJywnKSkgOiAodGhpcy5uYXR1cmFsKHttYXg6IDI1NX0pICsgJywnICsgdGhpcy5uYXR1cmFsKHttYXg6IDI1NX0pICsgJywnICsgdGhpcy5uYXR1cmFsKHttYXg6IDI1NX0pKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJnYlZhbHVlICsgJygnICsgY29sb3JWYWx1ZSArIGFscGhhQ2hhbmFsICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGV4KHN0YXJ0LCBlbmQsIHdpdGhIYXNoKSB7XG5cbiAgICAgICAgICAgIHZhciBzaW1ib2wgPSAod2l0aEhhc2gpID8gXCIjXCIgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gID0gKGlzR3JheXNjYWxlID8gZ3JheSh0aGlzLmhhc2goe2xlbmd0aDogc3RhcnR9KSkgOiB0aGlzLmhhc2goe2xlbmd0aDogZW5kfSkpOyBcbiAgICAgICAgICAgIHJldHVybiBzaW1ib2wgKyBleHByZXNzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5waWNrKFsnaGV4JywgJ3Nob3J0aGV4JywgJ3JnYicsICdyZ2JhJywgJzB4JywgJ25hbWUnXSksXG4gICAgICAgICAgICBncmF5c2NhbGU6IGZhbHNlLFxuICAgICAgICAgICAgY2FzaW5nOiAnbG93ZXInXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpc0dyYXlzY2FsZSA9IG9wdGlvbnMuZ3JheXNjYWxlO1xuICAgICAgICB2YXIgY29sb3JWYWx1ZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdoZXgnKSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlID0gIGhleC5jYWxsKHRoaXMsIDIsIDYsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnc2hvcnRoZXgnKSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlID0gaGV4LmNhbGwodGhpcywgMSwgMywgdHJ1ZSk7XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAncmdiJykge1xuICAgICAgICAgICAgY29sb3JWYWx1ZSA9IHJnYi5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdyZ2JhJykge1xuICAgICAgICAgICAgY29sb3JWYWx1ZSA9IHJnYi5jYWxsKHRoaXMsIHRydWUpO1xuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJzB4Jykge1xuICAgICAgICAgICAgY29sb3JWYWx1ZSA9ICcweCcgKyBoZXguY2FsbCh0aGlzLCAyLCA2KTtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSBpZihvcHRpb25zLmZvcm1hdCA9PT0gJ25hbWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5waWNrKHRoaXMuZ2V0KFwiY29sb3JOYW1lc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBmb3JtYXQgcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIG9uZSBvZiBcImhleFwiLCBcInNob3J0aGV4XCIsIFwicmdiXCIsIFwicmdiYVwiLCBcIjB4XCIgb3IgXCJuYW1lXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5jYXNpbmcgPT09ICd1cHBlcicgKSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlID0gY29sb3JWYWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yVmFsdWU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZG9tYWluID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy53b3JkKCkgKyAnLicgKyAob3B0aW9ucy50bGQgfHwgdGhpcy50bGQoKSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZW1haWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmQoe2xlbmd0aDogb3B0aW9ucy5sZW5ndGh9KSArICdAJyArIChvcHRpb25zLmRvbWFpbiB8fCB0aGlzLmRvbWFpbigpKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5mYmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoJzEwMDAwJyArIHRoaXMubmF0dXJhbCh7bWF4OiAxMDAwMDAwMDAwMDB9KSwgMTApO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmdvb2dsZV9hbmFseXRpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY2NvdW50ID0gdGhpcy5wYWQodGhpcy5uYXR1cmFsKHttYXg6IDk5OTk5OX0pLCA2KTtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYWQodGhpcy5uYXR1cmFsKHttYXg6IDk5fSksIDIpO1xuXG4gICAgICAgIHJldHVybiAnVUEtJyArIGFjY291bnQgKyAnLScgKyBwcm9wZXJ0eTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5oYXNodGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy53b3JkKCk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRvZG86IFRoaXMgY291bGQgcmV0dXJuIHNvbWUgcmVzZXJ2ZWQgSVBzLiBTZWUgaHR0cDovL3ZxLmlvLzEzN2RnWXlcbiAgICAgICAgLy8gdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgdXBkYXRlZCB0byBhY2NvdW50IGZvciB0aGF0IHJhcmUgYXMgaXQgbWF5IGJlXG4gICAgICAgIHJldHVybiB0aGlzLm5hdHVyYWwoe21pbjogMSwgbWF4OiAyNTR9KSArICcuJyArXG4gICAgICAgICAgICAgICB0aGlzLm5hdHVyYWwoe21heDogMjU1fSkgKyAnLicgK1xuICAgICAgICAgICAgICAgdGhpcy5uYXR1cmFsKHttYXg6IDI1NX0pICsgJy4nICtcbiAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbCh7bWluOiAxLCBtYXg6IDI1NH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmlwdjYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpcF9hZGRyID0gdGhpcy5uKHRoaXMuaGFzaCwgOCwge2xlbmd0aDogNH0pO1xuXG4gICAgICAgIHJldHVybiBpcF9hZGRyLmpvaW4oXCI6XCIpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmtsb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogOTl9KTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zZW12ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBpbmNsdWRlX3ByZXJlbGVhc2U6IHRydWUgfSk7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5waWNrb25lKFtcIl5cIiwgXCJ+XCIsIFwiPFwiLCBcIj5cIiwgXCI8PVwiLCBcIj49XCIsIFwiPVwiXSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJhbmdlKSB7XG4gICAgICAgICAgICByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlcmVsZWFzZSA9IFwiXCI7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVfcHJlcmVsZWFzZSkge1xuICAgICAgICAgICAgcHJlcmVsZWFzZSA9IHRoaXMud2VpZ2h0ZWQoW1wiXCIsIFwiLWRldlwiLCBcIi1iZXRhXCIsIFwiLWFscGhhXCJdLCBbNTAsIDEwLCA1LCAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlICsgdGhpcy5ycGcoJzNkMTAnKS5qb2luKCcuJykgKyBwcmVyZWxlYXNlO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbJ2NvbScsICdvcmcnLCAnZWR1JywgJ2dvdicsICdjby51aycsICduZXQnLCAnaW8nLCAnYWMnLCAnYWQnLCAnYWUnLCAnYWYnLCAnYWcnLCAnYWknLCAnYWwnLCAnYW0nLCAnYW4nLCAnYW8nLCAnYXEnLCAnYXInLCAnYXMnLCAnYXQnLCAnYXUnLCAnYXcnLCAnYXgnLCAnYXonLCAnYmEnLCAnYmInLCAnYmQnLCAnYmUnLCAnYmYnLCAnYmcnLCAnYmgnLCAnYmknLCAnYmonLCAnYm0nLCAnYm4nLCAnYm8nLCAnYnEnLCAnYnInLCAnYnMnLCAnYnQnLCAnYnYnLCAnYncnLCAnYnknLCAnYnonLCAnY2EnLCAnY2MnLCAnY2QnLCAnY2YnLCAnY2cnLCAnY2gnLCAnY2knLCAnY2snLCAnY2wnLCAnY20nLCAnY24nLCAnY28nLCAnY3InLCAnY3UnLCAnY3YnLCAnY3cnLCAnY3gnLCAnY3knLCAnY3onLCAnZGUnLCAnZGonLCAnZGsnLCAnZG0nLCAnZG8nLCAnZHonLCAnZWMnLCAnZWUnLCAnZWcnLCAnZWgnLCAnZXInLCAnZXMnLCAnZXQnLCAnZXUnLCAnZmknLCAnZmonLCAnZmsnLCAnZm0nLCAnZm8nLCAnZnInLCAnZ2EnLCAnZ2InLCAnZ2QnLCAnZ2UnLCAnZ2YnLCAnZ2cnLCAnZ2gnLCAnZ2knLCAnZ2wnLCAnZ20nLCAnZ24nLCAnZ3AnLCAnZ3EnLCAnZ3InLCAnZ3MnLCAnZ3QnLCAnZ3UnLCAnZ3cnLCAnZ3knLCAnaGsnLCAnaG0nLCAnaG4nLCAnaHInLCAnaHQnLCAnaHUnLCAnaWQnLCAnaWUnLCAnaWwnLCAnaW0nLCAnaW4nLCAnaW8nLCAnaXEnLCAnaXInLCAnaXMnLCAnaXQnLCAnamUnLCAnam0nLCAnam8nLCAnanAnLCAna2UnLCAna2cnLCAna2gnLCAna2knLCAna20nLCAna24nLCAna3AnLCAna3InLCAna3cnLCAna3knLCAna3onLCAnbGEnLCAnbGInLCAnbGMnLCAnbGknLCAnbGsnLCAnbHInLCAnbHMnLCAnbHQnLCAnbHUnLCAnbHYnLCAnbHknLCAnbWEnLCAnbWMnLCAnbWQnLCAnbWUnLCAnbWcnLCAnbWgnLCAnbWsnLCAnbWwnLCAnbW0nLCAnbW4nLCAnbW8nLCAnbXAnLCAnbXEnLCAnbXInLCAnbXMnLCAnbXQnLCAnbXUnLCAnbXYnLCAnbXcnLCAnbXgnLCAnbXknLCAnbXonLCAnbmEnLCAnbmMnLCAnbmUnLCAnbmYnLCAnbmcnLCAnbmknLCAnbmwnLCAnbm8nLCAnbnAnLCAnbnInLCAnbnUnLCAnbnonLCAnb20nLCAncGEnLCAncGUnLCAncGYnLCAncGcnLCAncGgnLCAncGsnLCAncGwnLCAncG0nLCAncG4nLCAncHInLCAncHMnLCAncHQnLCAncHcnLCAncHknLCAncWEnLCAncmUnLCAncm8nLCAncnMnLCAncnUnLCAncncnLCAnc2EnLCAnc2InLCAnc2MnLCAnc2QnLCAnc2UnLCAnc2cnLCAnc2gnLCAnc2knLCAnc2onLCAnc2snLCAnc2wnLCAnc20nLCAnc24nLCAnc28nLCAnc3InLCAnc3MnLCAnc3QnLCAnc3UnLCAnc3YnLCAnc3gnLCAnc3knLCAnc3onLCAndGMnLCAndGQnLCAndGYnLCAndGcnLCAndGgnLCAndGonLCAndGsnLCAndGwnLCAndG0nLCAndG4nLCAndG8nLCAndHAnLCAndHInLCAndHQnLCAndHYnLCAndHcnLCAndHonLCAndWEnLCAndWcnLCAndWsnLCAndXMnLCAndXknLCAndXonLCAndmEnLCAndmMnLCAndmUnLCAndmcnLCAndmknLCAndm4nLCAndnUnLCAnd2YnLCAnd3MnLCAneWUnLCAneXQnLCAnemEnLCAnem0nLCAnencnXTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS50bGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2sodGhpcy50bGRzKCkpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnR3aXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQCcgKyB0aGlzLndvcmQoKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBwcm90b2NvbDogXCJodHRwXCIsIGRvbWFpbjogdGhpcy5kb21haW4ob3B0aW9ucyksIGRvbWFpbl9wcmVmaXg6IFwiXCIsIHBhdGg6IHRoaXMud29yZCgpLCBleHRlbnNpb25zOiBbXX0pO1xuXG4gICAgICAgIHZhciBleHRlbnNpb24gPSBvcHRpb25zLmV4dGVuc2lvbnMubGVuZ3RoID4gMCA/IFwiLlwiICsgdGhpcy5waWNrKG9wdGlvbnMuZXh0ZW5zaW9ucykgOiBcIlwiO1xuICAgICAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW5fcHJlZml4ID8gb3B0aW9ucy5kb21haW5fcHJlZml4ICsgXCIuXCIgKyBvcHRpb25zLmRvbWFpbiA6IG9wdGlvbnMuZG9tYWluO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zLnByb3RvY29sICsgXCI6Ly9cIiArIGRvbWFpbiArIFwiL1wiICsgb3B0aW9ucy5wYXRoICsgZXh0ZW5zaW9uO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgV2ViIC0tXG5cbiAgICAvLyAtLSBMb2NhdGlvbiAtLVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttaW46IDUsIG1heDogMjAwMH0pICsgJyAnICsgdGhpcy5zdHJlZXQob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuYWx0aXR1ZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2ZpeGVkOiA1LCBtaW46IDAsIG1heDogODg0OH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdGluZyh7XG4gICAgICAgICAgICBtaW46IG9wdGlvbnMubWluLFxuICAgICAgICAgICAgbWF4OiBvcHRpb25zLm1heCxcbiAgICAgICAgICAgIGZpeGVkOiBvcHRpb25zLmZpeGVkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmFyZWFjb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtwYXJlbnMgOiB0cnVlfSk7XG4gICAgICAgIC8vIERvbid0IHdhbnQgYXJlYSBjb2RlcyB0byBzdGFydCB3aXRoIDEsIG9yIGhhdmUgYSA5IGFzIHRoZSBzZWNvbmQgZGlnaXRcbiAgICAgICAgdmFyIGFyZWFjb2RlID0gdGhpcy5uYXR1cmFsKHttaW46IDIsIG1heDogOX0pLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbCh7bWluOiAwLCBtYXg6IDh9KS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdHVyYWwoe21pbjogMCwgbWF4OiA5fSkudG9TdHJpbmcoKTtcblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5wYXJlbnMgPyAnKCcgKyBhcmVhY29kZSArICcpJyA6IGFyZWFjb2RlO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmNpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhcGl0YWxpemUodGhpcy53b3JkKHtzeWxsYWJsZXM6IDN9KSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuY29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRpdHVkZShvcHRpb25zKSArICcsICcgKyB0aGlzLmxvbmdpdHVkZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jb3VudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcImNvdW50cmllc1wiKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jb3VudHJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgY291bnRyeSA9IHRoaXMucGljayh0aGlzLmNvdW50cmllcygpKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZnVsbCA/IGNvdW50cnkubmFtZSA6IGNvdW50cnkuYWJicmV2aWF0aW9uO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmRlcHRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtmaXhlZDogNSwgbWluOiAtMTA5OTQsIG1heDogMH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdGluZyh7XG4gICAgICAgICAgICBtaW46IG9wdGlvbnMubWluLFxuICAgICAgICAgICAgbWF4OiBvcHRpb25zLm1heCxcbiAgICAgICAgICAgIGZpeGVkOiBvcHRpb25zLmZpeGVkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmdlb2hhc2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBsZW5ndGg6IDcgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZyh7IGxlbmd0aDogb3B0aW9ucy5sZW5ndGgsIHBvb2w6ICcwMTIzNDU2Nzg5YmNkZWZnaGprbW5wcXJzdHV2d3h5eicgfSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZ2VvanNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGl0dWRlKG9wdGlvbnMpICsgJywgJyArIHRoaXMubG9uZ2l0dWRlKG9wdGlvbnMpICsgJywgJyArIHRoaXMuYWx0aXR1ZGUob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubGF0aXR1ZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2ZpeGVkOiA1LCBtaW46IC05MCwgbWF4OiA5MH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdGluZyh7bWluOiBvcHRpb25zLm1pbiwgbWF4OiBvcHRpb25zLm1heCwgZml4ZWQ6IG9wdGlvbnMuZml4ZWR9KTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5sb25naXR1ZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2ZpeGVkOiA1LCBtaW46IC0xODAsIG1heDogMTgwfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0aW5nKHttaW46IG9wdGlvbnMubWluLCBtYXg6IG9wdGlvbnMubWF4LCBmaXhlZDogb3B0aW9ucy5maXhlZH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnBob25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbnVtUGljayxcbiAgICAgICAgICAgIHVrTnVtID0gZnVuY3Rpb24gKHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBbXTtcbiAgICAgICAgICAgICAgICAvL2ZpbGxzIHRoZSBzZWN0aW9uIHBhcnQgb2YgdGhlIHBob25lIG51bWJlciB3aXRoIHJhbmRvbSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIHBhcnRzLnNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLnB1c2goc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogbn0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydHMuYXJlYSArIHNlY3Rpb24uam9pbignICcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvdW50cnk6ICd1cycsXG4gICAgICAgICAgICBtb2JpbGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW9wdGlvbnMuZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmVucyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaG9uZTtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmNvdW50cnkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZyJzpcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVBpY2sgPSB0aGlzLnBpY2soW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWQgem9uZSBhbmQgZMOpcGFydGVtZW50IGNvZGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgJzAxJyArIHRoaXMucGljayhbJzMwJywgJzM0JywgJzM5JywgJzQwJywgJzQxJywgJzQyJywgJzQzJywgJzQ0JywgJzQ1JywgJzQ2JywgJzQ3JywgJzQ4JywgJzQ5JywgJzUzJywgJzU1JywgJzU2JywgJzU4JywgJzYwJywgJzY0JywgJzY5JywgJzcwJywgJzcyJywgJzczJywgJzc0JywgJzc1JywgJzc2JywgJzc3JywgJzc4JywgJzc5JywgJzgwJywgJzgxJywgJzgyJywgJzgzJ10pICsgc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogNn0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzAyJyArIHRoaXMucGljayhbJzE0JywgJzE4JywgJzIyJywgJzIzJywgJzI4JywgJzI5JywgJzMwJywgJzMxJywgJzMyJywgJzMzJywgJzM0JywgJzM1JywgJzM2JywgJzM3JywgJzM4JywgJzQwJywgJzQxJywgJzQzJywgJzQ0JywgJzQ1JywgJzQ2JywgJzQ3JywgJzQ4JywgJzQ5JywgJzUwJywgJzUxJywgJzUyJywgJzUzJywgJzU0JywgJzU2JywgJzU3JywgJzYxJywgJzYyJywgJzY5JywgJzcyJywgJzc2JywgJzc3JywgJzc4JywgJzg1JywgJzkwJywgJzk2JywgJzk3JywgJzk4JywgJzk5J10pICsgc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogNn0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzAzJyArIHRoaXMucGljayhbJzEwJywgJzIwJywgJzIxJywgJzIyJywgJzIzJywgJzI0JywgJzI1JywgJzI2JywgJzI3JywgJzI4JywgJzI5JywgJzM5JywgJzQ0JywgJzQ1JywgJzUxJywgJzUyJywgJzU0JywgJzU1JywgJzU3JywgJzU4JywgJzU5JywgJzYwJywgJzYxJywgJzYyJywgJzYzJywgJzY0JywgJzY1JywgJzY2JywgJzY3JywgJzY4JywgJzY5JywgJzcwJywgJzcxJywgJzcyJywgJzczJywgJzgwJywgJzgxJywgJzgyJywgJzgzJywgJzg0JywgJzg1JywgJzg2JywgJzg3JywgJzg4JywgJzg5JywgJzkwJ10pICsgc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogNn0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzA0JyArIHRoaXMucGljayhbJzExJywgJzEzJywgJzE1JywgJzIwJywgJzIyJywgJzI2JywgJzI3JywgJzMwJywgJzMyJywgJzM0JywgJzM3JywgJzQyJywgJzQzJywgJzQ0JywgJzUwJywgJzU2JywgJzU3JywgJzYzJywgJzY2JywgJzY3JywgJzY4JywgJzY5JywgJzcwJywgJzcxJywgJzcyJywgJzczJywgJzc0JywgJzc1JywgJzc2JywgJzc3JywgJzc4JywgJzc5JywgJzgwJywgJzgxJywgJzgyJywgJzgzJywgJzg0JywgJzg1JywgJzg2JywgJzg4JywgJzg5JywgJzkwJywgJzkxJywgJzkyJywgJzkzJywgJzk0JywgJzk1JywgJzk3JywgJzk4J10pICsgc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogNn0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzA1JyArIHRoaXMucGljayhbJzA4JywgJzE2JywgJzE3JywgJzE5JywgJzI0JywgJzMxJywgJzMyJywgJzMzJywgJzM0JywgJzM1JywgJzQwJywgJzQ1JywgJzQ2JywgJzQ3JywgJzQ5JywgJzUzJywgJzU1JywgJzU2JywgJzU3JywgJzU4JywgJzU5JywgJzYxJywgJzYyJywgJzYzJywgJzY0JywgJzY1JywgJzY3JywgJzc5JywgJzgxJywgJzgyJywgJzg2JywgJzg3JywgJzkwJywgJzk0J10pICsgc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogNn0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzA5JyArIHNlbGYuc3RyaW5nKHsgcG9vbDogJzAxMjM0NTY3ODknLCBsZW5ndGg6IDh9KSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHBob25lID0gb3B0aW9ucy5mb3JtYXR0ZWQgPyBudW1QaWNrLm1hdGNoKC8uLi9nKS5qb2luKCcgJykgOiBudW1QaWNrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVBpY2sgPSB0aGlzLnBpY2soWycwNicsICcwNyddKSArIHNlbGYuc3RyaW5nKHsgcG9vbDogJzAxMjM0NTY3ODknLCBsZW5ndGg6IDh9KTtcbiAgICAgICAgICAgICAgICAgICAgcGhvbmUgPSBvcHRpb25zLmZvcm1hdHRlZCA/IG51bVBpY2subWF0Y2goLy4uL2cpLmpvaW4oJyAnKSA6IG51bVBpY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndWsnOlxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUGljayA9IHRoaXMucGljayhbXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhbGlkIGFyZWEgY29kZXMgb2YgbWFqb3IgY2l0aWVzL2NvdW50aWVzIGZvbGxvd2VkIGJ5IHJhbmRvbSBudW1iZXJzIGluIHJlcXVpcmVkIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAxJyArIHRoaXMuY2hhcmFjdGVyKHsgcG9vbDogJzIzNDU2OScgfSkgKyAnMSAnLCBzZWN0aW9uczogWzMsNF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAyMCAnICsgdGhpcy5jaGFyYWN0ZXIoeyBwb29sOiAnMzc4JyB9KSwgc2VjdGlvbnM6IFszLDRdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMjMgJyArIHRoaXMuY2hhcmFjdGVyKHsgcG9vbDogJzg5JyB9KSwgc2VjdGlvbnM6IFszLDRdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMjQgNycsIHNlY3Rpb25zOiBbMyw0XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDI4ICcgKyB0aGlzLnBpY2soWycyNScsJzI4JywnMzcnLCc3MScsJzgyJywnOTAnLCc5MicsJzk1J10pLCBzZWN0aW9uczogWzIsNF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAxMicgKyB0aGlzLnBpY2soWycwNCcsJzA4JywnNTQnLCc3NicsJzk3JywnOTgnXSkgKyAnICcsIHNlY3Rpb25zOiBbNV0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAxMycgKyB0aGlzLnBpY2soWyc2MycsJzY0JywnODQnLCc4NiddKSArICcgJywgc2VjdGlvbnM6IFs1XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDE0JyArIHRoaXMucGljayhbJzA0JywnMjAnLCc2MCcsJzYxJywnODAnLCc4OCddKSArICcgJywgc2VjdGlvbnM6IFs1XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDE1JyArIHRoaXMucGljayhbJzI0JywnMjcnLCc2MicsJzY2J10pICsgJyAnLCBzZWN0aW9uczogWzVdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMTYnICsgdGhpcy5waWNrKFsnMDYnLCcyOScsJzM1JywnNDcnLCc1OScsJzk1J10pICsgJyAnLCBzZWN0aW9uczogWzVdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMTcnICsgdGhpcy5waWNrKFsnMjYnLCc0NCcsJzUwJywnNjgnXSkgKyAnICcsIHNlY3Rpb25zOiBbNV0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAxOCcgKyB0aGlzLnBpY2soWycyNycsJzM3JywnODQnLCc5NyddKSArICcgJywgc2VjdGlvbnM6IFs1XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDE5JyArIHRoaXMucGljayhbJzAwJywnMDUnLCczNScsJzQ2JywnNDknLCc2MycsJzk1J10pICsgJyAnLCBzZWN0aW9uczogWzVdIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHBob25lID0gb3B0aW9ucy5mb3JtYXR0ZWQgPyB1a051bShudW1QaWNrKSA6IHVrTnVtKG51bVBpY2spLnJlcGxhY2UoJyAnLCAnJywgJ2cnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBudW1QaWNrID0gdGhpcy5waWNrKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzA3JyArIHRoaXMucGljayhbJzQnLCc1JywnNycsJzgnLCc5J10pLCBzZWN0aW9uczogWzIsNl0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzA3NjI0ICcsIHNlY3Rpb25zOiBbNl0gfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcGhvbmUgPSBvcHRpb25zLmZvcm1hdHRlZCA/IHVrTnVtKG51bVBpY2spIDogdWtOdW0obnVtUGljaykucmVwbGFjZSgnICcsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cyc6XG4gICAgICAgICAgICAgICAgdmFyIGFyZWFjb2RlID0gdGhpcy5hcmVhY29kZShvcHRpb25zKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBleGNoYW5nZSA9IHRoaXMubmF0dXJhbCh7IG1pbjogMiwgbWF4OiA5IH0pLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdHVyYWwoeyBtaW46IDAsIG1heDogOSB9KS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXR1cmFsKHsgbWluOiAwLCBtYXg6IDkgfSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHRoaXMubmF0dXJhbCh7IG1pbjogMTAwMCwgbWF4OiA5OTk5IH0pLnRvU3RyaW5nKCk7IC8vIHRoaXMgY291bGQgYmUgcmFuZG9tIFswLTldezR9XG4gICAgICAgICAgICAgICAgcGhvbmUgPSBvcHRpb25zLmZvcm1hdHRlZCA/IGFyZWFjb2RlICsgJyAnICsgZXhjaGFuZ2UgKyAnLScgKyBzdWJzY3JpYmVyIDogYXJlYWNvZGUgKyBleGNoYW5nZSArIHN1YnNjcmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBob25lO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnBvc3RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUG9zdGFsIERpc3RyaWN0XG4gICAgICAgIHZhciBwZCA9IHRoaXMuY2hhcmFjdGVyKHtwb29sOiBcIlhWVFNSUE5LTE1ISkdFQ0JBXCJ9KTtcbiAgICAgICAgLy8gRm9yd2FyZCBTb3J0YXRpb24gQXJlYSAoRlNBKVxuICAgICAgICB2YXIgZnNhID0gcGQgKyB0aGlzLm5hdHVyYWwoe21heDogOX0pICsgdGhpcy5jaGFyYWN0ZXIoe2FscGhhOiB0cnVlLCBjYXNpbmc6IFwidXBwZXJcIn0pO1xuICAgICAgICAvLyBMb2NhbCBEZWxpdmVyeSBVbnV0IChMRFUpXG4gICAgICAgIHZhciBsZHUgPSB0aGlzLm5hdHVyYWwoe21heDogOX0pICsgdGhpcy5jaGFyYWN0ZXIoe2FscGhhOiB0cnVlLCBjYXNpbmc6IFwidXBwZXJcIn0pICsgdGhpcy5uYXR1cmFsKHttYXg6IDl9KTtcblxuICAgICAgICByZXR1cm4gZnNhICsgXCIgXCIgKyBsZHU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucHJvdmluY2VzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHsgY291bnRyeTogJ2NhJyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwicHJvdmluY2VzXCIpW29wdGlvbnMuY291bnRyeS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5wcm92aW5jZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmZ1bGwpID9cbiAgICAgICAgICAgIHRoaXMucGljayh0aGlzLnByb3ZpbmNlcyhvcHRpb25zKSkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5wcm92aW5jZXMob3B0aW9ucykpLmFiYnJldmlhdGlvbjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmZ1bGwpID9cbiAgICAgICAgICAgIHRoaXMucGljayh0aGlzLnN0YXRlcyhvcHRpb25zKSkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5zdGF0ZXMob3B0aW9ucykpLmFiYnJldmlhdGlvbjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zdGF0ZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBjb3VudHJ5OiAndXMnLCB1c19zdGF0ZXNfYW5kX2RjOiB0cnVlIH0gKTtcblxuICAgICAgICB2YXIgc3RhdGVzO1xuXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VzJzpcbiAgICAgICAgICAgICAgICB2YXIgdXNfc3RhdGVzX2FuZF9kYyA9IHRoaXMuZ2V0KFwidXNfc3RhdGVzX2FuZF9kY1wiKSxcbiAgICAgICAgICAgICAgICAgICAgdGVycml0b3JpZXMgPSB0aGlzLmdldChcInRlcnJpdG9yaWVzXCIpLFxuICAgICAgICAgICAgICAgICAgICBhcm1lZF9mb3JjZXMgPSB0aGlzLmdldChcImFybWVkX2ZvcmNlc1wiKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNfc3RhdGVzX2FuZF9kYykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSBzdGF0ZXMuY29uY2F0KHVzX3N0YXRlc19hbmRfZGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50ZXJyaXRvcmllcykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSBzdGF0ZXMuY29uY2F0KHRlcnJpdG9yaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJtZWRfZm9yY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IHN0YXRlcy5jb25jYXQoYXJtZWRfZm9yY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpdCc6XG4gICAgICAgICAgICAgICAgc3RhdGVzID0gdGhpcy5nZXQoXCJjb3VudHJ5X3JlZ2lvbnNcIilbb3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zdHJlZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBjb3VudHJ5OiAndXMnLCBzeWxsYWJsZXM6IDIgfSk7XG4gICAgICAgIHZhciAgICAgc3RyZWV0O1xuXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VzJzpcbiAgICAgICAgICAgICAgICBzdHJlZXQgPSB0aGlzLndvcmQoeyBzeWxsYWJsZXM6IG9wdGlvbnMuc3lsbGFibGVzIH0pO1xuICAgICAgICAgICAgICAgIHN0cmVldCA9IHRoaXMuY2FwaXRhbGl6ZShzdHJlZXQpO1xuICAgICAgICAgICAgICAgIHN0cmVldCArPSAnICc7XG4gICAgICAgICAgICAgICAgc3RyZWV0ICs9IG9wdGlvbnMuc2hvcnRfc3VmZml4ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlZXRfc3VmZml4KG9wdGlvbnMpLmFiYnJldmlhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWV0X3N1ZmZpeChvcHRpb25zKS5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXQnOlxuICAgICAgICAgICAgICAgIHN0cmVldCA9IHRoaXMud29yZCh7IHN5bGxhYmxlczogb3B0aW9ucy5zeWxsYWJsZXMgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWV0ID0gdGhpcy5jYXBpdGFsaXplKHN0cmVldCk7XG4gICAgICAgICAgICAgICAgc3RyZWV0ID0gKG9wdGlvbnMuc2hvcnRfc3VmZml4ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlZXRfc3VmZml4KG9wdGlvbnMpLmFiYnJldmlhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWV0X3N1ZmZpeChvcHRpb25zKS5uYW1lKSArIFwiIFwiICsgc3RyZWV0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlZXQ7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuc3RyZWV0X3N1ZmZpeCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGNvdW50cnk6ICd1cycgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2sodGhpcy5zdHJlZXRfc3VmZml4ZXMob3B0aW9ucykpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnN0cmVldF9zdWZmaXhlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGNvdW50cnk6ICd1cycgfSk7XG4gICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgbW9zdCBjb21tb24gc3VmZml4ZXMuXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInN0cmVldF9zdWZmaXhlc1wiKVtvcHRpb25zLmNvdW50cnkudG9Mb3dlckNhc2UoKV07XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IG9ubHkgcmV0dXJuaW5nIFVTIHppcCBjb2RlcywgaW50ZXJuYXRpb25hbGl6YXRpb24gd2lsbCBiZSBhIHdob2xlXG4gICAgLy8gb3RoZXIgYmVhc3QgdG8gdGFja2xlIGF0IHNvbWUgcG9pbnQuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS56aXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgemlwID0gdGhpcy5uKHRoaXMubmF0dXJhbCwgNSwge21heDogOX0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGx1c2ZvdXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHppcC5wdXNoKCctJyk7XG4gICAgICAgICAgICB6aXAgPSB6aXAuY29uY2F0KHRoaXMubih0aGlzLm5hdHVyYWwsIDQsIHttYXg6IDl9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gemlwLmpvaW4oXCJcIik7XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBMb2NhdGlvbiAtLVxuXG4gICAgLy8gLS0gVGltZVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5hbXBtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib29sKCkgPyAnYW0nIDogJ3BtJztcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRhdGVfc3RyaW5nLCBkYXRlO1xuXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHNwZWNpZmllZCB3ZSBpZ25vcmUgcHJlc2V0XG4gICAgICAgIGlmKG9wdGlvbnMgJiYgKG9wdGlvbnMubWluIHx8IG9wdGlvbnMubWF4KSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBhbWVyaWNhbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHJpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtaW4gPSB0eXBlb2Ygb3B0aW9ucy5taW4gIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1pbi5nZXRUaW1lKCkgOiAxO1xuICAgICAgICAgICAgLy8gMTAwLDAwMCwwMDAgZGF5cyBtZWFzdXJlZCByZWxhdGl2ZSB0byBtaWRuaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIDAxIEphbnVhcnksIDE5NzAgVVRDLiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gICAgICAgICAgICB2YXIgbWF4ID0gdHlwZW9mIG9wdGlvbnMubWF4ICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5tYXguZ2V0VGltZSgpIDogODY0MDAwMDAwMDAwMDAwMDtcblxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRoaXMubmF0dXJhbCh7bWluOiBtaW4sIG1heDogbWF4fSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLm1vbnRoKHtyYXc6IHRydWV9KTtcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IG0uZGF5cztcblxuICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLm1vbnRoKSB7XG4gICAgICAgICAgICAgICAgLy8gTW9kIDEyIHRvIGFsbG93IG1vbnRocyBvdXRzaWRlIHJhbmdlIG9mIDAtMTEgKG5vdCBlbmNvdXJhZ2VkLCBidXQgYWxzbyBub3QgcHJldmVudGVkKS5cbiAgICAgICAgICAgICAgICBkYXlzSW5Nb250aCA9IHRoaXMuZ2V0KCdtb250aHMnKVsoKG9wdGlvbnMubW9udGggJSAxMikgKyAxMikgJSAxMl0uZGF5cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludCh0aGlzLnllYXIoKSwgMTApLFxuICAgICAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSB0byBzdWJ0cmFjdCAxIGJlY2F1c2UgRGF0ZSgpIDAtaW5kZXhlcyBtb250aCBidXQgbm90IGRheSBvciB5ZWFyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICAgICAgICAgIG1vbnRoOiBtLm51bWVyaWMgLSAxLFxuICAgICAgICAgICAgICAgIGRheTogdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogZGF5c0luTW9udGh9KSxcbiAgICAgICAgICAgICAgICBob3VyOiB0aGlzLmhvdXIoKSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IHRoaXMubWludXRlKCksXG4gICAgICAgICAgICAgICAgc2Vjb25kOiB0aGlzLnNlY29uZCgpLFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGlzLm1pbGxpc2Vjb25kKCksXG4gICAgICAgICAgICAgICAgYW1lcmljYW46IHRydWUsXG4gICAgICAgICAgICAgICAgc3RyaW5nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShvcHRpb25zLnllYXIsIG9wdGlvbnMubW9udGgsIG9wdGlvbnMuZGF5LCBvcHRpb25zLmhvdXIsIG9wdGlvbnMubWludXRlLCBvcHRpb25zLnNlY29uZCwgb3B0aW9ucy5taWxsaXNlY29uZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hbWVyaWNhbikge1xuICAgICAgICAgICAgLy8gQWRkaW5nIDEgdG8gdGhlIG1vbnRoIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIERhdGUoKSAwLWluZGV4ZXNcbiAgICAgICAgICAgIC8vIG1vbnRocyBidXQgbm90IGRheSBmb3Igc29tZSBvZGQgcmVhc29uLlxuICAgICAgICAgICAgZGF0ZV9zdHJpbmcgPSAoZGF0ZS5nZXRNb250aCgpICsgMSkgKyAnLycgKyBkYXRlLmdldERhdGUoKSArICcvJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGVfc3RyaW5nID0gZGF0ZS5nZXREYXRlKCkgKyAnLycgKyAoZGF0ZS5nZXRNb250aCgpICsgMSkgKyAnLycgKyBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5zdHJpbmcgPyBkYXRlX3N0cmluZyA6IGRhdGU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuaGFtbWVydGltZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUob3B0aW9ucykuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmhvdXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICAgICAgbWluOiBvcHRpb25zICYmIG9wdGlvbnMudHdlbnR5Zm91ciA/IDAgOiAxLFxuICAgICAgICAgICAgbWF4OiBvcHRpb25zICYmIG9wdGlvbnMudHdlbnR5Zm91ciA/IDIzIDogMTJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdFJhbmdlKG9wdGlvbnMubWluIDwgMCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy50d2VudHlmb3VyICYmIG9wdGlvbnMubWF4ID4gMjMsIFwiQ2hhbmNlOiBNYXggY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAyMyBmb3IgdHdlbnR5Zm91ciBvcHRpb24uXCIpO1xuICAgICAgICB0ZXN0UmFuZ2UoIW9wdGlvbnMudHdlbnR5Zm91ciAmJiBvcHRpb25zLm1heCA+IDEyLCBcIkNoYW5jZTogTWF4IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gMTIuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPiBvcHRpb25zLm1heCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIE1heC5cIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbCh7bWluOiBvcHRpb25zLm1pbiwgbWF4OiBvcHRpb25zLm1heH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm1pbGxpc2Vjb25kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttYXg6IDk5OX0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm1pbnV0ZSA9IENoYW5jZS5wcm90b3R5cGUuc2Vjb25kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHttaW46IDAsIG1heDogNTl9KTtcblxuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPCAwLCBcIkNoYW5jZTogTWluIGNhbm5vdCBiZSBsZXNzIHRoYW4gMC5cIik7XG4gICAgICAgIHRlc3RSYW5nZShvcHRpb25zLm1heCA+IDU5LCBcIkNoYW5jZTogTWF4IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gNTkuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPiBvcHRpb25zLm1heCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIE1heC5cIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbCh7bWluOiBvcHRpb25zLm1pbiwgbWF4OiBvcHRpb25zLm1heH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm1vbnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHttaW46IDEsIG1heDogMTJ9KTtcblxuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPCAxLCBcIkNoYW5jZTogTWluIGNhbm5vdCBiZSBsZXNzIHRoYW4gMS5cIik7XG4gICAgICAgIHRlc3RSYW5nZShvcHRpb25zLm1heCA+IDEyLCBcIkNoYW5jZTogTWF4IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gMTIuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPiBvcHRpb25zLm1heCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIE1heC5cIik7XG5cbiAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5waWNrKHRoaXMubW9udGhzKCkuc2xpY2Uob3B0aW9ucy5taW4gLSAxLCBvcHRpb25zLm1heCkpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5yYXcgPyBtb250aCA6IG1vbnRoLm5hbWU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubW9udGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJtb250aHNcIik7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuc2Vjb25kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttYXg6IDU5fSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUudGltZXN0YW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogcGFyc2VJbnQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwLCAxMCl9KTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS53ZWVrZGF5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHt3ZWVrZGF5X29ubHk6IGZhbHNlfSk7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IFtcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiXTtcbiAgICAgICAgaWYgKCFvcHRpb25zLndlZWtkYXlfb25seSkge1xuICAgICAgICAgICAgd2Vla2RheXMucHVzaChcIlNhdHVyZGF5XCIpO1xuICAgICAgICAgICAgd2Vla2RheXMucHVzaChcIlN1bmRheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5waWNrb25lKHdlZWtkYXlzKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS55ZWFyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHllYXIgYXMgbWluIGlmIG5vbmUgc3BlY2lmaWVkXG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7bWluOiBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCl9KTtcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIG9uZSBjZW50dXJ5IGFmdGVyIGN1cnJlbnQgeWVhciBhcyBtYXggaWYgbm9uZSBzcGVjaWZpZWRcbiAgICAgICAgb3B0aW9ucy5tYXggPSAodHlwZW9mIG9wdGlvbnMubWF4ICE9PSBcInVuZGVmaW5lZFwiKSA/IG9wdGlvbnMubWF4IDogb3B0aW9ucy5taW4gKyAxMDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbChvcHRpb25zKS50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgVGltZVxuXG4gICAgLy8gLS0gRmluYW5jZSAtLVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHlwZSwgbnVtYmVyLCB0b19nZW5lcmF0ZTtcblxuICAgICAgICB0eXBlID0gKG9wdGlvbnMudHlwZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNjX3R5cGUoeyBuYW1lOiBvcHRpb25zLnR5cGUsIHJhdzogdHJ1ZSB9KSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2NfdHlwZSh7IHJhdzogdHJ1ZSB9KTtcblxuICAgICAgICBudW1iZXIgPSB0eXBlLnByZWZpeC5zcGxpdChcIlwiKTtcbiAgICAgICAgdG9fZ2VuZXJhdGUgPSB0eXBlLmxlbmd0aCAtIHR5cGUucHJlZml4Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgLy8gR2VuZXJhdGVzIG4gLSAxIGRpZ2l0c1xuICAgICAgICBudW1iZXIgPSBudW1iZXIuY29uY2F0KHRoaXMubih0aGlzLmludGVnZXIsIHRvX2dlbmVyYXRlLCB7bWluOiAwLCBtYXg6IDl9KSk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBsYXN0IGRpZ2l0IGFjY29yZGluZyB0byBMdWhuIGFsZ29yaXRobVxuICAgICAgICBudW1iZXIucHVzaCh0aGlzLmx1aG5fY2FsY3VsYXRlKG51bWJlci5qb2luKFwiXCIpKSk7XG5cbiAgICAgICAgcmV0dXJuIG51bWJlci5qb2luKFwiXCIpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmNjX3R5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhbmtfY2FyZF9udW1iZXIjSXNzdWVyX2lkZW50aWZpY2F0aW9uX251bWJlcl8uMjhJSU4uMjlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwiY2NfdHlwZXNcIik7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuY2NfdHlwZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy5jY190eXBlcygpLFxuICAgICAgICAgICAgdHlwZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEFjY2VwdCBlaXRoZXIgbmFtZSBvciBzaG9ydF9uYW1lIHRvIHNwZWNpZnkgY2FyZCB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVzW2ldLm5hbWUgPT09IG9wdGlvbnMubmFtZSB8fCB0eXBlc1tpXS5zaG9ydF9uYW1lID09PSBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ3JlZGl0IGNhcmQgdHlwZSAnXCIgKyBvcHRpb25zLm5hbWUgKyBcIicnIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5waWNrKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zLnJhdyA/IHR5cGUgOiB0eXBlLm5hbWU7XG4gICAgfTtcblxuICAgIC8vcmV0dXJuIGFsbCB3b3JsZCBjdXJyZW5jeSBieSBJU08gNDIxN1xuICAgIENoYW5jZS5wcm90b3R5cGUuY3VycmVuY3lfdHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcImN1cnJlbmN5X3R5cGVzXCIpO1xuICAgIH07XG5cbiAgICAvL3JldHVybiByYW5kb20gd29ybGQgY3VycmVuY3kgYnkgSVNPIDQyMTdcbiAgICBDaGFuY2UucHJvdG90eXBlLmN1cnJlbmN5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrKHRoaXMuY3VycmVuY3lfdHlwZXMoKSk7XG4gICAgfTtcblxuICAgIC8vUmV0dXJuIHJhbmRvbSBjb3JyZWN0IGN1cnJlbmN5IGV4Y2hhbmdlIHBhaXIgKGUuZy4gRVVSL1VTRCkgb3IgYXJyYXkgb2YgY3VycmVuY3kgY29kZVxuICAgIENoYW5jZS5wcm90b3R5cGUuY3VycmVuY3lfcGFpciA9IGZ1bmN0aW9uIChyZXR1cm5Bc1N0cmluZykge1xuICAgICAgICB2YXIgY3VycmVuY2llcyA9IHRoaXMudW5pcXVlKHRoaXMuY3VycmVuY3ksIDIsIHtcbiAgICAgICAgICAgIGNvbXBhcmF0b3I6IGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbihhY2MsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBtYXRjaCBoYXMgYmVlbiBmb3VuZCwgc2hvcnQgY2lyY3VpdCBjaGVjayBhbmQganVzdCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYyB8fCAoaXRlbS5jb2RlID09PSB2YWwuY29kZSk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmV0dXJuQXNTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW5jaWVzWzBdLmNvZGUgKyAnLycgKyBjdXJyZW5jaWVzWzFdLmNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVuY2llcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmRvbGxhciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGEgc29tZXdoYXQgbW9yZSBzYW5lIG1heCBmb3IgZG9sbGFyIHRoYW4gYWxsIGF2YWlsYWJsZSBudW1iZXJzXG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7bWF4IDogMTAwMDAsIG1pbiA6IDB9KTtcblxuICAgICAgICB2YXIgZG9sbGFyID0gdGhpcy5mbG9hdGluZyh7bWluOiBvcHRpb25zLm1pbiwgbWF4OiBvcHRpb25zLm1heCwgZml4ZWQ6IDJ9KS50b1N0cmluZygpLFxuICAgICAgICAgICAgY2VudHMgPSBkb2xsYXIuc3BsaXQoJy4nKVsxXTtcblxuICAgICAgICBpZiAoY2VudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9sbGFyICs9ICcuMDAnO1xuICAgICAgICB9IGVsc2UgaWYgKGNlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGRvbGxhciA9IGRvbGxhciArICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2xsYXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJy0kJyArIGRvbGxhci5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICckJyArIGRvbGxhcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmV1cm8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMuZG9sbGFyKG9wdGlvbnMpLnJlcGxhY2UoXCIkXCIsIFwiXCIpKS50b0xvY2FsZVN0cmluZygpICsgXCLigqxcIjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBleHAgPSB7fTtcblxuICAgICAgICBleHAueWVhciA9IHRoaXMuZXhwX3llYXIoKTtcblxuICAgICAgICAvLyBJZiB0aGUgeWVhciBpcyB0aGlzIHllYXIsIG5lZWQgdG8gZW5zdXJlIG1vbnRoIGlzIGdyZWF0ZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gY3VycmVudCBtb250aCBvciB0aGlzIGV4cGlyYXRpb24gd2lsbCBub3QgYmUgdmFsaWRcbiAgICAgICAgaWYgKGV4cC55ZWFyID09PSAobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKS50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBleHAubW9udGggPSB0aGlzLmV4cF9tb250aCh7ZnV0dXJlOiB0cnVlfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHAubW9udGggPSB0aGlzLmV4cF9tb250aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmF3ID8gZXhwIDogZXhwLm1vbnRoICsgJy8nICsgZXhwLnllYXI7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZXhwX21vbnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgbW9udGgsIG1vbnRoX2ludCxcbiAgICAgICAgICAgIC8vIERhdGUgb2JqZWN0IG1vbnRocyBhcmUgMCBpbmRleGVkXG4gICAgICAgICAgICBjdXJNb250aCA9IG5ldyBEYXRlKCkuZ2V0TW9udGgoKSArIDE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZnV0dXJlICYmIChjdXJNb250aCAhPT0gMTIpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbW9udGggPSB0aGlzLm1vbnRoKHtyYXc6IHRydWV9KS5udW1lcmljO1xuICAgICAgICAgICAgICAgIG1vbnRoX2ludCA9IHBhcnNlSW50KG1vbnRoLCAxMCk7XG4gICAgICAgICAgICB9IHdoaWxlIChtb250aF9pbnQgPD0gY3VyTW9udGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9udGggPSB0aGlzLm1vbnRoKHtyYXc6IHRydWV9KS5udW1lcmljO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmV4cF95ZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyTW9udGggPSBuZXcgRGF0ZSgpLmdldE1vbnRoKCkgKyAxLFxuICAgICAgICAgICAgY3VyWWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKHttaW46ICgoY3VyTW9udGggPT09IDEyKSA/IChjdXJZZWFyICsgMSkgOiBjdXJZZWFyKSwgbWF4OiAoY3VyWWVhciArIDEwKX0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnZhdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGNvdW50cnk6ICdpdCcgfSk7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2l0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdF92YXQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgRmluYW5jZVxuXG4gICAgLy8gLS0gUmVnaW9uYWxcblxuICAgIENoYW5jZS5wcm90b3R5cGUuaXRfdmF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRfdmF0ID0gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogMTgwMDAwMH0pO1xuXG4gICAgICAgIGl0X3ZhdCA9IHRoaXMucGFkKGl0X3ZhdCwgNykgKyB0aGlzLnBhZCh0aGlzLnBpY2sodGhpcy5wcm92aW5jZXMoeyBjb3VudHJ5OiAnaXQnIH0pKS5jb2RlLCAzKTtcbiAgICAgICAgcmV0dXJuIGl0X3ZhdCArIHRoaXMubHVobl9jYWxjdWxhdGUoaXRfdmF0KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiB0aGlzIGdlbmVyYXRvciBpcyB3cml0dGVuIGZvbGxvd2luZyB0aGUgb2ZmaWNpYWwgYWxnb3JpdGhtXG4gICAgICogYWxsIGRhdGEgY2FuIGJlIHBhc3NlZCBleHBsaWNpdGVseSBvciByYW5kb21pemVkIGJ5IGNhbGxpbmcgY2hhbmNlLmNmKCkgd2l0aG91dCBvcHRpb25zXG4gICAgICogdGhlIGNvZGUgZG9lcyBub3QgY2hlY2sgdGhhdCB0aGUgaW5wdXQgZGF0YSBpcyB2YWxpZCAoaXQgZ29lcyBiZXlvbmQgdGhlIHNjb3BlIG9mIHRoZSBnZW5lcmF0b3IpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIFtPYmplY3RdIG9wdGlvbnMgPSB7IGZpcnN0OiBmaXJzdCBuYW1lLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdDogbGFzdCBuYW1lLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZGVyOiBmZW1hbGV8bWFsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpcnRoZGF5OiBKYXZhU2NyaXB0IGRhdGUgb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2l0eTogc3RyaW5nKDQpLCAxIGxldHRlciArIDMgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogQHJldHVybiBbc3RyaW5nXSBjb2RpY2UgZmlzY2FsZVxuICAgICAqXG4gICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLmNmID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBnZW5kZXIgPSAhIW9wdGlvbnMuZ2VuZGVyID8gb3B0aW9ucy5nZW5kZXIgOiB0aGlzLmdlbmRlcigpLFxuICAgICAgICAgICAgZmlyc3QgPSAhIW9wdGlvbnMuZmlyc3QgPyBvcHRpb25zLmZpcnN0IDogdGhpcy5maXJzdCggeyBnZW5kZXI6IGdlbmRlciwgbmF0aW9uYWxpdHk6ICdpdCd9ICksXG4gICAgICAgICAgICBsYXN0ID0gISFvcHRpb25zLmxhc3QgPyBvcHRpb25zLmxhc3QgOiB0aGlzLmxhc3QoIHsgbmF0aW9uYWxpdHk6ICdpdCd9ICksXG4gICAgICAgICAgICBiaXJ0aGRheSA9ICEhb3B0aW9ucy5iaXJ0aGRheSA/IG9wdGlvbnMuYmlydGhkYXkgOiB0aGlzLmJpcnRoZGF5KCksXG4gICAgICAgICAgICBjaXR5ID0gISFvcHRpb25zLmNpdHkgPyBvcHRpb25zLmNpdHkgOiB0aGlzLnBpY2tvbmUoWydBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdMJywgJ00nLCAnWiddKSArIHRoaXMucGFkKHRoaXMubmF0dXJhbCh7bWF4Ojk5OX0pLCAzKSxcbiAgICAgICAgICAgIGNmID0gW10sXG4gICAgICAgICAgICBuYW1lX2dlbmVyYXRvciA9IGZ1bmN0aW9uKG5hbWUsIGlzTGFzdCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5fdmFsdWUgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChuYW1lLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3ZhbHVlID0gbmFtZS5zcGxpdChcIlwiKS5jb25jYXQoXCJYWFhcIi5zcGxpdChcIlwiKSkuc3BsaWNlKDAsMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gbmFtZS50b1VwcGVyQ2FzZSgpLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwiQkNERkdISktMTU5QUlNUVldaXCIuaW5kZXhPZihjKSAhPT0gLTEpID8gYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdGVtcC5zdWJzdHIoMCwzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHRlbXBbMF0gKyB0ZW1wLnN1YnN0cigyLDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybl92YWx1ZSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gbmFtZS50b1VwcGVyQ2FzZSgpLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIkFFSU9VXCIuaW5kZXhPZihjKSAhPT0gLTEpID8gYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpLnN1YnN0cigwLCAzIC0gcmV0dXJuX3ZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3ZhbHVlID0gcmV0dXJuX3ZhbHVlICsgdGVtcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuX3ZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGVfZ2VuZXJhdG9yID0gZnVuY3Rpb24oYmlydGhkYXksIGdlbmRlciwgdGhhdCkge1xuICAgICAgICAgICAgICAgIHZhciBsZXR0ZXJtb250aHMgPSBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdIJywgJ0wnLCAnTScsICdQJywgJ1InLCAnUycsICdUJ107XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gIGJpcnRoZGF5LmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKS5zdWJzdHIoMikgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldHRlcm1vbnRoc1tiaXJ0aGRheS5nZXRNb250aCgpXSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnBhZChiaXJ0aGRheS5nZXREYXRlKCkgKyAoKGdlbmRlci50b0xvd2VyQ2FzZSgpID09PSBcImZlbWFsZVwiKSA/IDQwIDogMCksIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoZWNrZGlnaXRfZ2VuZXJhdG9yID0gZnVuY3Rpb24oY2YpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UxID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UyID0gXCJBQkNERUZHSElKQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnMgID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiLFxuICAgICAgICAgICAgICAgICAgICBvZGRzICAgPSBcIkJBS1BMQ1FEUkVWT1NGVEdVSE1JTkpXWllYXCIsXG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0ICA9IDA7XG5cblxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXQgKz0gZXZlbnMuaW5kZXhPZihyYW5nZTJbcmFuZ2UxLmluZGV4T2YoY2ZbaV0pXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdpdCArPSAgb2Rkcy5pbmRleE9mKHJhbmdlMltyYW5nZTEuaW5kZXhPZihjZltpXSldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnNbZGlnaXQgJSAyNl07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGNmID0gY2YuY29uY2F0KG5hbWVfZ2VuZXJhdG9yKGxhc3QsIHRydWUpLCBuYW1lX2dlbmVyYXRvcihmaXJzdCksIGRhdGVfZ2VuZXJhdG9yKGJpcnRoZGF5LCBnZW5kZXIsIHRoaXMpLCBjaXR5LnRvVXBwZXJDYXNlKCkuc3BsaXQoXCJcIikpLmpvaW4oXCJcIik7XG4gICAgICAgIGNmICs9IGNoZWNrZGlnaXRfZ2VuZXJhdG9yKGNmLnRvVXBwZXJDYXNlKCksIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBjZi50b1VwcGVyQ2FzZSgpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnBsX3Blc2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogOTk5OTk5OTk5OX0pO1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5wYWQobnVtYmVyLCAxMCkuc3BsaXQoJycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gcGFyc2VJbnQoYXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250cm9sTnVtYmVyID0gKDEgKiBhcnJbMF0gKyAzICogYXJyWzFdICsgNyAqIGFyclsyXSArIDkgKiBhcnJbM10gKyAxICogYXJyWzRdICsgMyAqIGFycls1XSArIDcgKiBhcnJbNl0gKyA5ICogYXJyWzddICsgMSAqIGFycls4XSArIDMgKiBhcnJbOV0pICUgMTA7XG4gICAgICAgIGlmKGNvbnRyb2xOdW1iZXIgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xOdW1iZXIgPSAxMCAtIGNvbnRyb2xOdW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyLmpvaW4oJycpICsgY29udHJvbE51bWJlcjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5wbF9uaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm5hdHVyYWwoe21pbjogMSwgbWF4OiA5OTk5OTk5OTl9KTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMucGFkKG51bWJlciwgOSkuc3BsaXQoJycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gcGFyc2VJbnQoYXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250cm9sTnVtYmVyID0gKDYgKiBhcnJbMF0gKyA1ICogYXJyWzFdICsgNyAqIGFyclsyXSArIDIgKiBhcnJbM10gKyAzICogYXJyWzRdICsgNCAqIGFycls1XSArIDUgKiBhcnJbNl0gKyA2ICogYXJyWzddICsgNyAqIGFycls4XSkgJSAxMTtcbiAgICAgICAgaWYoY29udHJvbE51bWJlciA9PT0gMTApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsX25pcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyci5qb2luKCcnKSArIGNvbnRyb2xOdW1iZXI7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucGxfcmVnb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm5hdHVyYWwoe21pbjogMSwgbWF4OiA5OTk5OTk5OX0pO1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5wYWQobnVtYmVyLCA4KS5zcGxpdCgnJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBwYXJzZUludChhcnJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRyb2xOdW1iZXIgPSAoOCAqIGFyclswXSArIDkgKiBhcnJbMV0gKyAyICogYXJyWzJdICsgMyAqIGFyclszXSArIDQgKiBhcnJbNF0gKyA1ICogYXJyWzVdICsgNiAqIGFycls2XSArIDcgKiBhcnJbN10pICUgMTE7XG4gICAgICAgIGlmKGNvbnRyb2xOdW1iZXIgPT09IDEwKSB7XG4gICAgICAgICAgICBjb250cm9sTnVtYmVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnIuam9pbignJykgKyBjb250cm9sTnVtYmVyO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgUmVnaW9uYWxcblxuICAgIC8vIC0tIE1pc2NlbGxhbmVvdXMgLS1cblxuICAgIC8vIERpY2UgLSBGb3IgYWxsIHRoZSBib2FyZCBnYW1lIGdlZWtzIG91dCB0aGVyZSwgbXlzZWxmIGluY2x1ZGVkIDspXG4gICAgZnVuY3Rpb24gZGljZUZuIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbChyYW5nZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIENoYW5jZS5wcm90b3R5cGUuZDQgPSBkaWNlRm4oe21pbjogMSwgbWF4OiA0fSk7XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kNiA9IGRpY2VGbih7bWluOiAxLCBtYXg6IDZ9KTtcbiAgICBDaGFuY2UucHJvdG90eXBlLmQ4ID0gZGljZUZuKHttaW46IDEsIG1heDogOH0pO1xuICAgIENoYW5jZS5wcm90b3R5cGUuZDEwID0gZGljZUZuKHttaW46IDEsIG1heDogMTB9KTtcbiAgICBDaGFuY2UucHJvdG90eXBlLmQxMiA9IGRpY2VGbih7bWluOiAxLCBtYXg6IDEyfSk7XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kMjAgPSBkaWNlRm4oe21pbjogMSwgbWF4OiAyMH0pO1xuICAgIENoYW5jZS5wcm90b3R5cGUuZDMwID0gZGljZUZuKHttaW46IDEsIG1heDogMzB9KTtcbiAgICBDaGFuY2UucHJvdG90eXBlLmQxMDAgPSBkaWNlRm4oe21pbjogMSwgbWF4OiAxMDB9KTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucnBnID0gZnVuY3Rpb24gKHRocm93biwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhyb3duKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgdHlwZSBvZiBkaWUgcm9sbCBtdXN0IGJlIGluY2x1ZGVkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJpdHMgPSB0aHJvd24udG9Mb3dlckNhc2UoKS5zcGxpdChcImRcIiksXG4gICAgICAgICAgICAgICAgcm9sbHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGJpdHMubGVuZ3RoICE9PSAyIHx8ICFwYXJzZUludChiaXRzWzBdLCAxMCkgfHwgIXBhcnNlSW50KGJpdHNbMV0sIDEwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZm9ybWF0IHByb3ZpZGVkLiBQbGVhc2UgcHJvdmlkZSAjZCMgd2hlcmUgdGhlIGZpcnN0ICMgaXMgdGhlIG51bWJlciBvZiBkaWNlIHRvIHJvbGwsIHRoZSBzZWNvbmQgIyBpcyB0aGUgbWF4IG9mIGVhY2ggZGllXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGJpdHNbMF07IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICByb2xsc1tpIC0gMV0gPSB0aGlzLm5hdHVyYWwoe21pbjogMSwgbWF4OiBiaXRzWzFdfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBvcHRpb25zLnN1bSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy5zdW0pID8gcm9sbHMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7IHJldHVybiBwICsgYzsgfSkgOiByb2xscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBHdWlkXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5ndWlkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHsgdmVyc2lvbjogNSB9KTtcblxuICAgICAgICB2YXIgZ3VpZF9wb29sID0gXCJhYmNkZWYxMjM0NTY3ODkwXCIsXG4gICAgICAgICAgICB2YXJpYW50X3Bvb2wgPSBcImFiODlcIixcbiAgICAgICAgICAgIGd1aWQgPSB0aGlzLnN0cmluZyh7IHBvb2w6IGd1aWRfcG9vbCwgbGVuZ3RoOiA4IH0pICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZyh7IHBvb2w6IGd1aWRfcG9vbCwgbGVuZ3RoOiA0IH0pICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAvLyBUaGUgVmVyc2lvblxuICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmVyc2lvbiArXG4gICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmcoeyBwb29sOiBndWlkX3Bvb2wsIGxlbmd0aDogMyB9KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgLy8gVGhlIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZyh7IHBvb2w6IHZhcmlhbnRfcG9vbCwgbGVuZ3RoOiAxIH0pICtcbiAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZyh7IHBvb2w6IGd1aWRfcG9vbCwgbGVuZ3RoOiAzIH0pICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZyh7IHBvb2w6IGd1aWRfcG9vbCwgbGVuZ3RoOiAxMiB9KTtcbiAgICAgICAgcmV0dXJuIGd1aWQ7XG4gICAgfTtcblxuICAgIC8vIEhhc2hcbiAgICBDaGFuY2UucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2xlbmd0aCA6IDQwLCBjYXNpbmc6ICdsb3dlcid9KTtcbiAgICAgICAgdmFyIHBvb2wgPSBvcHRpb25zLmNhc2luZyA9PT0gJ3VwcGVyJyA/IEhFWF9QT09MLnRvVXBwZXJDYXNlKCkgOiBIRVhfUE9PTDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nKHtwb29sOiBwb29sLCBsZW5ndGg6IG9wdGlvbnMubGVuZ3RofSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubHVobl9jaGVjayA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygpO1xuICAgICAgICB2YXIgY2hlY2tEaWdpdCA9ICtzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRGlnaXQgPT09IHRoaXMubHVobl9jYWxjdWxhdGUoK3N0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5sdWhuX2NhbGN1bGF0ZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IG51bS50b1N0cmluZygpLnNwbGl0KFwiXCIpLnJldmVyc2UoKTtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBkaWdpdDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGg7IGwgPiBpOyArK2kpIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gK2RpZ2l0c1tpXTtcbiAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0ICo9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0ID4gOSkge1xuICAgICAgICAgICAgICAgICAgICBkaWdpdCAtPSA5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN1bSAqIDkpICUgMTA7XG4gICAgfTtcblxuICAgIC8vIE1ENSBIYXNoXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5tZDUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzID0geyBzdHI6ICcnLCBrZXk6IG51bGwsIHJhdzogZmFsc2UgfTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuc3RyID0gdGhpcy5zdHJpbmcoKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdHMuc3RyID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYob3B0aW9ucy5jb25zdHJ1Y3RvciA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzID0gaW5pdE9wdGlvbnMob3B0aW9ucywgb3B0cyk7XG5cbiAgICAgICAgaWYoIW9wdHMuc3RyKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgdG8gcmV0dXJuIGFuIG1kNSBoYXNoLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYmltZDUubWQ1KG9wdHMuc3RyLCBvcHRzLmtleSwgb3B0cy5yYXcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjRGVzY3JpcHRpb246XG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKiBHZW5lcmF0ZSByYW5kb20gZmlsZSBuYW1lIHdpdGggZXh0ZW50aW9uXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnQgcHJvdmlkZSBleHRlbnRpb24gdHlwZSBcbiAgICAgKiAtPiByYXN0ZXIgXG4gICAgICogLT4gdmVjdG9yXG4gICAgICogLT4gM2RcbiAgICAgKiAtPiBkb2N1bWVudFxuICAgICAqXG4gICAgICogSWYgbm90aW5nIGlzIHByb3ZpZGVkIHRoZSBmdW5jdGlvbiByZXR1cm4gcmFuZG9tIGZpbGUgbmFtZSB3aXRoIHJhbmRvbSBcbiAgICAgKiBleHRlbnRpb24gdHlwZSBvZiBhbnkga2luZFxuICAgICAqXG4gICAgICogVGhlIHVzZXIgY2FuIHZhbGlkYXRlIHRoZSBmaWxlIG5hbWUgbGVuZ3RoIHJhbmdlIFxuICAgICAqIElmIG5vdGluZyBwcm92aWRlZCB0aGUgZ2VuZXJhdGVkIGZpbGUgbmFtZSBpcyByYWRvbVxuICAgICAqXG4gICAgICogI0V4dGVudGlvbiBQb29sIDpcbiAgICAgKiAqIEN1cnJlbnRseSB0aGUgc3VwcG9ydGVkIGV4dGVudGlvbnMgYXJlIFxuICAgICAqICAtPiBzb21lIG9mIHRoZSBtb3N0IHBvcHVsYXIgcmFzdGVyIGltYWdlIGV4dGVudGlvbnNcbiAgICAgKiAgLT4gc29tZSBvZiB0aGUgbW9zdCBwb3B1bGFyIHZlY3RvciBpbWFnZSBleHRlbnRpb25zXG4gICAgICogIC0+IHNvbWUgb2YgdGhlIG1vc3QgcG9wdWxhciAzZCBpbWFnZSBleHRlbnRpb25zXG4gICAgICogIC0+IHNvbWUgb2YgdGhlIG1vc3QgcG9wdWxhciBkb2N1bWVudCBleHRlbnRpb25zXG4gICAgICogXG4gICAgICogI0V4YW1wbGVzIDpcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqXG4gICAgICogUmV0dXJuIHJhbmRvbSBmaWxlIG5hbWUgd2l0aCByYW5kb20gZXh0ZW50aW9uLiBUaGUgZmlsZSBleHRlbnRpb25cbiAgICAgKiBpcyBwcm92aWRlZCBieSBhIHByZWRpZmluZWQgY29sbGVjdGlvbiBvZiBleHRlbnRpb25zLiBNb3JlIGFib3V0aCB0aGUgZXh0ZW50aW9uXG4gICAgICogcG9vbCBjYW4gYmUgZm9uZCBpbiAjRXh0ZW50aW9uIFBvb2wgc2VjdGlvblxuICAgICAqIFxuICAgICAqIGNoYW5jZS5maWxlKCkgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgKiA9PiBkc2ZzZGhqZi54bWxcbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIGdlbmVyYXRlIGEgZmlsZSBuYW1lIHdpdGggc3NwZWNpZmljIGxlbmd0aCwgc3BlY2lmeSB0aGUgXG4gICAgICogbGVuZ3RoIHByb3BlcnR5IGFuZCBpbnRlZ2VyIHZhbHVlLiBUaGUgZXh0ZW50aW9uIGlzIGdvaW5nIHRvIGJlIHJhbmRvbVxuICAgICAqICBcbiAgICAgKiBjaGFuY2UuZmlsZSh7bGVuZ3RoIDogMTB9KSAgICAgICAgICAgXG4gICAgICogPT4gYXNydGluZXFvcy5wZGZcbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIGdlZXJhdGUgZmlsZSB3aXRoIGV4dGVudGlvbiBmb3JtIHNvbWUgb2YgdGhlIHByZWRpZmluZWQgZ3JvdXBzXG4gICAgICogb2YgdGhlIGV4dGVudGlvbiBwb29sIGp1c3Qgc3BlY2lmeSB0aGUgZXh0ZW50b24gcG9vbCBjYXRlZ29yeSBpbiBmaWxlVHlwZSBwcm9wZXJ0eVxuICAgICAqICBcbiAgICAgKiBjaGFuY2UuZmlsZSh7ZmlsZVR5cGUgOiAncmFzdGVyJ30pICAgXG4gICAgICogPT4gZHNoZ3NzZHMucHNkXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHByb3ZpZGUgc3BlY2lmaWMgZXh0ZW50aW9uIGZvciB5b3VyIGZpbGVzXG4gICAgICogY2hhbmNlLmZpbGUoe2V4dGVudGlvbiA6ICdodG1sJ30pICAgIFxuICAgICAqID0+IGRqZnNkLmh0bWxcbiAgICAgKlxuICAgICAqIE9yIHlvdSBjb3VsZCBwYXNzIGN1c3RvbSBjb2xsZWN0aW9uIG9mIGV4dGVudG9ucyBidCBhcnJheSBvciBieSBvYmplY3RcbiAgICAgKiBjaGFuY2UuZmlsZSh7ZXh0ZW50aW9ucyA6IFsuLi5dfSkgICAgXG4gICAgICogPT4gZGhnc2RzZC5wc2RcbiAgICAgKiAgXG4gICAgICogY2hhbmNlLmZpbGUoe2V4dGVudGlvbnMgOiB7IGtleSA6IFsuLi5dLCBrZXkgOiBbLi4uXX19KVxuICAgICAqID0+IGRqc2Zrc2Rqc2QueG1sXG4gICAgICogXG4gICAgICogQHBhcmFtICBbY29sbGVjdGlvbl0gb3B0aW9ucyBcbiAgICAgKiBAcmV0dXJuIFtzdHJpbmddXG4gICAgICogXG4gICAgICovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5maWxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBcbiAgICAgICAgdmFyIGZpbGVPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHBvb2xDb2xsZWN0aW9uS2V5ID0gXCJmaWxlRXh0ZW5zaW9uXCI7XG4gICAgICAgIHZhciB0eXBlUmFuZ2UgICA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0KFwiZmlsZUV4dGVuc2lvblwiKSk7Ly9bJ3Jhc3RlcicsICd2ZWN0b3InLCAnM2QnLCAnZG9jdW1lbnQnXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lO1xuICAgICAgICB2YXIgZmlsZUV4dGVudGlvbjtcblxuICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gZmlsZSBuYW1lIFxuICAgICAgICBmaWxlTmFtZSA9IHRoaXMud29yZCh7bGVuZ3RoIDogZmlsZU9wdGlvbnMubGVuZ3RofSk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgZmlsZSBieSBzcGVjaWZpYyBleHRlbnRpb24gcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgaWYoZmlsZU9wdGlvbnMuZXh0ZW50aW9uKSB7XG5cbiAgICAgICAgICAgIGZpbGVFeHRlbnRpb24gPSBmaWxlT3B0aW9ucy5leHRlbnRpb247XG4gICAgICAgICAgICByZXR1cm4gKGZpbGVOYW1lICsgJy4nICsgZmlsZUV4dGVudGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBmaWxlIGJ5IHNwZWNpZmljIGF4dGVudGlvbiBjb2xsZWN0aW9uXG4gICAgICAgIGlmKGZpbGVPcHRpb25zLmV4dGVudGlvbnMpIHtcblxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShmaWxlT3B0aW9ucy5leHRlbnRpb25zKSkge1xuXG4gICAgICAgICAgICAgICAgZmlsZUV4dGVudGlvbiA9IHRoaXMucGlja29uZShmaWxlT3B0aW9ucy5leHRlbnRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZpbGVOYW1lICsgJy4nICsgZmlsZUV4dGVudGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGZpbGVPcHRpb25zLmV4dGVudGlvbnMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBleHRlbnRpb25PYmplY3RDb2xsZWN0aW9uID0gZmlsZU9wdGlvbnMuZXh0ZW50aW9ucztcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4dGVudGlvbk9iamVjdENvbGxlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgZmlsZUV4dGVudGlvbiA9IHRoaXMucGlja29uZShleHRlbnRpb25PYmplY3RDb2xsZWN0aW9uW3RoaXMucGlja29uZShrZXlzKV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmlsZU5hbWUgKyAnLicgKyBmaWxlRXh0ZW50aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0IGNvbGxlY3Rpb24gb2YgdHlwZSBBcnJheSBvciBPYmplY3QgdG8gYmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IFwiKTtcbiAgICAgICAgfSBcblxuICAgICAgICAvLyBHZW5lcmF0ZSBmaWxlIGV4dGVudGlvbiBiYXNlZCBvbiBzcGVjaWZpYyBmaWxlIHR5cGVcbiAgICAgICAgaWYoZmlsZU9wdGlvbnMuZmlsZVR5cGUpIHtcblxuICAgICAgICAgICAgdmFyIGZpbGVUeXBlID0gZmlsZU9wdGlvbnMuZmlsZVR5cGU7XG4gICAgICAgICAgICBpZih0eXBlUmFuZ2UuaW5kZXhPZihmaWxlVHlwZSkgIT09IC0xKSB7XG5cbiAgICAgICAgICAgICAgICBmaWxlRXh0ZW50aW9uID0gdGhpcy5waWNrb25lKHRoaXMuZ2V0KHBvb2xDb2xsZWN0aW9uS2V5KVtmaWxlVHlwZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmlsZU5hbWUgKyAnLicgKyBmaWxlRXh0ZW50aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0IGZpbGUgdHlwZSB2YWx1ZSB0byBiZSAncmFzdGVyJywgJ3ZlY3RvcicsICczZCcgb3IgJ2RvY3VtZW50JyBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gZmlsZSBuYW1lIGlmIG5vIGV4dGVudG9uIG9wdGlvbnMgYXJlIHBhc3NlZFxuICAgICAgICBmaWxlRXh0ZW50aW9uID0gdGhpcy5waWNrb25lKHRoaXMuZ2V0KHBvb2xDb2xsZWN0aW9uS2V5KVt0aGlzLnBpY2tvbmUodHlwZVJhbmdlKV0pO1xuICAgICAgICByZXR1cm4gKGZpbGVOYW1lICsgJy4nICsgZmlsZUV4dGVudGlvbik7XG4gICAgfTsgICAgIFxuXG4gICAgdmFyIGRhdGEgPSB7XG5cbiAgICAgICAgZmlyc3ROYW1lczoge1xuICAgICAgICAgICAgXCJtYWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImVuXCI6IFtcIkphbWVzXCIsIFwiSm9oblwiLCBcIlJvYmVydFwiLCBcIk1pY2hhZWxcIiwgXCJXaWxsaWFtXCIsIFwiRGF2aWRcIiwgXCJSaWNoYXJkXCIsIFwiSm9zZXBoXCIsIFwiQ2hhcmxlc1wiLCBcIlRob21hc1wiLCBcIkNocmlzdG9waGVyXCIsIFwiRGFuaWVsXCIsIFwiTWF0dGhld1wiLCBcIkdlb3JnZVwiLCBcIkRvbmFsZFwiLCBcIkFudGhvbnlcIiwgXCJQYXVsXCIsIFwiTWFya1wiLCBcIkVkd2FyZFwiLCBcIlN0ZXZlblwiLCBcIktlbm5ldGhcIiwgXCJBbmRyZXdcIiwgXCJCcmlhblwiLCBcIkpvc2h1YVwiLCBcIktldmluXCIsIFwiUm9uYWxkXCIsIFwiVGltb3RoeVwiLCBcIkphc29uXCIsIFwiSmVmZnJleVwiLCBcIkZyYW5rXCIsIFwiR2FyeVwiLCBcIlJ5YW5cIiwgXCJOaWNob2xhc1wiLCBcIkVyaWNcIiwgXCJTdGVwaGVuXCIsIFwiSmFjb2JcIiwgXCJMYXJyeVwiLCBcIkpvbmF0aGFuXCIsIFwiU2NvdHRcIiwgXCJSYXltb25kXCIsIFwiSnVzdGluXCIsIFwiQnJhbmRvblwiLCBcIkdyZWdvcnlcIiwgXCJTYW11ZWxcIiwgXCJCZW5qYW1pblwiLCBcIlBhdHJpY2tcIiwgXCJKYWNrXCIsIFwiSGVucnlcIiwgXCJXYWx0ZXJcIiwgXCJEZW5uaXNcIiwgXCJKZXJyeVwiLCBcIkFsZXhhbmRlclwiLCBcIlBldGVyXCIsIFwiVHlsZXJcIiwgXCJEb3VnbGFzXCIsIFwiSGFyb2xkXCIsIFwiQWFyb25cIiwgXCJKb3NlXCIsIFwiQWRhbVwiLCBcIkFydGh1clwiLCBcIlphY2hhcnlcIiwgXCJDYXJsXCIsIFwiTmF0aGFuXCIsIFwiQWxiZXJ0XCIsIFwiS3lsZVwiLCBcIkxhd3JlbmNlXCIsIFwiSm9lXCIsIFwiV2lsbGllXCIsIFwiR2VyYWxkXCIsIFwiUm9nZXJcIiwgXCJLZWl0aFwiLCBcIkplcmVteVwiLCBcIlRlcnJ5XCIsIFwiSGFycnlcIiwgXCJSYWxwaFwiLCBcIlNlYW5cIiwgXCJKZXNzZVwiLCBcIlJveVwiLCBcIkxvdWlzXCIsIFwiQmlsbHlcIiwgXCJBdXN0aW5cIiwgXCJCcnVjZVwiLCBcIkV1Z2VuZVwiLCBcIkNocmlzdGlhblwiLCBcIkJyeWFuXCIsIFwiV2F5bmVcIiwgXCJSdXNzZWxsXCIsIFwiSG93YXJkXCIsIFwiRnJlZFwiLCBcIkV0aGFuXCIsIFwiSm9yZGFuXCIsIFwiUGhpbGlwXCIsIFwiQWxhblwiLCBcIkp1YW5cIiwgXCJSYW5keVwiLCBcIlZpbmNlbnRcIiwgXCJCb2JieVwiLCBcIkR5bGFuXCIsIFwiSm9obm55XCIsIFwiUGhpbGxpcFwiLCBcIlZpY3RvclwiLCBcIkNsYXJlbmNlXCIsIFwiRXJuZXN0XCIsIFwiTWFydGluXCIsIFwiQ3JhaWdcIiwgXCJTdGFubGV5XCIsIFwiU2hhd25cIiwgXCJUcmF2aXNcIiwgXCJCcmFkbGV5XCIsIFwiTGVvbmFyZFwiLCBcIkVhcmxcIiwgXCJHYWJyaWVsXCIsIFwiSmltbXlcIiwgXCJGcmFuY2lzXCIsIFwiVG9kZFwiLCBcIk5vYWhcIiwgXCJEYW5ueVwiLCBcIkRhbGVcIiwgXCJDb2R5XCIsIFwiQ2FybG9zXCIsIFwiQWxsZW5cIiwgXCJGcmVkZXJpY2tcIiwgXCJMb2dhblwiLCBcIkN1cnRpc1wiLCBcIkFsZXhcIiwgXCJKb2VsXCIsIFwiTHVpc1wiLCBcIk5vcm1hblwiLCBcIk1hcnZpblwiLCBcIkdsZW5uXCIsIFwiVG9ueVwiLCBcIk5hdGhhbmllbFwiLCBcIlJvZG5leVwiLCBcIk1lbHZpblwiLCBcIkFsZnJlZFwiLCBcIlN0ZXZlXCIsIFwiQ2FtZXJvblwiLCBcIkNoYWRcIiwgXCJFZHdpblwiLCBcIkNhbGViXCIsIFwiRXZhblwiLCBcIkFudG9uaW9cIiwgXCJMZWVcIiwgXCJIZXJiZXJ0XCIsIFwiSmVmZmVyeVwiLCBcIklzYWFjXCIsIFwiRGVyZWtcIiwgXCJSaWNreVwiLCBcIk1hcmN1c1wiLCBcIlRoZW9kb3JlXCIsIFwiRWxpamFoXCIsIFwiTHVrZVwiLCBcIkplc3VzXCIsIFwiRWRkaWVcIiwgXCJUcm95XCIsIFwiTWlrZVwiLCBcIkR1c3RpblwiLCBcIlJheVwiLCBcIkFkcmlhblwiLCBcIkJlcm5hcmRcIiwgXCJMZXJveVwiLCBcIkFuZ2VsXCIsIFwiUmFuZGFsbFwiLCBcIldlc2xleVwiLCBcIklhblwiLCBcIkphcmVkXCIsIFwiTWFzb25cIiwgXCJIdW50ZXJcIiwgXCJDYWx2aW5cIiwgXCJPc2NhclwiLCBcIkNsaWZmb3JkXCIsIFwiSmF5XCIsIFwiU2hhbmVcIiwgXCJSb25uaWVcIiwgXCJCYXJyeVwiLCBcIkx1Y2FzXCIsIFwiQ29yZXlcIiwgXCJNYW51ZWxcIiwgXCJMZW9cIiwgXCJUb21teVwiLCBcIldhcnJlblwiLCBcIkphY2tzb25cIiwgXCJJc2FpYWhcIiwgXCJDb25ub3JcIiwgXCJEb25cIiwgXCJEZWFuXCIsIFwiSm9uXCIsIFwiSnVsaWFuXCIsIFwiTWlndWVsXCIsIFwiQmlsbFwiLCBcIkxsb3lkXCIsIFwiQ2hhcmxpZVwiLCBcIk1pdGNoZWxsXCIsIFwiTGVvblwiLCBcIkplcm9tZVwiLCBcIkRhcnJlbGxcIiwgXCJKZXJlbWlhaFwiLCBcIkFsdmluXCIsIFwiQnJldHRcIiwgXCJTZXRoXCIsIFwiRmxveWRcIiwgXCJKaW1cIiwgXCJCbGFrZVwiLCBcIk1pY2hlYWxcIiwgXCJHb3Jkb25cIiwgXCJUcmV2b3JcIiwgXCJMZXdpc1wiLCBcIkVyaWtcIiwgXCJFZGdhclwiLCBcIlZlcm5vblwiLCBcIkRldmluXCIsIFwiR2F2aW5cIiwgXCJKYXlkZW5cIiwgXCJDaHJpc1wiLCBcIkNseWRlXCIsIFwiVG9tXCIsIFwiRGVycmlja1wiLCBcIk1hcmlvXCIsIFwiQnJlbnRcIiwgXCJNYXJjXCIsIFwiSGVybWFuXCIsIFwiQ2hhc2VcIiwgXCJEb21pbmljXCIsIFwiUmljYXJkb1wiLCBcIkZyYW5rbGluXCIsIFwiTWF1cmljZVwiLCBcIk1heFwiLCBcIkFpZGVuXCIsIFwiT3dlblwiLCBcIkxlc3RlclwiLCBcIkdpbGJlcnRcIiwgXCJFbG1lclwiLCBcIkdlbmVcIiwgXCJGcmFuY2lzY29cIiwgXCJHbGVuXCIsIFwiQ29yeVwiLCBcIkdhcnJldHRcIiwgXCJDbGF5dG9uXCIsIFwiU2FtXCIsIFwiSm9yZ2VcIiwgXCJDaGVzdGVyXCIsIFwiQWxlamFuZHJvXCIsIFwiSmVmZlwiLCBcIkhhcnZleVwiLCBcIk1pbHRvblwiLCBcIkNvbGVcIiwgXCJJdmFuXCIsIFwiQW5kcmVcIiwgXCJEdWFuZVwiLCBcIkxhbmRvblwiXSxcbiAgICAgICAgICAgICAgICAvLyBEYXRhIHRha2VuIGZyb20gaHR0cDovL3d3dy5kYXRpLmdvdi5pdC9kYXRhc2V0L2NvbXVuZS1kaS1maXJlbnplXzAxNjNcbiAgICAgICAgICAgICAgICBcIml0XCI6IFtcIkFkb2xmb1wiLCBcIkFsYmVydG9cIiwgXCJBbGRvXCIsIFwiQWxlc3NhbmRyb1wiLCBcIkFsZXNzaW9cIiwgXCJBbGZyZWRvXCIsIFwiQWx2YXJvXCIsIFwiQW5kcmVhXCIsIFwiQW5nZWxvXCIsIFwiQW5naW9sb1wiLCBcIkFudG9uaW5vXCIsIFwiQW50b25pb1wiLCBcIkF0dGlsaW9cIiwgXCJCZW5pdG9cIiwgXCJCZXJuYXJkb1wiLCBcIkJydW5vXCIsIFwiQ2FybG9cIiwgXCJDZXNhcmVcIiwgXCJDaHJpc3RpYW5cIiwgXCJDbGF1ZGlvXCIsIFwiQ29ycmFkb1wiLCBcIkNvc2ltb1wiLCBcIkNyaXN0aWFuXCIsIFwiQ3Jpc3RpYW5vXCIsIFwiRGFuaWVsZVwiLCBcIkRhcmlvXCIsIFwiRGF2aWRcIiwgXCJEYXZpZGVcIiwgXCJEaWVnb1wiLCBcIkRpbm9cIiwgXCJEb21lbmljb1wiLCBcIkR1Y2Npb1wiLCBcIkVkb2FyZG9cIiwgXCJFbGlhXCIsIFwiRWxpb1wiLCBcIkVtYW51ZWxlXCIsIFwiRW1pbGlhbm9cIiwgXCJFbWlsaW9cIiwgXCJFbnJpY29cIiwgXCJFbnpvXCIsIFwiRXR0b3JlXCIsIFwiRmFiaW9cIiwgXCJGYWJyaXppb1wiLCBcIkZlZGVyaWNvXCIsIFwiRmVyZGluYW5kb1wiLCBcIkZlcm5hbmRvXCIsIFwiRmlsaXBwb1wiLCBcIkZyYW5jZXNjb1wiLCBcIkZyYW5jb1wiLCBcIkdhYnJpZWxlXCIsIFwiR2lhY29tb1wiLCBcIkdpYW1wYW9sb1wiLCBcIkdpYW1waWVyb1wiLCBcIkdpYW5jYXJsb1wiLCBcIkdpYW5mcmFuY29cIiwgXCJHaWFubHVjYVwiLCBcIkdpYW5tYXJjb1wiLCBcIkdpYW5uaVwiLCBcIkdpbm9cIiwgXCJHaW9yZ2lvXCIsIFwiR2lvdmFubmlcIiwgXCJHaXVsaWFub1wiLCBcIkdpdWxpb1wiLCBcIkdpdXNlcHBlXCIsIFwiR3Jhemlhbm9cIiwgXCJHcmVnb3Jpb1wiLCBcIkd1aWRvXCIsIFwiSWFjb3BvXCIsIFwiSmFjb3BvXCIsIFwiTGFwb1wiLCBcIkxlb25hcmRvXCIsIFwiTG9yZW56b1wiLCBcIkx1Y2FcIiwgXCJMdWNpYW5vXCIsIFwiTHVpZ2lcIiwgXCJNYW51ZWxcIiwgXCJNYXJjZWxsb1wiLCBcIk1hcmNvXCIsIFwiTWFyaW5vXCIsIFwiTWFyaW9cIiwgXCJNYXNzaW1pbGlhbm9cIiwgXCJNYXNzaW1vXCIsIFwiTWF0dGVvXCIsIFwiTWF0dGlhXCIsIFwiTWF1cml6aW9cIiwgXCJNYXVyb1wiLCBcIk1pY2hlbGVcIiwgXCJNaXJrb1wiLCBcIk1vaGFtZWRcIiwgXCJOZWxsb1wiLCBcIk5lcmlcIiwgXCJOaWNjb2zDslwiLCBcIk5pY29sYVwiLCBcIk9zdmFsZG9cIiwgXCJPdGVsbG9cIiwgXCJQYW9sb1wiLCBcIlBpZXIgTHVpZ2lcIiwgXCJQaWVyb1wiLCBcIlBpZXRyb1wiLCBcIlJhZmZhZWxlXCIsIFwiUmVtb1wiLCBcIlJlbmF0b1wiLCBcIlJlbnpvXCIsIFwiUmljY2FyZG9cIiwgXCJSb2JlcnRvXCIsIFwiUm9sYW5kb1wiLCBcIlJvbWFub1wiLCBcIlNhbHZhdG9yZVwiLCBcIlNhbXVlbGVcIiwgXCJTYW5kcm9cIiwgXCJTZXJnaW9cIiwgXCJTaWx2YW5vXCIsIFwiU2ltb25lXCIsIFwiU3RlZmFub1wiLCBcIlRob21hc1wiLCBcIlRvbW1hc29cIiwgXCJVYmFsZG9cIiwgXCJVZ29cIiwgXCJVbWJlcnRvXCIsIFwiVmFsZXJpb1wiLCBcIlZhbHRlclwiLCBcIlZhc2NvXCIsIFwiVmluY2Vuem9cIiwgXCJWaXR0b3Jpb1wiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmVtYWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImVuXCI6IFtcIk1hcnlcIiwgXCJFbW1hXCIsIFwiRWxpemFiZXRoXCIsIFwiTWlubmllXCIsIFwiTWFyZ2FyZXRcIiwgXCJJZGFcIiwgXCJBbGljZVwiLCBcIkJlcnRoYVwiLCBcIlNhcmFoXCIsIFwiQW5uaWVcIiwgXCJDbGFyYVwiLCBcIkVsbGFcIiwgXCJGbG9yZW5jZVwiLCBcIkNvcmFcIiwgXCJNYXJ0aGFcIiwgXCJMYXVyYVwiLCBcIk5lbGxpZVwiLCBcIkdyYWNlXCIsIFwiQ2FycmllXCIsIFwiTWF1ZGVcIiwgXCJNYWJlbFwiLCBcIkJlc3NpZVwiLCBcIkplbm5pZVwiLCBcIkdlcnRydWRlXCIsIFwiSnVsaWFcIiwgXCJIYXR0aWVcIiwgXCJFZGl0aFwiLCBcIk1hdHRpZVwiLCBcIlJvc2VcIiwgXCJDYXRoZXJpbmVcIiwgXCJMaWxsaWFuXCIsIFwiQWRhXCIsIFwiTGlsbGllXCIsIFwiSGVsZW5cIiwgXCJKZXNzaWVcIiwgXCJMb3Vpc2VcIiwgXCJFdGhlbFwiLCBcIkx1bGFcIiwgXCJNeXJ0bGVcIiwgXCJFdmFcIiwgXCJGcmFuY2VzXCIsIFwiTGVuYVwiLCBcIkx1Y3lcIiwgXCJFZG5hXCIsIFwiTWFnZ2llXCIsIFwiUGVhcmxcIiwgXCJEYWlzeVwiLCBcIkZhbm5pZVwiLCBcIkpvc2VwaGluZVwiLCBcIkRvcmFcIiwgXCJSb3NhXCIsIFwiS2F0aGVyaW5lXCIsIFwiQWduZXNcIiwgXCJNYXJpZVwiLCBcIk5vcmFcIiwgXCJNYXlcIiwgXCJNYW1pZVwiLCBcIkJsYW5jaGVcIiwgXCJTdGVsbGFcIiwgXCJFbGxlblwiLCBcIk5hbmN5XCIsIFwiRWZmaWVcIiwgXCJTYWxsaWVcIiwgXCJOZXR0aWVcIiwgXCJEZWxsYVwiLCBcIkxpenppZVwiLCBcIkZsb3JhXCIsIFwiU3VzaWVcIiwgXCJNYXVkXCIsIFwiTWFlXCIsIFwiRXR0YVwiLCBcIkhhcnJpZXRcIiwgXCJTYWRpZVwiLCBcIkNhcm9saW5lXCIsIFwiS2F0aWVcIiwgXCJMeWRpYVwiLCBcIkVsc2llXCIsIFwiS2F0ZVwiLCBcIlN1c2FuXCIsIFwiTW9sbGllXCIsIFwiQWxtYVwiLCBcIkFkZGllXCIsIFwiR2VvcmdpYVwiLCBcIkVsaXphXCIsIFwiTHVsdVwiLCBcIk5hbm5pZVwiLCBcIkxvdHRpZVwiLCBcIkFtYW5kYVwiLCBcIkJlbGxlXCIsIFwiQ2hhcmxvdHRlXCIsIFwiUmViZWNjYVwiLCBcIlJ1dGhcIiwgXCJWaW9sYVwiLCBcIk9saXZlXCIsIFwiQW1lbGlhXCIsIFwiSGFubmFoXCIsIFwiSmFuZVwiLCBcIlZpcmdpbmlhXCIsIFwiRW1pbHlcIiwgXCJNYXRpbGRhXCIsIFwiSXJlbmVcIiwgXCJLYXRocnluXCIsIFwiRXN0aGVyXCIsIFwiV2lsbGllXCIsIFwiSGVucmlldHRhXCIsIFwiT2xsaWVcIiwgXCJBbXlcIiwgXCJSYWNoZWxcIiwgXCJTYXJhXCIsIFwiRXN0ZWxsYVwiLCBcIlRoZXJlc2FcIiwgXCJBdWd1c3RhXCIsIFwiT3JhXCIsIFwiUGF1bGluZVwiLCBcIkpvc2llXCIsIFwiTG9sYVwiLCBcIlNvcGhpYVwiLCBcIkxlb25hXCIsIFwiQW5uZVwiLCBcIk1pbGRyZWRcIiwgXCJBbm5cIiwgXCJCZXVsYWhcIiwgXCJDYWxsaWVcIiwgXCJMb3VcIiwgXCJEZWxpYVwiLCBcIkVsZWFub3JcIiwgXCJCYXJiYXJhXCIsIFwiSXZhXCIsIFwiTG91aXNhXCIsIFwiTWFyaWFcIiwgXCJNYXltZVwiLCBcIkV2ZWx5blwiLCBcIkVzdGVsbGVcIiwgXCJOaW5hXCIsIFwiQmV0dHlcIiwgXCJNYXJpb25cIiwgXCJCZXR0aWVcIiwgXCJEb3JvdGh5XCIsIFwiTHVlbGxhXCIsIFwiSW5lelwiLCBcIkxlbGFcIiwgXCJSb3NpZVwiLCBcIkFsbGllXCIsIFwiTWlsbGllXCIsIFwiSmFuaWVcIiwgXCJDb3JuZWxpYVwiLCBcIlZpY3RvcmlhXCIsIFwiUnVieVwiLCBcIldpbmlmcmVkXCIsIFwiQWx0YVwiLCBcIkNlbGlhXCIsIFwiQ2hyaXN0aW5lXCIsIFwiQmVhdHJpY2VcIiwgXCJCaXJkaWVcIiwgXCJIYXJyaWV0dFwiLCBcIk1hYmxlXCIsIFwiTXlyYVwiLCBcIlNvcGhpZVwiLCBcIlRpbGxpZVwiLCBcIklzYWJlbFwiLCBcIlN5bHZpYVwiLCBcIkNhcm9seW5cIiwgXCJJc2FiZWxsZVwiLCBcIkxlaWxhXCIsIFwiU2FsbHlcIiwgXCJJbmFcIiwgXCJFc3NpZVwiLCBcIkJlcnRpZVwiLCBcIk5lbGxcIiwgXCJBbGJlcnRhXCIsIFwiS2F0aGFyaW5lXCIsIFwiTG9yYVwiLCBcIlJlbmFcIiwgXCJNaW5hXCIsIFwiUmhvZGFcIiwgXCJNYXRoaWxkYVwiLCBcIkFiYmllXCIsIFwiRXVsYVwiLCBcIkRvbGxpZVwiLCBcIkhldHRpZVwiLCBcIkV1bmljZVwiLCBcIkZhbm55XCIsIFwiT2xhXCIsIFwiTGVub3JhXCIsIFwiQWRlbGFpZGVcIiwgXCJDaHJpc3RpbmFcIiwgXCJMZWxpYVwiLCBcIk5lbGxlXCIsIFwiU3VlXCIsIFwiSm9oYW5uYVwiLCBcIkxpbGx5XCIsIFwiTHVjaW5kYVwiLCBcIk1pbmVydmFcIiwgXCJMZXR0aWVcIiwgXCJSb3hpZVwiLCBcIkN5bnRoaWFcIiwgXCJIZWxlbmFcIiwgXCJIaWxkYVwiLCBcIkh1bGRhXCIsIFwiQmVybmljZVwiLCBcIkdlbmV2aWV2ZVwiLCBcIkplYW5cIiwgXCJDb3JkZWxpYVwiLCBcIk1hcmlhblwiLCBcIkZyYW5jaXNcIiwgXCJKZWFuZXR0ZVwiLCBcIkFkZWxpbmVcIiwgXCJHdXNzaWVcIiwgXCJMZWFoXCIsIFwiTG9pc1wiLCBcIkx1cmFcIiwgXCJNaXR0aWVcIiwgXCJIYWxsaWVcIiwgXCJJc2FiZWxsYVwiLCBcIk9sZ2FcIiwgXCJQaG9lYmVcIiwgXCJUZXJlc2FcIiwgXCJIZXN0ZXJcIiwgXCJMaWRhXCIsIFwiTGluYVwiLCBcIldpbm5pZVwiLCBcIkNsYXVkaWFcIiwgXCJNYXJndWVyaXRlXCIsIFwiVmVyYVwiLCBcIkNlY2VsaWFcIiwgXCJCZXNzXCIsIFwiRW1pbGllXCIsIFwiSm9oblwiLCBcIlJvc2V0dGFcIiwgXCJWZXJuYVwiLCBcIk15cnRpZVwiLCBcIkNlY2lsaWFcIiwgXCJFbHZhXCIsIFwiT2xpdmlhXCIsIFwiT3BoZWxpYVwiLCBcIkdlb3JnaWVcIiwgXCJFbG5vcmFcIiwgXCJWaW9sZXRcIiwgXCJBZGVsZVwiLCBcIkxpbHlcIiwgXCJMaW5uaWVcIiwgXCJMb3JldHRhXCIsIFwiTWFkZ2VcIiwgXCJQb2xseVwiLCBcIlZpcmdpZVwiLCBcIkV1Z2VuaWFcIiwgXCJMdWNpbGVcIiwgXCJMdWNpbGxlXCIsIFwiTWFiZWxsZVwiLCBcIlJvc2FsaWVcIl0sXG4gICAgICAgICAgICAgICAgLy8gRGF0YSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZGF0aS5nb3YuaXQvZGF0YXNldC9jb211bmUtZGktZmlyZW56ZV8wMTYyXG4gICAgICAgICAgICAgICAgXCJpdFwiOiBbXCJBZGFcIiwgXCJBZHJpYW5hXCIsIFwiQWxlc3NhbmRyYVwiLCBcIkFsZXNzaWFcIiwgXCJBbGljZVwiLCBcIkFuZ2VsYVwiLCBcIkFubmFcIiwgXCJBbm5hIE1hcmlhXCIsIFwiQW5uYWxpc2FcIiwgXCJBbm5pdGFcIiwgXCJBbm51bnppYXRhXCIsIFwiQW50b25lbGxhXCIsIFwiQXJpYW5uYVwiLCBcIkFzaWFcIiwgXCJBc3N1bnRhXCIsIFwiQXVyb3JhXCIsIFwiQmFyYmFyYVwiLCBcIkJlYXRyaWNlXCIsIFwiQmVuZWRldHRhXCIsIFwiQmlhbmNhXCIsIFwiQnJ1bmFcIiwgXCJDYW1pbGxhXCIsIFwiQ2FybGFcIiwgXCJDYXJsb3R0YVwiLCBcIkNhcm1lbGFcIiwgXCJDYXJvbGluYVwiLCBcIkNhdGVyaW5hXCIsIFwiQ2F0aWFcIiwgXCJDZWNpbGlhXCIsIFwiQ2hpYXJhXCIsIFwiQ2luemlhXCIsIFwiQ2xhcmFcIiwgXCJDbGF1ZGlhXCIsIFwiQ29zdGFuemFcIiwgXCJDcmlzdGluYVwiLCBcIkRhbmllbGFcIiwgXCJEZWJvcmFcIiwgXCJEaWxldHRhXCIsIFwiRGluYVwiLCBcIkRvbmF0ZWxsYVwiLCBcIkVsZW5hXCIsIFwiRWxlb25vcmFcIiwgXCJFbGlzYVwiLCBcIkVsaXNhYmV0dGFcIiwgXCJFbWFudWVsYVwiLCBcIkVtbWFcIiwgXCJFdmFcIiwgXCJGZWRlcmljYVwiLCBcIkZlcm5hbmRhXCIsIFwiRmlvcmVsbGFcIiwgXCJGaW9yZW56YVwiLCBcIkZsb3JhXCIsIFwiRnJhbmNhXCIsIFwiRnJhbmNlc2NhXCIsIFwiR2FicmllbGxhXCIsIFwiR2FpYVwiLCBcIkdlbW1hXCIsIFwiR2lhZGFcIiwgXCJHaWFubmFcIiwgXCJHaW5hXCIsIFwiR2luZXZyYVwiLCBcIkdpb3JnaWFcIiwgXCJHaW92YW5uYVwiLCBcIkdpdWxpYVwiLCBcIkdpdWxpYW5hXCIsIFwiR2l1c2VwcGFcIiwgXCJHaXVzZXBwaW5hXCIsIFwiR3JhemlhXCIsIFwiR3JhemllbGxhXCIsIFwiR3JldGFcIiwgXCJJZGFcIiwgXCJJbGFyaWFcIiwgXCJJbmVzXCIsIFwiSW9sYW5kYVwiLCBcIklyZW5lXCIsIFwiSXJtYVwiLCBcIklzYWJlbGxhXCIsIFwiSmVzc2ljYVwiLCBcIkxhdXJhXCIsIFwiTGVkYVwiLCBcIkxldGl6aWFcIiwgXCJMaWNpYVwiLCBcIkxpZGlhXCIsIFwiTGlsaWFuYVwiLCBcIkxpbmFcIiwgXCJMaW5kYVwiLCBcIkxpc2FcIiwgXCJMaXZpYVwiLCBcIkxvcmV0dGFcIiwgXCJMdWFuYVwiLCBcIkx1Y2lhXCIsIFwiTHVjaWFuYVwiLCBcIkx1Y3JlemlhXCIsIFwiTHVpc2FcIiwgXCJNYW51ZWxhXCIsIFwiTWFyYVwiLCBcIk1hcmNlbGxhXCIsIFwiTWFyZ2hlcml0YVwiLCBcIk1hcmlhXCIsIFwiTWFyaWEgQ3Jpc3RpbmFcIiwgXCJNYXJpYSBHcmF6aWFcIiwgXCJNYXJpYSBMdWlzYVwiLCBcIk1hcmlhIFBpYVwiLCBcIk1hcmlhIFRlcmVzYVwiLCBcIk1hcmluYVwiLCBcIk1hcmlzYVwiLCBcIk1hcnRhXCIsIFwiTWFydGluYVwiLCBcIk1hcnppYVwiLCBcIk1hdGlsZGVcIiwgXCJNZWxpc3NhXCIsIFwiTWljaGVsYVwiLCBcIk1pbGVuYVwiLCBcIk1pcmVsbGFcIiwgXCJNb25pY2FcIiwgXCJOYXRhbGluYVwiLCBcIk5lbGxhXCIsIFwiTmljb2xldHRhXCIsIFwiTm9lbWlcIiwgXCJPbGdhXCIsIFwiUGFvbGFcIiwgXCJQYXRyaXppYVwiLCBcIlBpZXJhXCIsIFwiUGllcmluYVwiLCBcIlJhZmZhZWxsYVwiLCBcIlJlYmVjY2FcIiwgXCJSZW5hdGFcIiwgXCJSaW5hXCIsIFwiUml0YVwiLCBcIlJvYmVydGFcIiwgXCJSb3NhXCIsIFwiUm9zYW5uYVwiLCBcIlJvc3NhbmFcIiwgXCJSb3NzZWxsYVwiLCBcIlNhYnJpbmFcIiwgXCJTYW5kcmFcIiwgXCJTYXJhXCIsIFwiU2VyZW5hXCIsIFwiU2lsdmFuYVwiLCBcIlNpbHZpYVwiLCBcIlNpbW9uYVwiLCBcIlNpbW9uZXR0YVwiLCBcIlNvZmlhXCIsIFwiU29uaWFcIiwgXCJTdGVmYW5pYVwiLCBcIlN1c2FubmFcIiwgXCJUZXJlc2FcIiwgXCJUaW5hXCIsIFwiVGl6aWFuYVwiLCBcIlRvc2NhXCIsIFwiVmFsZW50aW5hXCIsIFwiVmFsZXJpYVwiLCBcIlZhbmRhXCIsIFwiVmFuZXNzYVwiLCBcIlZhbm5hXCIsIFwiVmVyYVwiLCBcIlZlcm9uaWNhXCIsIFwiVmlsbWFcIiwgXCJWaW9sYVwiLCBcIlZpcmdpbmlhXCIsIFwiVml0dG9yaWFcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsYXN0TmFtZXM6IHtcbiAgICAgICAgICAgIFwiZW5cIjogWydTbWl0aCcsICdKb2huc29uJywgJ1dpbGxpYW1zJywgJ0pvbmVzJywgJ0Jyb3duJywgJ0RhdmlzJywgJ01pbGxlcicsICdXaWxzb24nLCAnTW9vcmUnLCAnVGF5bG9yJywgJ0FuZGVyc29uJywgJ1Rob21hcycsICdKYWNrc29uJywgJ1doaXRlJywgJ0hhcnJpcycsICdNYXJ0aW4nLCAnVGhvbXBzb24nLCAnR2FyY2lhJywgJ01hcnRpbmV6JywgJ1JvYmluc29uJywgJ0NsYXJrJywgJ1JvZHJpZ3VleicsICdMZXdpcycsICdMZWUnLCAnV2Fsa2VyJywgJ0hhbGwnLCAnQWxsZW4nLCAnWW91bmcnLCAnSGVybmFuZGV6JywgJ0tpbmcnLCAnV3JpZ2h0JywgJ0xvcGV6JywgJ0hpbGwnLCAnU2NvdHQnLCAnR3JlZW4nLCAnQWRhbXMnLCAnQmFrZXInLCAnR29uemFsZXonLCAnTmVsc29uJywgJ0NhcnRlcicsICdNaXRjaGVsbCcsICdQZXJleicsICdSb2JlcnRzJywgJ1R1cm5lcicsICdQaGlsbGlwcycsICdDYW1wYmVsbCcsICdQYXJrZXInLCAnRXZhbnMnLCAnRWR3YXJkcycsICdDb2xsaW5zJywgJ1N0ZXdhcnQnLCAnU2FuY2hleicsICdNb3JyaXMnLCAnUm9nZXJzJywgJ1JlZWQnLCAnQ29vaycsICdNb3JnYW4nLCAnQmVsbCcsICdNdXJwaHknLCAnQmFpbGV5JywgJ1JpdmVyYScsICdDb29wZXInLCAnUmljaGFyZHNvbicsICdDb3gnLCAnSG93YXJkJywgJ1dhcmQnLCAnVG9ycmVzJywgJ1BldGVyc29uJywgJ0dyYXknLCAnUmFtaXJleicsICdKYW1lcycsICdXYXRzb24nLCAnQnJvb2tzJywgJ0tlbGx5JywgJ1NhbmRlcnMnLCAnUHJpY2UnLCAnQmVubmV0dCcsICdXb29kJywgJ0Jhcm5lcycsICdSb3NzJywgJ0hlbmRlcnNvbicsICdDb2xlbWFuJywgJ0plbmtpbnMnLCAnUGVycnknLCAnUG93ZWxsJywgJ0xvbmcnLCAnUGF0dGVyc29uJywgJ0h1Z2hlcycsICdGbG9yZXMnLCAnV2FzaGluZ3RvbicsICdCdXRsZXInLCAnU2ltbW9ucycsICdGb3N0ZXInLCAnR29uemFsZXMnLCAnQnJ5YW50JywgJ0FsZXhhbmRlcicsICdSdXNzZWxsJywgJ0dyaWZmaW4nLCAnRGlheicsICdIYXllcycsICdNeWVycycsICdGb3JkJywgJ0hhbWlsdG9uJywgJ0dyYWhhbScsICdTdWxsaXZhbicsICdXYWxsYWNlJywgJ1dvb2RzJywgJ0NvbGUnLCAnV2VzdCcsICdKb3JkYW4nLCAnT3dlbnMnLCAnUmV5bm9sZHMnLCAnRmlzaGVyJywgJ0VsbGlzJywgJ0hhcnJpc29uJywgJ0dpYnNvbicsICdNY0RvbmFsZCcsICdDcnV6JywgJ01hcnNoYWxsJywgJ09ydGl6JywgJ0dvbWV6JywgJ011cnJheScsICdGcmVlbWFuJywgJ1dlbGxzJywgJ1dlYmInLCAnU2ltcHNvbicsICdTdGV2ZW5zJywgJ1R1Y2tlcicsICdQb3J0ZXInLCAnSHVudGVyJywgJ0hpY2tzJywgJ0NyYXdmb3JkJywgJ0hlbnJ5JywgJ0JveWQnLCAnTWFzb24nLCAnTW9yYWxlcycsICdLZW5uZWR5JywgJ1dhcnJlbicsICdEaXhvbicsICdSYW1vcycsICdSZXllcycsICdCdXJucycsICdHb3Jkb24nLCAnU2hhdycsICdIb2xtZXMnLCAnUmljZScsICdSb2JlcnRzb24nLCAnSHVudCcsICdCbGFjaycsICdEYW5pZWxzJywgJ1BhbG1lcicsICdNaWxscycsICdOaWNob2xzJywgJ0dyYW50JywgJ0tuaWdodCcsICdGZXJndXNvbicsICdSb3NlJywgJ1N0b25lJywgJ0hhd2tpbnMnLCAnRHVubicsICdQZXJraW5zJywgJ0h1ZHNvbicsICdTcGVuY2VyJywgJ0dhcmRuZXInLCAnU3RlcGhlbnMnLCAnUGF5bmUnLCAnUGllcmNlJywgJ0JlcnJ5JywgJ01hdHRoZXdzJywgJ0Fybm9sZCcsICdXYWduZXInLCAnV2lsbGlzJywgJ1JheScsICdXYXRraW5zJywgJ09sc29uJywgJ0NhcnJvbGwnLCAnRHVuY2FuJywgJ1NueWRlcicsICdIYXJ0JywgJ0N1bm5pbmdoYW0nLCAnQnJhZGxleScsICdMYW5lJywgJ0FuZHJld3MnLCAnUnVpeicsICdIYXJwZXInLCAnRm94JywgJ1JpbGV5JywgJ0FybXN0cm9uZycsICdDYXJwZW50ZXInLCAnV2VhdmVyJywgJ0dyZWVuZScsICdMYXdyZW5jZScsICdFbGxpb3R0JywgJ0NoYXZleicsICdTaW1zJywgJ0F1c3RpbicsICdQZXRlcnMnLCAnS2VsbGV5JywgJ0ZyYW5rbGluJywgJ0xhd3NvbicsICdGaWVsZHMnLCAnR3V0aWVycmV6JywgJ1J5YW4nLCAnU2NobWlkdCcsICdDYXJyJywgJ1Zhc3F1ZXonLCAnQ2FzdGlsbG8nLCAnV2hlZWxlcicsICdDaGFwbWFuJywgJ09saXZlcicsICdNb250Z29tZXJ5JywgJ1JpY2hhcmRzJywgJ1dpbGxpYW1zb24nLCAnSm9obnN0b24nLCAnQmFua3MnLCAnTWV5ZXInLCAnQmlzaG9wJywgJ01jQ295JywgJ0hvd2VsbCcsICdBbHZhcmV6JywgJ01vcnJpc29uJywgJ0hhbnNlbicsICdGZXJuYW5kZXonLCAnR2FyemEnLCAnSGFydmV5JywgJ0xpdHRsZScsICdCdXJ0b24nLCAnU3RhbmxleScsICdOZ3V5ZW4nLCAnR2VvcmdlJywgJ0phY29icycsICdSZWlkJywgJ0tpbScsICdGdWxsZXInLCAnTHluY2gnLCAnRGVhbicsICdHaWxiZXJ0JywgJ0dhcnJldHQnLCAnUm9tZXJvJywgJ1dlbGNoJywgJ0xhcnNvbicsICdGcmF6aWVyJywgJ0J1cmtlJywgJ0hhbnNvbicsICdEYXknLCAnTWVuZG96YScsICdNb3Jlbm8nLCAnQm93bWFuJywgJ01lZGluYScsICdGb3dsZXInLCAnQnJld2VyJywgJ0hvZmZtYW4nLCAnQ2FybHNvbicsICdTaWx2YScsICdQZWFyc29uJywgJ0hvbGxhbmQnLCAnRG91Z2xhcycsICdGbGVtaW5nJywgJ0plbnNlbicsICdWYXJnYXMnLCAnQnlyZCcsICdEYXZpZHNvbicsICdIb3BraW5zJywgJ01heScsICdUZXJyeScsICdIZXJyZXJhJywgJ1dhZGUnLCAnU290bycsICdXYWx0ZXJzJywgJ0N1cnRpcycsICdOZWFsJywgJ0NhbGR3ZWxsJywgJ0xvd2UnLCAnSmVubmluZ3MnLCAnQmFybmV0dCcsICdHcmF2ZXMnLCAnSmltZW5leicsICdIb3J0b24nLCAnU2hlbHRvbicsICdCYXJyZXR0JywgJ09icmllbicsICdDYXN0cm8nLCAnU3V0dG9uJywgJ0dyZWdvcnknLCAnTWNLaW5uZXknLCAnTHVjYXMnLCAnTWlsZXMnLCAnQ3JhaWcnLCAnUm9kcmlxdWV6JywgJ0NoYW1iZXJzJywgJ0hvbHQnLCAnTGFtYmVydCcsICdGbGV0Y2hlcicsICdXYXR0cycsICdCYXRlcycsICdIYWxlJywgJ1Job2RlcycsICdQZW5hJywgJ0JlY2snLCAnTmV3bWFuJywgJ0hheW5lcycsICdNY0RhbmllbCcsICdNZW5kZXonLCAnQnVzaCcsICdWYXVnaG4nLCAnUGFya3MnLCAnRGF3c29uJywgJ1NhbnRpYWdvJywgJ05vcnJpcycsICdIYXJkeScsICdMb3ZlJywgJ1N0ZWVsZScsICdDdXJyeScsICdQb3dlcnMnLCAnU2NodWx0eicsICdCYXJrZXInLCAnR3V6bWFuJywgJ1BhZ2UnLCAnTXVub3onLCAnQmFsbCcsICdLZWxsZXInLCAnQ2hhbmRsZXInLCAnV2ViZXInLCAnTGVvbmFyZCcsICdXYWxzaCcsICdMeW9ucycsICdSYW1zZXknLCAnV29sZmUnLCAnU2NobmVpZGVyJywgJ011bGxpbnMnLCAnQmVuc29uJywgJ1NoYXJwJywgJ0Jvd2VuJywgJ0RhbmllbCcsICdCYXJiZXInLCAnQ3VtbWluZ3MnLCAnSGluZXMnLCAnQmFsZHdpbicsICdHcmlmZml0aCcsICdWYWxkZXonLCAnSHViYmFyZCcsICdTYWxhemFyJywgJ1JlZXZlcycsICdXYXJuZXInLCAnU3RldmVuc29uJywgJ0J1cmdlc3MnLCAnU2FudG9zJywgJ1RhdGUnLCAnQ3Jvc3MnLCAnR2FybmVyJywgJ01hbm4nLCAnTWFjaycsICdNb3NzJywgJ1Rob3JudG9uJywgJ0Rlbm5pcycsICdNY0dlZScsICdGYXJtZXInLCAnRGVsZ2FkbycsICdBZ3VpbGFyJywgJ1ZlZ2EnLCAnR2xvdmVyJywgJ01hbm5pbmcnLCAnQ29oZW4nLCAnSGFybW9uJywgJ1JvZGdlcnMnLCAnUm9iYmlucycsICdOZXd0b24nLCAnVG9kZCcsICdCbGFpcicsICdIaWdnaW5zJywgJ0luZ3JhbScsICdSZWVzZScsICdDYW5ub24nLCAnU3RyaWNrbGFuZCcsICdUb3duc2VuZCcsICdQb3R0ZXInLCAnR29vZHdpbicsICdXYWx0b24nLCAnUm93ZScsICdIYW1wdG9uJywgJ09ydGVnYScsICdQYXR0b24nLCAnU3dhbnNvbicsICdKb3NlcGgnLCAnRnJhbmNpcycsICdHb29kbWFuJywgJ01hbGRvbmFkbycsICdZYXRlcycsICdCZWNrZXInLCAnRXJpY2tzb24nLCAnSG9kZ2VzJywgJ1Jpb3MnLCAnQ29ubmVyJywgJ0Fka2lucycsICdXZWJzdGVyJywgJ05vcm1hbicsICdNYWxvbmUnLCAnSGFtbW9uZCcsICdGbG93ZXJzJywgJ0NvYmInLCAnTW9vZHknLCAnUXVpbm4nLCAnQmxha2UnLCAnTWF4d2VsbCcsICdQb3BlJywgJ0Zsb3lkJywgJ09zYm9ybmUnLCAnUGF1bCcsICdNY0NhcnRoeScsICdHdWVycmVybycsICdMaW5kc2V5JywgJ0VzdHJhZGEnLCAnU2FuZG92YWwnLCAnR2liYnMnLCAnVHlsZXInLCAnR3Jvc3MnLCAnRml0emdlcmFsZCcsICdTdG9rZXMnLCAnRG95bGUnLCAnU2hlcm1hbicsICdTYXVuZGVycycsICdXaXNlJywgJ0NvbG9uJywgJ0dpbGwnLCAnQWx2YXJhZG8nLCAnR3JlZXInLCAnUGFkaWxsYScsICdTaW1vbicsICdXYXRlcnMnLCAnTnVuZXonLCAnQmFsbGFyZCcsICdTY2h3YXJ0eicsICdNY0JyaWRlJywgJ0hvdXN0b24nLCAnQ2hyaXN0ZW5zZW4nLCAnS2xlaW4nLCAnUHJhdHQnLCAnQnJpZ2dzJywgJ1BhcnNvbnMnLCAnTWNMYXVnaGxpbicsICdaaW1tZXJtYW4nLCAnRnJlbmNoJywgJ0J1Y2hhbmFuJywgJ01vcmFuJywgJ0NvcGVsYW5kJywgJ1JveScsICdQaXR0bWFuJywgJ0JyYWR5JywgJ01jQ29ybWljaycsICdIb2xsb3dheScsICdCcm9jaycsICdQb29sZScsICdGcmFuaycsICdMb2dhbicsICdPd2VuJywgJ0Jhc3MnLCAnTWFyc2gnLCAnRHJha2UnLCAnV29uZycsICdKZWZmZXJzb24nLCAnUGFyaycsICdNb3J0b24nLCAnQWJib3R0JywgJ1NwYXJrcycsICdQYXRyaWNrJywgJ05vcnRvbicsICdIdWZmJywgJ0NsYXl0b24nLCAnTWFzc2V5JywgJ0xsb3lkJywgJ0ZpZ3Vlcm9hJywgJ0NhcnNvbicsICdCb3dlcnMnLCAnUm9iZXJzb24nLCAnQmFydG9uJywgJ1RyYW4nLCAnTGFtYicsICdIYXJyaW5ndG9uJywgJ0Nhc2V5JywgJ0Jvb25lJywgJ0NvcnRleicsICdDbGFya2UnLCAnTWF0aGlzJywgJ1NpbmdsZXRvbicsICdXaWxraW5zJywgJ0NhaW4nLCAnQnJ5YW4nLCAnVW5kZXJ3b29kJywgJ0hvZ2FuJywgJ01jS2VuemllJywgJ0NvbGxpZXInLCAnTHVuYScsICdQaGVscHMnLCAnTWNHdWlyZScsICdBbGxpc29uJywgJ0JyaWRnZXMnLCAnV2lsa2Vyc29uJywgJ05hc2gnLCAnU3VtbWVycycsICdBdGtpbnMnXSxcbiAgICAgICAgICAgICAgICAvLyBEYXRhIHRha2VuIGZyb20gaHR0cDovL3d3dy5kYXRpLmdvdi5pdC9kYXRhc2V0L2NvbXVuZS1kaS1maXJlbnplXzAxNjQgKGZpcnN0IDEwMDApXG4gICAgICAgICAgICBcIml0XCI6IFtcIkFjY2lhaVwiLCBcIkFnbGlldHRpXCIsIFwiQWdvc3RpbmlcIiwgXCJBZ3Jlc3RpXCIsIFwiQWhtZWRcIiwgXCJBaWF6emlcIiwgXCJBbGJhbmVzZVwiLCBcIkFsYmVydGlcIiwgXCJBbGVzc2lcIiwgXCJBbGZhbmlcIiwgXCJBbGluYXJpXCIsIFwiQWx0ZXJpbmlcIiwgXCJBbWF0b1wiLCBcIkFtbWFubmF0aVwiLCBcIkFuY2lsbG90dGlcIiwgXCJBbmRyZWlcIiwgXCJBbmRyZWluaVwiLCBcIkFuZHJlb25pXCIsIFwiQW5nZWxpXCIsIFwiQW5pY2hpbmlcIiwgXCJBbnRvbmVsbGlcIiwgXCJBbnRvbmluaVwiLCBcIkFyZW5hXCIsIFwiQXJpYW5pXCIsIFwiQXJuZXRvbGlcIiwgXCJBcnJpZ2hpXCIsIFwiQmFjY2FuaVwiLCBcIkJhY2NldHRpXCIsIFwiQmFjY2lcIiwgXCJCYWNoZXJpbmlcIiwgXCJCYWRpaVwiLCBcIkJhZ2dpYW5pXCIsIFwiQmFnbGlvbmlcIiwgXCJCYWduaVwiLCBcIkJhZ25vbGlcIiwgXCJCYWxkYXNzaW5pXCIsIFwiQmFsZGlcIiwgXCJCYWxkaW5pXCIsIFwiQmFsbGVyaW5pXCIsIFwiQmFsbGlcIiwgXCJCYWxsaW5pXCIsIFwiQmFsbG9uaVwiLCBcIkJhbWJpXCIsIFwiQmFuY2hpXCIsIFwiQmFuZGluZWxsaVwiLCBcIkJhbmRpbmlcIiwgXCJCYW5pXCIsIFwiQmFyYmV0dGlcIiwgXCJCYXJiaWVyaVwiLCBcIkJhcmNoaWVsbGlcIiwgXCJCYXJkYXp6aVwiLCBcIkJhcmRlbGxpXCIsIFwiQmFyZGlcIiwgXCJCYXJkdWNjaVwiLCBcIkJhcmdlbGxpbmlcIiwgXCJCYXJnaWFjY2hpXCIsIFwiQmFybmlcIiwgXCJCYXJvbmNlbGxpXCIsIFwiQmFyb25jaW5pXCIsIFwiQmFyb25lXCIsIFwiQmFyb25pXCIsIFwiQmFyb250aVwiLCBcIkJhcnRhbGVzaVwiLCBcIkJhcnRvbGV0dGlcIiwgXCJCYXJ0b2xpXCIsIFwiQmFydG9saW5pXCIsIFwiQmFydG9sb25pXCIsIFwiQmFydG9sb3p6aVwiLCBcIkJhc2FnbmlcIiwgXCJCYXNpbGVcIiwgXCJCYXNzaVwiLCBcIkJhdGFjY2hpXCIsIFwiQmF0dGFnbGlhXCIsIFwiQmF0dGFnbGluaVwiLCBcIkJhdXNpXCIsIFwiQmVjYWdsaVwiLCBcIkJlY2F0dGluaVwiLCBcIkJlY2NoaVwiLCBcIkJlY3VjY2lcIiwgXCJCZWxsYW5kaVwiLCBcIkJlbGxlc2lcIiwgXCJCZWxsaVwiLCBcIkJlbGxpbmlcIiwgXCJCZWxsdWNjaVwiLCBcIkJlbmNpbmlcIiwgXCJCZW5lZGV0dGlcIiwgXCJCZW5lbGxpXCIsIFwiQmVuaVwiLCBcIkJlbmluaVwiLCBcIkJlbnNpXCIsIFwiQmVudWNjaVwiLCBcIkJlbnZlbnV0aVwiLCBcIkJlcmxpbmNpb25pXCIsIFwiQmVybmFjY2hpb25pXCIsIFwiQmVybmFyZGlcIiwgXCJCZXJuYXJkaW5pXCIsIFwiQmVybmlcIiwgXCJCZXJuaW5pXCIsIFwiQmVydGVsbGlcIiwgXCJCZXJ0aVwiLCBcIkJlcnRpbmlcIiwgXCJCZXNzaVwiLCBcIkJldHRpXCIsIFwiQmV0dGluaVwiLCBcIkJpYWdpXCIsIFwiQmlhZ2luaVwiLCBcIkJpYWdpb25pXCIsIFwiQmlhZ2lvdHRpXCIsIFwiQmlhbmNhbGFuaVwiLCBcIkJpYW5jaGlcIiwgXCJCaWFuY2hpbmlcIiwgXCJCaWFuY29cIiwgXCJCaWZmb2xpXCIsIFwiQmlnYXp6aVwiLCBcIkJpZ2lcIiwgXCJCaWxpb3R0aVwiLCBcIkJpbGxpXCIsIFwiQmluYXp6aVwiLCBcIkJpbmRpXCIsIFwiQmluaVwiLCBcIkJpb25kaVwiLCBcIkJpenphcnJpXCIsIFwiQm9jY2lcIiwgXCJCb2dhbmlcIiwgXCJCb2xvZ25lc2lcIiwgXCJCb25haXV0aVwiLCBcIkJvbmFubmlcIiwgXCJCb25jaWFuaVwiLCBcIkJvbmNpbmVsbGlcIiwgXCJCb25kaVwiLCBcIkJvbmVjaGlcIiwgXCJCb25naW5pXCIsIFwiQm9uaVwiLCBcIkJvbmluaVwiLCBcIkJvcmNoaVwiLCBcIkJvcmV0dGlcIiwgXCJCb3JnaGlcIiwgXCJCb3JnaGluaVwiLCBcIkJvcmdpb2xpXCIsIFwiQm9ycmlcIiwgXCJCb3JzZWxsaVwiLCBcIkJvc2NoaVwiLCBcIkJvdHRhaVwiLCBcIkJyYWNjaVwiLCBcIkJyYWNjaW5pXCIsIFwiQnJhbmRpXCIsIFwiQnJhc2NoaVwiLCBcIkJyYXZpXCIsIFwiQnJhenppbmlcIiwgXCJCcmVzY2hpXCIsIFwiQnJpbGxpXCIsIFwiQnJpenppXCIsIFwiQnJvZ2VsbGlcIiwgXCJCcm9naVwiLCBcIkJyb2dpb25pXCIsIFwiQnJ1bmVsbGlcIiwgXCJCcnVuZXR0aVwiLCBcIkJydW5pXCIsIFwiQnJ1bm9cIiwgXCJCcnVub3JpXCIsIFwiQnJ1c2NoaVwiLCBcIkJ1Y2NpXCIsIFwiQnVjY2lhcmVsbGlcIiwgXCJCdWNjaW9uaVwiLCBcIkJ1Y2VsbGlcIiwgXCJCdWxsaVwiLCBcIkJ1cmJlcmlcIiwgXCJCdXJjaGlcIiwgXCJCdXJnYXNzaVwiLCBcIkJ1cnJvbmlcIiwgXCJCdXNzb3R0aVwiLCBcIkJ1dGlcIiwgXCJDYWNpb2xsaVwiLCBcIkNhaWFuaVwiLCBcIkNhbGFicmVzZVwiLCBcIkNhbGFtYWlcIiwgXCJDYWxhbWFuZHJlaVwiLCBcIkNhbGRpbmlcIiwgXCJDYWxvJ1wiLCBcIkNhbG9uYWNpXCIsIFwiQ2Fsb3NpXCIsIFwiQ2FsdmVsbGlcIiwgXCJDYW1iaVwiLCBcIkNhbWljaW90dG9saVwiLCBcIkNhbW1lbGxpXCIsIFwiQ2FtbWlsbGlcIiwgXCJDYW1wb2xtaVwiLCBcIkNhbnRpbmlcIiwgXCJDYXBhbm5pXCIsIFwiQ2FwZWNjaGlcIiwgXCJDYXBvbmlcIiwgXCJDYXBwZWxsZXR0aVwiLCBcIkNhcHBlbGxpXCIsIFwiQ2FwcGVsbGluaVwiLCBcIkNhcHB1Z2lcIiwgXCJDYXByZXR0aVwiLCBcIkNhcHV0b1wiLCBcIkNhcmJvbmVcIiwgXCJDYXJib25pXCIsIFwiQ2FyZGluaVwiLCBcIkNhcmxlc2lcIiwgXCJDYXJsZXR0aVwiLCBcIkNhcmxpXCIsIFwiQ2Fyb3RpXCIsIFwiQ2Fyb3R0aVwiLCBcIkNhcnJhaVwiLCBcIkNhcnJhcmVzaVwiLCBcIkNhcnRhXCIsIFwiQ2FydXNvXCIsIFwiQ2FzYWxpbmlcIiwgXCJDYXNhdGlcIiwgXCJDYXNlbGxpXCIsIFwiQ2FzaW5pXCIsIFwiQ2FzdGFnbm9saVwiLCBcIkNhc3RlbGxhbmlcIiwgXCJDYXN0ZWxsaVwiLCBcIkNhc3RlbGx1Y2NpXCIsIFwiQ2F0YWxhbm9cIiwgXCJDYXRhcnppXCIsIFwiQ2F0ZWxhbmlcIiwgXCJDYXZhY2lvY2NoaVwiLCBcIkNhdmFsbGFyb1wiLCBcIkNhdmFsbGluaVwiLCBcIkNhdmljY2hpXCIsIFwiQ2F2aW5pXCIsIFwiQ2VjY2FyZWxsaVwiLCBcIkNlY2NhdGVsbGlcIiwgXCJDZWNjaGVyZWxsaVwiLCBcIkNlY2NoZXJpbmlcIiwgXCJDZWNjaGlcIiwgXCJDZWNjaGluaVwiLCBcIkNlY2NvbmlcIiwgXCJDZWlcIiwgXCJDZWxsYWlcIiwgXCJDZWxsaVwiLCBcIkNlbGxpbmlcIiwgXCJDZW5jZXR0aVwiLCBcIkNlbmlcIiwgXCJDZW5uaVwiLCBcIkNlcmJhaVwiLCBcIkNlc2FyaVwiLCBcIkNlc2VyaVwiLCBcIkNoZWNjYWNjaVwiLCBcIkNoZWNjaGlcIiwgXCJDaGVjY3VjY2lcIiwgXCJDaGVsaVwiLCBcIkNoZWxsaW5pXCIsIFwiQ2hlblwiLCBcIkNoZW5nXCIsIFwiQ2hlcmljaVwiLCBcIkNoZXJ1YmluaVwiLCBcIkNoaWFyYW1vbnRpXCIsIFwiQ2hpYXJhbnRpbmlcIiwgXCJDaGlhcmVsbGlcIiwgXCJDaGlhcmlcIiwgXCJDaGlhcmluaVwiLCBcIkNoaWFydWdpXCIsIFwiQ2hpYXZhY2NpXCIsIFwiQ2hpZXNpXCIsIFwiQ2hpbWVudGlcIiwgXCJDaGluaVwiLCBcIkNoaXJpY2lcIiwgXCJDaGl0aVwiLCBcIkNpYWJhdHRpXCIsIFwiQ2lhbXBpXCIsIFwiQ2lhbmNoaVwiLCBcIkNpYW5mYW5lbGxpXCIsIFwiQ2lhbmZlcm9uaVwiLCBcIkNpYW5pXCIsIFwiQ2lhcGV0dGlcIiwgXCJDaWFwcGlcIiwgXCJDaWFyZGlcIiwgXCJDaWF0dGlcIiwgXCJDaWNhbGlcIiwgXCJDaWNjb25lXCIsIFwiQ2luZWxsaVwiLCBcIkNpbmlcIiwgXCJDaW9iYW51XCIsIFwiQ2lvbGxpXCIsIFwiQ2lvbmlcIiwgXCJDaXByaWFuaVwiLCBcIkNpcmlsbG9cIiwgXCJDaXJyaVwiLCBcIkNpdWNjaGlcIiwgXCJDaXVmZmlcIiwgXCJDaXVsbGlcIiwgXCJDaXVsbGluaVwiLCBcIkNsZW1lbnRlXCIsIFwiQ29jY2hpXCIsIFwiQ29nbm9tZVwiLCBcIkNvbGlcIiwgXCJDb2xsaW5pXCIsIFwiQ29sb21ib1wiLCBcIkNvbHppXCIsIFwiQ29tcGFyaW5pXCIsIFwiQ29uZm9ydGlcIiwgXCJDb25zaWdsaVwiLCBcIkNvbnRlXCIsIFwiQ29udGlcIiwgXCJDb250aW5pXCIsIFwiQ29wcGluaVwiLCBcIkNvcHBvbGFcIiwgXCJDb3JzaVwiLCBcIkNvcnNpbmlcIiwgXCJDb3J0aVwiLCBcIkNvcnRpbmlcIiwgXCJDb3NpXCIsIFwiQ29zdGFcIiwgXCJDb3N0YW50aW5pXCIsIFwiQ29zdGFudGlub1wiLCBcIkNvenppXCIsIFwiQ3Jlc2NpXCIsIFwiQ3Jlc2Npb2xpXCIsIFwiQ3Jlc3RpXCIsIFwiQ3JpbmlcIiwgXCJDdXJyYWRpXCIsIFwiRCdBZ29zdGlub1wiLCBcIkQnQWxlc3NhbmRyb1wiLCBcIkQnQW1pY29cIiwgXCJEJ0FuZ2Vsb1wiLCBcIkRhZGRpXCIsIFwiRGFpbmVsbGlcIiwgXCJEYWxsYWlcIiwgXCJEYW50aVwiLCBcIkRhdml0dGlcIiwgXCJEZSBBbmdlbGlzXCIsIFwiRGUgTHVjYVwiLCBcIkRlIE1hcmNvXCIsIFwiRGUgUm9zYVwiLCBcIkRlIFNhbnRpc1wiLCBcIkRlIFNpbW9uZVwiLCBcIkRlIFZpdGFcIiwgXCJEZWdsJ0lubm9jZW50aVwiLCBcIkRlZ2xpIElubm9jZW50aVwiLCBcIkRlaVwiLCBcIkRlbCBMdW5nb1wiLCBcIkRlbCBSZVwiLCBcIkRpIE1hcmNvXCIsIFwiRGkgU3RlZmFub1wiLCBcIkRpbmlcIiwgXCJEaW9wXCIsIFwiRG9icmVcIiwgXCJEb2xmaVwiLCBcIkRvbmF0aVwiLCBcIkRvbmRvbGlcIiwgXCJEb25nXCIsIFwiRG9ubmluaVwiLCBcIkR1Y2NpXCIsIFwiRHVtaXRydVwiLCBcIkVybWluaVwiLCBcIkVzcG9zaXRvXCIsIFwiRXZhbmdlbGlzdGlcIiwgXCJGYWJicmlcIiwgXCJGYWJicmluaVwiLCBcIkZhYmJyaXp6aVwiLCBcIkZhYmJyb25pXCIsIFwiRmFiYnJ1Y2NpXCIsIFwiRmFiaWFuaVwiLCBcIkZhY2NoaW5pXCIsIFwiRmFnZ2lcIiwgXCJGYWdpb2xpXCIsIFwiRmFpbGxpXCIsIFwiRmFpbmlcIiwgXCJGYWxjaWFuaVwiLCBcIkZhbGNpbmlcIiwgXCJGYWxjb25lXCIsIFwiRmFsbGFuaVwiLCBcIkZhbG9ybmlcIiwgXCJGYWxzaW5pXCIsIFwiRmFsdWdpYW5pXCIsIFwiRmFuY2VsbGlcIiwgXCJGYW5lbGxpXCIsIFwiRmFuZXR0aVwiLCBcIkZhbmZhbmlcIiwgXCJGYW5pXCIsIFwiRmFudGFwcGllJ1wiLCBcIkZhbnRlY2hpXCIsIFwiRmFudGlcIiwgXCJGYW50aW5pXCIsIFwiRmFudG9uaVwiLCBcIkZhcmluYVwiLCBcIkZhdHRvcmlcIiwgXCJGYXZpbGxpXCIsIFwiRmVkaVwiLCBcIkZlaVwiLCBcIkZlcnJhbnRlXCIsIFwiRmVycmFyYVwiLCBcIkZlcnJhcmlcIiwgXCJGZXJyYXJvXCIsIFwiRmVycmV0dGlcIiwgXCJGZXJyaVwiLCBcIkZlcnJpbmlcIiwgXCJGZXJyb25pXCIsIFwiRmlhc2NoaVwiLCBcIkZpYmJpXCIsIFwiRmllc29saVwiLCBcIkZpbGlwcGlcIiwgXCJGaWxpcHBpbmlcIiwgXCJGaW5pXCIsIFwiRmlvcmF2YW50aVwiLCBcIkZpb3JlXCIsIFwiRmlvcmVudGluaVwiLCBcIkZpb3JpbmlcIiwgXCJGaXNzaVwiLCBcIkZvY2FyZGlcIiwgXCJGb2dnaVwiLCBcIkZvbnRhbmFcIiwgXCJGb250YW5lbGxpXCIsIFwiRm9udGFuaVwiLCBcIkZvcmNvbmlcIiwgXCJGb3JtaWdsaVwiLCBcIkZvcnRlXCIsIFwiRm9ydGlcIiwgXCJGb3J0aW5pXCIsIFwiRm9zc2F0aVwiLCBcIkZvc3NpXCIsIFwiRnJhbmNhbGFuY2lcIiwgXCJGcmFuY2VzY2hpXCIsIFwiRnJhbmNlc2NoaW5pXCIsIFwiRnJhbmNoaVwiLCBcIkZyYW5jaGluaVwiLCBcIkZyYW5jaVwiLCBcIkZyYW5jaW5pXCIsIFwiRnJhbmNpb25pXCIsIFwiRnJhbmNvXCIsIFwiRnJhc3NpbmV0aVwiLCBcIkZyYXRpXCIsIFwiRnJhdGluaVwiLCBcIkZyaWxsaVwiLCBcIkZyaXp6aVwiLCBcIkZyb3NhbGlcIiwgXCJGcm9zaW5pXCIsIFwiRnJ1bGxpbmlcIiwgXCJGdXNjb1wiLCBcIkZ1c2lcIiwgXCJHYWJicmllbGxpXCIsIFwiR2FiZWxsaW5pXCIsIFwiR2FnbGlhcmRpXCIsIFwiR2FsYW50aVwiLCBcIkdhbGFyZGlcIiwgXCJHYWxlb3R0aVwiLCBcIkdhbGxldHRpXCIsIFwiR2FsbGlcIiwgXCJHYWxsb1wiLCBcIkdhbGxvcmlcIiwgXCJHYW1iYWNjaWFuaVwiLCBcIkdhcmdhbmlcIiwgXCJHYXJvZmFsb1wiLCBcIkdhcnVnbGllcmlcIiwgXCJHYXNoaVwiLCBcIkdhc3BlcmluaVwiLCBcIkdhdHRpXCIsIFwiR2VsbGlcIiwgXCJHZW5zaW5pXCIsIFwiR2VudGlsZVwiLCBcIkdlbnRpbGlcIiwgXCJHZXJpXCIsIFwiR2VyaW5pXCIsIFwiR2hlcmlcIiwgXCJHaGluaVwiLCBcIkdpYWNoZXR0aVwiLCBcIkdpYWNoaVwiLCBcIkdpYWNvbWVsbGlcIiwgXCJHaWFuYXNzaVwiLCBcIkdpYW5pXCIsIFwiR2lhbm5lbGxpXCIsIFwiR2lhbm5ldHRpXCIsIFwiR2lhbm5pXCIsIFwiR2lhbm5pbmlcIiwgXCJHaWFubm9uaVwiLCBcIkdpYW5ub3R0aVwiLCBcIkdpYW5ub3p6aVwiLCBcIkdpZ2xpXCIsIFwiR2lvcmRhbm9cIiwgXCJHaW9yZ2V0dGlcIiwgXCJHaW9yZ2lcIiwgXCJHaW92YWNjaGluaVwiLCBcIkdpb3Zhbm5lbGxpXCIsIFwiR2lvdmFubmV0dGlcIiwgXCJHaW92YW5uaW5pXCIsIFwiR2lvdmFubm9uaVwiLCBcIkdpdWxpYW5pXCIsIFwiR2l1bnRpXCIsIFwiR2l1bnRpbmlcIiwgXCJHaXVzdGlcIiwgXCJHb25uZWxsaVwiLCBcIkdvcmV0dGlcIiwgXCJHb3JpXCIsIFwiR3JhZGlcIiwgXCJHcmFtaWduaVwiLCBcIkdyYXNzaVwiLCBcIkdyYXNzb1wiLCBcIkdyYXppYW5pXCIsIFwiR3JhenppbmlcIiwgXCJHcmVjb1wiLCBcIkdyaWZvbmlcIiwgXCJHcmlsbG9cIiwgXCJHcmltYWxkaVwiLCBcIkdyb3NzaVwiLCBcIkd1YWx0aWVyaVwiLCBcIkd1YXJkdWNjaVwiLCBcIkd1YXJpbm9cIiwgXCJHdWFybmllcmlcIiwgXCJHdWFzdGlcIiwgXCJHdWVycmFcIiwgXCJHdWVycmlcIiwgXCJHdWVycmluaVwiLCBcIkd1aWRpXCIsIFwiR3VpZG90dGlcIiwgXCJIZVwiLCBcIkhveGhhXCIsIFwiSHVcIiwgXCJIdWFuZ1wiLCBcIklhbmRlbGxpXCIsIFwiSWduZXN0aVwiLCBcIklubm9jZW50aVwiLCBcIkppblwiLCBcIkxhIFJvc2FcIiwgXCJMYWlcIiwgXCJMYW5kaVwiLCBcIkxhbmRpbmlcIiwgXCJMYW5pbmlcIiwgXCJMYXBpXCIsIFwiTGFwaW5pXCIsIFwiTGFyaVwiLCBcIkxhc2NpYWxmYXJpXCIsIFwiTGFzdHJ1Y2NpXCIsIFwiTGF0aW5pXCIsIFwiTGF6emVyaVwiLCBcIkxhenplcmluaVwiLCBcIkxlbGxpXCIsIFwiTGVuemlcIiwgXCJMZW9uYXJkaVwiLCBcIkxlb25jaW5pXCIsIFwiTGVvbmVcIiwgXCJMZW9uaVwiLCBcIkxlcHJpXCIsIFwiTGlcIiwgXCJMaWFvXCIsIFwiTGluXCIsIFwiTGluYXJpXCIsIFwiTGlwcGlcIiwgXCJMaXNpXCIsIFwiTGl2aVwiLCBcIkxvbWJhcmRpXCIsIFwiTG9tYmFyZGluaVwiLCBcIkxvbWJhcmRvXCIsIFwiTG9uZ29cIiwgXCJMb3BlelwiLCBcIkxvcmVuemlcIiwgXCJMb3JlbnppbmlcIiwgXCJMb3JpbmlcIiwgXCJMb3R0aVwiLCBcIkx1XCIsIFwiTHVjY2hlc2lcIiwgXCJMdWNoZXJpbmlcIiwgXCJMdW5naGlcIiwgXCJMdXBpXCIsIFwiTWFkaWFpXCIsIFwiTWFlc3RyaW5pXCIsIFwiTWFmZmVpXCIsIFwiTWFnZ2lcIiwgXCJNYWdnaW5pXCIsIFwiTWFnaGVyaW5pXCIsIFwiTWFnaW5pXCIsIFwiTWFnbmFuaVwiLCBcIk1hZ25lbGxpXCIsIFwiTWFnbmlcIiwgXCJNYWdub2xmaVwiLCBcIk1hZ3JpbmlcIiwgXCJNYWxhdm9sdGlcIiwgXCJNYWxldm9sdGlcIiwgXCJNYW5jYVwiLCBcIk1hbmNpbmlcIiwgXCJNYW5ldHRpXCIsIFwiTWFuZnJlZGlcIiwgXCJNYW5nYW5pXCIsIFwiTWFubmVsbGlcIiwgXCJNYW5uaVwiLCBcIk1hbm5pbmlcIiwgXCJNYW5udWNjaVwiLCBcIk1hbnVlbGxpXCIsIFwiTWFuemluaVwiLCBcIk1hcmNlbGxpXCIsIFwiTWFyY2hlc2VcIiwgXCJNYXJjaGV0dGlcIiwgXCJNYXJjaGlcIiwgXCJNYXJjaGlhbmlcIiwgXCJNYXJjaGlvbm5pXCIsIFwiTWFyY29uaVwiLCBcIk1hcmN1Y2NpXCIsIFwiTWFyZ2hlcmlcIiwgXCJNYXJpXCIsIFwiTWFyaWFuaVwiLCBcIk1hcmlsbGlcIiwgXCJNYXJpbmFpXCIsIFwiTWFyaW5hcmlcIiwgXCJNYXJpbmVsbGlcIiwgXCJNYXJpbmlcIiwgXCJNYXJpbm9cIiwgXCJNYXJpb3R0aVwiLCBcIk1hcnNpbGlcIiwgXCJNYXJ0ZWxsaVwiLCBcIk1hcnRpbmVsbGlcIiwgXCJNYXJ0aW5pXCIsIFwiTWFydGlub1wiLCBcIk1hcnppXCIsIFwiTWFzaVwiLCBcIk1hc2luaVwiLCBcIk1hc29uaVwiLCBcIk1hc3NhaVwiLCBcIk1hdGVyYXNzaVwiLCBcIk1hdHRlaVwiLCBcIk1hdHRlaW5pXCIsIFwiTWF0dGV1Y2NpXCIsIFwiTWF0dGV1enppXCIsIFwiTWF0dGlvbGlcIiwgXCJNYXR0b2xpbmlcIiwgXCJNYXR1Y2NpXCIsIFwiTWF1cm9cIiwgXCJNYXp6YW50aVwiLCBcIk1henplaVwiLCBcIk1henpldHRpXCIsIFwiTWF6emlcIiwgXCJNYXp6aW5pXCIsIFwiTWF6em9jY2hpXCIsIFwiTWF6em9saVwiLCBcIk1henpvbmlcIiwgXCJNYXp6dW9saVwiLCBcIk1lYWNjaVwiLCBcIk1lY29jY2lcIiwgXCJNZWluaVwiLCBcIk1lbGFuaVwiLCBcIk1lbGVcIiwgXCJNZWxpXCIsIFwiTWVuZ29uaVwiLCBcIk1lbmljaGV0dGlcIiwgXCJNZW9uaVwiLCBcIk1lcmxpbmlcIiwgXCJNZXNzZXJpXCIsIFwiTWVzc2luYVwiLCBcIk1ldWNjaVwiLCBcIk1pY2NpbmVzaVwiLCBcIk1pY2VsaVwiLCBcIk1pY2hlbGlcIiwgXCJNaWNoZWxpbmlcIiwgXCJNaWNoZWxvenppXCIsIFwiTWlnbGlvcmlcIiwgXCJNaWdsaW9yaW5pXCIsIFwiTWlsYW5pXCIsIFwiTWluaWF0aVwiLCBcIk1pc3VyaVwiLCBcIk1vbmFjb1wiLCBcIk1vbnRhZ25hbmlcIiwgXCJNb250YWduaVwiLCBcIk1vbnRhbmFyaVwiLCBcIk1vbnRlbGF0aWNpXCIsIFwiTW9udGlcIiwgXCJNb250aWdpYW5pXCIsIFwiTW9udGluaVwiLCBcIk1vcmFuZGlcIiwgXCJNb3JhbmRpbmlcIiwgXCJNb3JlbGxpXCIsIFwiTW9yZXR0aVwiLCBcIk1vcmdhbnRpXCIsIFwiTW9yaVwiLCBcIk1vcmluaVwiLCBcIk1vcm9uaVwiLCBcIk1vcm96emlcIiwgXCJNdWduYWlcIiwgXCJNdWduYWluaVwiLCBcIk11c3RhZmFcIiwgXCJOYWxkaVwiLCBcIk5hbGRpbmlcIiwgXCJOYW5uZWxsaVwiLCBcIk5hbm5pXCIsIFwiTmFubmluaVwiLCBcIk5hbm51Y2NpXCIsIFwiTmFyZGlcIiwgXCJOYXJkaW5pXCIsIFwiTmFyZG9uaVwiLCBcIk5hdGFsaVwiLCBcIk5kaWF5ZVwiLCBcIk5lbmNldHRpXCIsIFwiTmVuY2luaVwiLCBcIk5lbmNpb25pXCIsIFwiTmVyaVwiLCBcIk5lc2lcIiwgXCJOZXN0aVwiLCBcIk5pY2NvbGFpXCIsIFwiTmljY29saVwiLCBcIk5pY2NvbGluaVwiLCBcIk5pZ2lcIiwgXCJOaXN0cmlcIiwgXCJOb2NlbnRpbmlcIiwgXCJOb2ZlcmluaVwiLCBcIk5vdmVsbGlcIiwgXCJOdWNjaVwiLCBcIk51dGlcIiwgXCJOdXRpbmlcIiwgXCJPbGl2YVwiLCBcIk9saXZpZXJpXCIsIFwiT2xtaVwiLCBcIk9ybGFuZGlcIiwgXCJPcmxhbmRpbmlcIiwgXCJPcmxhbmRvXCIsIFwiT3JzaW5pXCIsIFwiT3J0b2xhbmlcIiwgXCJPdHRhbmVsbGlcIiwgXCJQYWNjaWFuaVwiLCBcIlBhY2VcIiwgXCJQYWNpXCIsIFwiUGFjaW5pXCIsIFwiUGFnYW5pXCIsIFwiUGFnYW5vXCIsIFwiUGFnZ2V0dGlcIiwgXCJQYWdsaWFpXCIsIFwiUGFnbmlcIiwgXCJQYWduaW5pXCIsIFwiUGFsYWRpbmlcIiwgXCJQYWxhZ2lcIiwgXCJQYWxjaGV0dGlcIiwgXCJQYWxsb25pXCIsIFwiUGFsbWllcmlcIiwgXCJQYWx1bWJvXCIsIFwiUGFtcGFsb25pXCIsIFwiUGFuY2FuaVwiLCBcIlBhbmRvbGZpXCIsIFwiUGFuZG9sZmluaVwiLCBcIlBhbmVyYWlcIiwgXCJQYW5pY2hpXCIsIFwiUGFvbGV0dGlcIiwgXCJQYW9saVwiLCBcIlBhb2xpbmlcIiwgXCJQYXBpXCIsIFwiUGFwaW5pXCIsIFwiUGFwdWNjaVwiLCBcIlBhcmVudGlcIiwgXCJQYXJpZ2lcIiwgXCJQYXJpc2lcIiwgXCJQYXJyaVwiLCBcIlBhcnJpbmlcIiwgXCJQYXNxdWluaVwiLCBcIlBhc3NlcmlcIiwgXCJQZWNjaGlvbGlcIiwgXCJQZWNvcmluaVwiLCBcIlBlbGxlZ3JpbmlcIiwgXCJQZXBpXCIsIFwiUGVyaW5pXCIsIFwiUGVycm9uZVwiLCBcIlBlcnV6emlcIiwgXCJQZXNjaVwiLCBcIlBlc3RlbGxpXCIsIFwiUGV0cmlcIiwgXCJQZXRyaW5pXCIsIFwiUGV0cnVjY2lcIiwgXCJQZXR0aW5pXCIsIFwiUGV6emF0aVwiLCBcIlBlenphdGluaVwiLCBcIlBpYW5pXCIsIFwiUGlhenphXCIsIFwiUGlhenplc2lcIiwgXCJQaWF6emluaVwiLCBcIlBpY2NhcmRpXCIsIFwiUGljY2hpXCIsIFwiUGljY2luaVwiLCBcIlBpY2Npb2xpXCIsIFwiUGllcmFjY2luaVwiLCBcIlBpZXJhY2Npb25pXCIsIFwiUGllcmFsbGlcIiwgXCJQaWVyYXR0aW5pXCIsIFwiUGllcmlcIiwgXCJQaWVyaW5pXCIsIFwiUGllcm9uaVwiLCBcIlBpZXRyaW5pXCIsIFwiUGluaVwiLCBcIlBpbm5hXCIsIFwiUGludG9cIiwgXCJQaW56YW5pXCIsIFwiUGluemF1dGlcIiwgXCJQaXJhc1wiLCBcIlBpc2FuaVwiLCBcIlBpc3RvbGVzaVwiLCBcIlBvZ2dlc2lcIiwgXCJQb2dnaVwiLCBcIlBvZ2dpYWxpXCIsIFwiUG9nZ2lvbGluaVwiLCBcIlBvbGlcIiwgXCJQb2xsYXN0cmlcIiwgXCJQb3JjaWFuaVwiLCBcIlBvenppXCIsIFwiUHJhdGVsbGVzaVwiLCBcIlByYXRlc2lcIiwgXCJQcm9zcGVyaVwiLCBcIlBydW5ldGlcIiwgXCJQdWNjaVwiLCBcIlB1Y2NpbmlcIiwgXCJQdWNjaW9uaVwiLCBcIlB1Z2lcIiwgXCJQdWdsaWVzZVwiLCBcIlB1bGl0aVwiLCBcIlF1ZXJjaVwiLCBcIlF1ZXJjaW9saVwiLCBcIlJhZGRpXCIsIFwiUmFkdVwiLCBcIlJhZmZhZWxsaVwiLCBcIlJhZ2F6emluaVwiLCBcIlJhbmZhZ25pXCIsIFwiUmFuaWVyaVwiLCBcIlJhc3RyZWxsaVwiLCBcIlJhdWdlaVwiLCBcIlJhdmVnZ2lcIiwgXCJSZW5haVwiLCBcIlJlbnppXCIsIFwiUmV0dG9yaVwiLCBcIlJpY2NpXCIsIFwiUmljY2lhcmRpXCIsIFwiUmlkaVwiLCBcIlJpZG9sZmlcIiwgXCJSaWdhY2NpXCIsIFwiUmlnaGlcIiwgXCJSaWdoaW5pXCIsIFwiUmluYWxkaVwiLCBcIlJpc2FsaXRpXCIsIFwiUmlzdG9yaVwiLCBcIlJpenpvXCIsIFwiUm9jY2hpXCIsIFwiUm9jY2hpbmlcIiwgXCJSb2dhaVwiLCBcIlJvbWFnbm9saVwiLCBcIlJvbWFuZWxsaVwiLCBcIlJvbWFuaVwiLCBcIlJvbWFub1wiLCBcIlJvbWVpXCIsIFwiUm9tZW9cIiwgXCJSb21pdGlcIiwgXCJSb21vbGlcIiwgXCJSb21vbGluaVwiLCBcIlJvbnRpbmlcIiwgXCJSb3NhdGlcIiwgXCJSb3NlbGxpXCIsIFwiUm9zaVwiLCBcIlJvc3NldHRpXCIsIFwiUm9zc2lcIiwgXCJSb3NzaW5pXCIsIFwiUm92YWlcIiwgXCJSdWdnZXJpXCIsIFwiUnVnZ2llcm9cIiwgXCJSdXNzb1wiLCBcIlNhYmF0aW5pXCIsIFwiU2FjY2FyZGlcIiwgXCJTYWNjaGV0dGlcIiwgXCJTYWNjaGlcIiwgXCJTYWNjb1wiLCBcIlNhbGVybm9cIiwgXCJTYWxpbWJlbmlcIiwgXCJTYWx1Y2NpXCIsIFwiU2FsdmFkb3JpXCIsIFwiU2FsdmVzdHJpbmlcIiwgXCJTYWx2aVwiLCBcIlNhbHZpbmlcIiwgXCJTYW5lc2lcIiwgXCJTYW5pXCIsIFwiU2FubmFcIiwgXCJTYW50aVwiLCBcIlNhbnRpbmlcIiwgXCJTYW50b25pXCIsIFwiU2FudG9yb1wiLCBcIlNhbnR1Y2NpXCIsIFwiU2FyZGlcIiwgXCJTYXJyaVwiLCBcIlNhcnRpXCIsIFwiU2Fzc2lcIiwgXCJTYm9sY2lcIiwgXCJTY2FsaVwiLCBcIlNjYXJwZWxsaVwiLCBcIlNjYXJzZWxsaVwiLCBcIlNjb3BldGFuaVwiLCBcIlNlY2NpXCIsIFwiU2VsdmlcIiwgXCJTZW5hdG9yaVwiLCBcIlNlbmVzaVwiLCBcIlNlcmFmaW5pXCIsIFwiU2VyZW5pXCIsIFwiU2VycmFcIiwgXCJTZXN0aW5pXCIsIFwiU2d1YW5jaVwiLCBcIlNpZW5pXCIsIFwiU2lnbm9yaW5pXCIsIFwiU2lsdmVzdHJpXCIsIFwiU2ltb25jaW5pXCIsIFwiU2ltb25ldHRpXCIsIFwiU2ltb25pXCIsIFwiU2luZ2hcIiwgXCJTb2RpXCIsIFwiU29sZGlcIiwgXCJTb21pZ2xpXCIsIFwiU29yYmlcIiwgXCJTb3JlbGxpXCIsIFwiU29ycmVudGlub1wiLCBcIlNvdHRpbGlcIiwgXCJTcGluYVwiLCBcIlNwaW5lbGxpXCIsIFwiU3RhY2Npb2xpXCIsIFwiU3RhZGVyaW5pXCIsIFwiU3RlZmFuZWxsaVwiLCBcIlN0ZWZhbmlcIiwgXCJTdGVmYW5pbmlcIiwgXCJTdGVsbGFcIiwgXCJTdXNpbmlcIiwgXCJUYWNjaGlcIiwgXCJUYWNjb25pXCIsIFwiVGFkZGVpXCIsIFwiVGFnbGlhZmVycmlcIiwgXCJUYW1idXJpbmlcIiwgXCJUYW5nYW5lbGxpXCIsIFwiVGFuaVwiLCBcIlRhbmluaVwiLCBcIlRhcGluYXNzaVwiLCBcIlRhcmNoaVwiLCBcIlRhcmNoaWFuaVwiLCBcIlRhcmdpb25pXCIsIFwiVGFzc2lcIiwgXCJUYXNzaW5pXCIsIFwiVGVtcGVzdGlcIiwgXCJUZXJ6YW5pXCIsIFwiVGVzaVwiLCBcIlRlc3RhXCIsIFwiVGVzdGlcIiwgXCJUaWxsaVwiLCBcIlRpbnRpXCIsIFwiVGlyaW5uYW56aVwiLCBcIlRvY2NhZm9uZGlcIiwgXCJUb2ZhbmFyaVwiLCBcIlRvZmFuaVwiLCBcIlRvZ25hY2NpbmlcIiwgXCJUb25lbGxpXCIsIFwiVG9uaW5pXCIsIFwiVG9yZWxsaVwiLCBcIlRvcnJpbmlcIiwgXCJUb3NpXCIsIFwiVG90aVwiLCBcIlRvenppXCIsIFwiVHJhbWJ1c3RpXCIsIFwiVHJhcGFuaVwiLCBcIlR1Y2NpXCIsIFwiVHVyY2hpXCIsIFwiVWdvbGluaVwiLCBcIlVsaXZpXCIsIFwiVmFsZW50ZVwiLCBcIlZhbGVudGlcIiwgXCJWYWxlbnRpbmlcIiwgXCJWYW5nZWxpc3RpXCIsIFwiVmFubmlcIiwgXCJWYW5uaW5pXCIsIFwiVmFubm9uaVwiLCBcIlZhbm5venppXCIsIFwiVmFubnVjY2hpXCIsIFwiVmFubnVjY2lcIiwgXCJWZW50dXJhXCIsIFwiVmVudHVyaVwiLCBcIlZlbnR1cmluaVwiLCBcIlZlc3RyaVwiLCBcIlZldHRvcmlcIiwgXCJWaWNoaVwiLCBcIlZpY2lhbmlcIiwgXCJWaWVyaVwiLCBcIlZpZ2lhbmlcIiwgXCJWaWdub2xpXCIsIFwiVmlnbm9saW5pXCIsIFwiVmlnbm96emlcIiwgXCJWaWxsYW5pXCIsIFwiVmluY2lcIiwgXCJWaXNhbmlcIiwgXCJWaXRhbGVcIiwgXCJWaXRhbGlcIiwgXCJWaXRpXCIsIFwiVml2aWFuaVwiLCBcIlZpdm9saVwiLCBcIlZvbHBlXCIsIFwiVm9scGlcIiwgXCJXYW5nXCIsIFwiV3VcIiwgXCJYdVwiLCBcIllhbmdcIiwgXCJZZVwiLCBcIlphZ2xpXCIsIFwiWmFuaVwiLCBcIlphbmllcmlcIiwgXCJaYW5vYmluaVwiLCBcIlplY2NoaVwiLCBcIlpldHRpXCIsIFwiWmhhbmdcIiwgXCJaaGVuZ1wiLCBcIlpob3VcIiwgXCJaaHVcIiwgXCJaaW5nb25pXCIsIFwiWmluaVwiLCBcIlpvcHBpXCJdXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGF0YSB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS91bXBpcnNreS9jb3VudHJ5LWxpc3QvYmxvYi9tYXN0ZXIvY291bnRyeS9jbGRyL2VuX1VTL2NvdW50cnkuanNvblxuICAgICAgICBjb3VudHJpZXM6IFt7XCJuYW1lXCI6XCJBZmdoYW5pc3RhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJBRlwifSx7XCJuYW1lXCI6XCJBbGJhbmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFMXCJ9LHtcIm5hbWVcIjpcIkFsZ2VyaWFcIixcImFiYnJldmlhdGlvblwiOlwiRFpcIn0se1wibmFtZVwiOlwiQW1lcmljYW4gU2Ftb2FcIixcImFiYnJldmlhdGlvblwiOlwiQVNcIn0se1wibmFtZVwiOlwiQW5kb3JyYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJBRFwifSx7XCJuYW1lXCI6XCJBbmdvbGFcIixcImFiYnJldmlhdGlvblwiOlwiQU9cIn0se1wibmFtZVwiOlwiQW5ndWlsbGFcIixcImFiYnJldmlhdGlvblwiOlwiQUlcIn0se1wibmFtZVwiOlwiQW50YXJjdGljYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJBUVwifSx7XCJuYW1lXCI6XCJBbnRpZ3VhIGFuZCBCYXJidWRhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFHXCJ9LHtcIm5hbWVcIjpcIkFyZ2VudGluYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJBUlwifSx7XCJuYW1lXCI6XCJBcm1lbmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFNXCJ9LHtcIm5hbWVcIjpcIkFydWJhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFXXCJ9LHtcIm5hbWVcIjpcIkF1c3RyYWxpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJBVVwifSx7XCJuYW1lXCI6XCJBdXN0cmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFUXCJ9LHtcIm5hbWVcIjpcIkF6ZXJiYWlqYW5cIixcImFiYnJldmlhdGlvblwiOlwiQVpcIn0se1wibmFtZVwiOlwiQmFoYW1hc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJCU1wifSx7XCJuYW1lXCI6XCJCYWhyYWluXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJIXCJ9LHtcIm5hbWVcIjpcIkJhbmdsYWRlc2hcIixcImFiYnJldmlhdGlvblwiOlwiQkRcIn0se1wibmFtZVwiOlwiQmFyYmFkb3NcIixcImFiYnJldmlhdGlvblwiOlwiQkJcIn0se1wibmFtZVwiOlwiQmVsYXJ1c1wiLFwiYWJicmV2aWF0aW9uXCI6XCJCWVwifSx7XCJuYW1lXCI6XCJCZWxnaXVtXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJFXCJ9LHtcIm5hbWVcIjpcIkJlbGl6ZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCWlwifSx7XCJuYW1lXCI6XCJCZW5pblwiLFwiYWJicmV2aWF0aW9uXCI6XCJCSlwifSx7XCJuYW1lXCI6XCJCZXJtdWRhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJNXCJ9LHtcIm5hbWVcIjpcIkJodXRhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJCVFwifSx7XCJuYW1lXCI6XCJCb2xpdmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJPXCJ9LHtcIm5hbWVcIjpcIkJvc25pYSBhbmQgSGVyemVnb3ZpbmFcIixcImFiYnJldmlhdGlvblwiOlwiQkFcIn0se1wibmFtZVwiOlwiQm90c3dhbmFcIixcImFiYnJldmlhdGlvblwiOlwiQldcIn0se1wibmFtZVwiOlwiQm91dmV0IElzbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJCVlwifSx7XCJuYW1lXCI6XCJCcmF6aWxcIixcImFiYnJldmlhdGlvblwiOlwiQlJcIn0se1wibmFtZVwiOlwiQnJpdGlzaCBBbnRhcmN0aWMgVGVycml0b3J5XCIsXCJhYmJyZXZpYXRpb25cIjpcIkJRXCJ9LHtcIm5hbWVcIjpcIkJyaXRpc2ggSW5kaWFuIE9jZWFuIFRlcnJpdG9yeVwiLFwiYWJicmV2aWF0aW9uXCI6XCJJT1wifSx7XCJuYW1lXCI6XCJCcml0aXNoIFZpcmdpbiBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlZHXCJ9LHtcIm5hbWVcIjpcIkJydW5laVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCTlwifSx7XCJuYW1lXCI6XCJCdWxnYXJpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCR1wifSx7XCJuYW1lXCI6XCJCdXJraW5hIEZhc29cIixcImFiYnJldmlhdGlvblwiOlwiQkZcIn0se1wibmFtZVwiOlwiQnVydW5kaVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCSVwifSx7XCJuYW1lXCI6XCJDYW1ib2RpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJLSFwifSx7XCJuYW1lXCI6XCJDYW1lcm9vblwiLFwiYWJicmV2aWF0aW9uXCI6XCJDTVwifSx7XCJuYW1lXCI6XCJDYW5hZGFcIixcImFiYnJldmlhdGlvblwiOlwiQ0FcIn0se1wibmFtZVwiOlwiQ2FudG9uIGFuZCBFbmRlcmJ1cnkgSXNsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJDVFwifSx7XCJuYW1lXCI6XCJDYXBlIFZlcmRlXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNWXCJ9LHtcIm5hbWVcIjpcIkNheW1hbiBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIktZXCJ9LHtcIm5hbWVcIjpcIkNlbnRyYWwgQWZyaWNhbiBSZXB1YmxpY1wiLFwiYWJicmV2aWF0aW9uXCI6XCJDRlwifSx7XCJuYW1lXCI6XCJDaGFkXCIsXCJhYmJyZXZpYXRpb25cIjpcIlREXCJ9LHtcIm5hbWVcIjpcIkNoaWxlXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNMXCJ9LHtcIm5hbWVcIjpcIkNoaW5hXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNOXCJ9LHtcIm5hbWVcIjpcIkNocmlzdG1hcyBJc2xhbmRcIixcImFiYnJldmlhdGlvblwiOlwiQ1hcIn0se1wibmFtZVwiOlwiQ29jb3MgW0tlZWxpbmddIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiQ0NcIn0se1wibmFtZVwiOlwiQ29sb21iaWFcIixcImFiYnJldmlhdGlvblwiOlwiQ09cIn0se1wibmFtZVwiOlwiQ29tb3Jvc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJLTVwifSx7XCJuYW1lXCI6XCJDb25nbyAtIEJyYXp6YXZpbGxlXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNHXCJ9LHtcIm5hbWVcIjpcIkNvbmdvIC0gS2luc2hhc2FcIixcImFiYnJldmlhdGlvblwiOlwiQ0RcIn0se1wibmFtZVwiOlwiQ29vayBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNLXCJ9LHtcIm5hbWVcIjpcIkNvc3RhIFJpY2FcIixcImFiYnJldmlhdGlvblwiOlwiQ1JcIn0se1wibmFtZVwiOlwiQ3JvYXRpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJIUlwifSx7XCJuYW1lXCI6XCJDdWJhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNVXCJ9LHtcIm5hbWVcIjpcIkN5cHJ1c1wiLFwiYWJicmV2aWF0aW9uXCI6XCJDWVwifSx7XCJuYW1lXCI6XCJDemVjaCBSZXB1YmxpY1wiLFwiYWJicmV2aWF0aW9uXCI6XCJDWlwifSx7XCJuYW1lXCI6XCJDw7R0ZSBk4oCZSXZvaXJlXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNJXCJ9LHtcIm5hbWVcIjpcIkRlbm1hcmtcIixcImFiYnJldmlhdGlvblwiOlwiREtcIn0se1wibmFtZVwiOlwiRGppYm91dGlcIixcImFiYnJldmlhdGlvblwiOlwiREpcIn0se1wibmFtZVwiOlwiRG9taW5pY2FcIixcImFiYnJldmlhdGlvblwiOlwiRE1cIn0se1wibmFtZVwiOlwiRG9taW5pY2FuIFJlcHVibGljXCIsXCJhYmJyZXZpYXRpb25cIjpcIkRPXCJ9LHtcIm5hbWVcIjpcIkRyb25uaW5nIE1hdWQgTGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJOUVwifSx7XCJuYW1lXCI6XCJFYXN0IEdlcm1hbnlcIixcImFiYnJldmlhdGlvblwiOlwiRERcIn0se1wibmFtZVwiOlwiRWN1YWRvclwiLFwiYWJicmV2aWF0aW9uXCI6XCJFQ1wifSx7XCJuYW1lXCI6XCJFZ3lwdFwiLFwiYWJicmV2aWF0aW9uXCI6XCJFR1wifSx7XCJuYW1lXCI6XCJFbCBTYWx2YWRvclwiLFwiYWJicmV2aWF0aW9uXCI6XCJTVlwifSx7XCJuYW1lXCI6XCJFcXVhdG9yaWFsIEd1aW5lYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHUVwifSx7XCJuYW1lXCI6XCJFcml0cmVhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkVSXCJ9LHtcIm5hbWVcIjpcIkVzdG9uaWFcIixcImFiYnJldmlhdGlvblwiOlwiRUVcIn0se1wibmFtZVwiOlwiRXRoaW9waWFcIixcImFiYnJldmlhdGlvblwiOlwiRVRcIn0se1wibmFtZVwiOlwiRmFsa2xhbmQgSXNsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJGS1wifSx7XCJuYW1lXCI6XCJGYXJvZSBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkZPXCJ9LHtcIm5hbWVcIjpcIkZpamlcIixcImFiYnJldmlhdGlvblwiOlwiRkpcIn0se1wibmFtZVwiOlwiRmlubGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJGSVwifSx7XCJuYW1lXCI6XCJGcmFuY2VcIixcImFiYnJldmlhdGlvblwiOlwiRlJcIn0se1wibmFtZVwiOlwiRnJlbmNoIEd1aWFuYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHRlwifSx7XCJuYW1lXCI6XCJGcmVuY2ggUG9seW5lc2lhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBGXCJ9LHtcIm5hbWVcIjpcIkZyZW5jaCBTb3V0aGVybiBUZXJyaXRvcmllc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJURlwifSx7XCJuYW1lXCI6XCJGcmVuY2ggU291dGhlcm4gYW5kIEFudGFyY3RpYyBUZXJyaXRvcmllc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJGUVwifSx7XCJuYW1lXCI6XCJHYWJvblwiLFwiYWJicmV2aWF0aW9uXCI6XCJHQVwifSx7XCJuYW1lXCI6XCJHYW1iaWFcIixcImFiYnJldmlhdGlvblwiOlwiR01cIn0se1wibmFtZVwiOlwiR2VvcmdpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHRVwifSx7XCJuYW1lXCI6XCJHZXJtYW55XCIsXCJhYmJyZXZpYXRpb25cIjpcIkRFXCJ9LHtcIm5hbWVcIjpcIkdoYW5hXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdIXCJ9LHtcIm5hbWVcIjpcIkdpYnJhbHRhclwiLFwiYWJicmV2aWF0aW9uXCI6XCJHSVwifSx7XCJuYW1lXCI6XCJHcmVlY2VcIixcImFiYnJldmlhdGlvblwiOlwiR1JcIn0se1wibmFtZVwiOlwiR3JlZW5sYW5kXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdMXCJ9LHtcIm5hbWVcIjpcIkdyZW5hZGFcIixcImFiYnJldmlhdGlvblwiOlwiR0RcIn0se1wibmFtZVwiOlwiR3VhZGVsb3VwZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHUFwifSx7XCJuYW1lXCI6XCJHdWFtXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdVXCJ9LHtcIm5hbWVcIjpcIkd1YXRlbWFsYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHVFwifSx7XCJuYW1lXCI6XCJHdWVybnNleVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHR1wifSx7XCJuYW1lXCI6XCJHdWluZWFcIixcImFiYnJldmlhdGlvblwiOlwiR05cIn0se1wibmFtZVwiOlwiR3VpbmVhLUJpc3NhdVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHV1wifSx7XCJuYW1lXCI6XCJHdXlhbmFcIixcImFiYnJldmlhdGlvblwiOlwiR1lcIn0se1wibmFtZVwiOlwiSGFpdGlcIixcImFiYnJldmlhdGlvblwiOlwiSFRcIn0se1wibmFtZVwiOlwiSGVhcmQgSXNsYW5kIGFuZCBNY0RvbmFsZCBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkhNXCJ9LHtcIm5hbWVcIjpcIkhvbmR1cmFzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkhOXCJ9LHtcIm5hbWVcIjpcIkhvbmcgS29uZyBTQVIgQ2hpbmFcIixcImFiYnJldmlhdGlvblwiOlwiSEtcIn0se1wibmFtZVwiOlwiSHVuZ2FyeVwiLFwiYWJicmV2aWF0aW9uXCI6XCJIVVwifSx7XCJuYW1lXCI6XCJJY2VsYW5kXCIsXCJhYmJyZXZpYXRpb25cIjpcIklTXCJ9LHtcIm5hbWVcIjpcIkluZGlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIklOXCJ9LHtcIm5hbWVcIjpcIkluZG9uZXNpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJJRFwifSx7XCJuYW1lXCI6XCJJcmFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIklSXCJ9LHtcIm5hbWVcIjpcIklyYXFcIixcImFiYnJldmlhdGlvblwiOlwiSVFcIn0se1wibmFtZVwiOlwiSXJlbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJJRVwifSx7XCJuYW1lXCI6XCJJc2xlIG9mIE1hblwiLFwiYWJicmV2aWF0aW9uXCI6XCJJTVwifSx7XCJuYW1lXCI6XCJJc3JhZWxcIixcImFiYnJldmlhdGlvblwiOlwiSUxcIn0se1wibmFtZVwiOlwiSXRhbHlcIixcImFiYnJldmlhdGlvblwiOlwiSVRcIn0se1wibmFtZVwiOlwiSmFtYWljYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJKTVwifSx7XCJuYW1lXCI6XCJKYXBhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJKUFwifSx7XCJuYW1lXCI6XCJKZXJzZXlcIixcImFiYnJldmlhdGlvblwiOlwiSkVcIn0se1wibmFtZVwiOlwiSm9obnN0b24gSXNsYW5kXCIsXCJhYmJyZXZpYXRpb25cIjpcIkpUXCJ9LHtcIm5hbWVcIjpcIkpvcmRhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJKT1wifSx7XCJuYW1lXCI6XCJLYXpha2hzdGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIktaXCJ9LHtcIm5hbWVcIjpcIktlbnlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIktFXCJ9LHtcIm5hbWVcIjpcIktpcmliYXRpXCIsXCJhYmJyZXZpYXRpb25cIjpcIktJXCJ9LHtcIm5hbWVcIjpcIkt1d2FpdFwiLFwiYWJicmV2aWF0aW9uXCI6XCJLV1wifSx7XCJuYW1lXCI6XCJLeXJneXpzdGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIktHXCJ9LHtcIm5hbWVcIjpcIkxhb3NcIixcImFiYnJldmlhdGlvblwiOlwiTEFcIn0se1wibmFtZVwiOlwiTGF0dmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxWXCJ9LHtcIm5hbWVcIjpcIkxlYmFub25cIixcImFiYnJldmlhdGlvblwiOlwiTEJcIn0se1wibmFtZVwiOlwiTGVzb3Rob1wiLFwiYWJicmV2aWF0aW9uXCI6XCJMU1wifSx7XCJuYW1lXCI6XCJMaWJlcmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxSXCJ9LHtcIm5hbWVcIjpcIkxpYnlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxZXCJ9LHtcIm5hbWVcIjpcIkxpZWNodGVuc3RlaW5cIixcImFiYnJldmlhdGlvblwiOlwiTElcIn0se1wibmFtZVwiOlwiTGl0aHVhbmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxUXCJ9LHtcIm5hbWVcIjpcIkx1eGVtYm91cmdcIixcImFiYnJldmlhdGlvblwiOlwiTFVcIn0se1wibmFtZVwiOlwiTWFjYXUgU0FSIENoaW5hXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1PXCJ9LHtcIm5hbWVcIjpcIk1hY2Vkb25pYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNS1wifSx7XCJuYW1lXCI6XCJNYWRhZ2FzY2FyXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1HXCJ9LHtcIm5hbWVcIjpcIk1hbGF3aVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNV1wifSx7XCJuYW1lXCI6XCJNYWxheXNpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNWVwifSx7XCJuYW1lXCI6XCJNYWxkaXZlc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJNVlwifSx7XCJuYW1lXCI6XCJNYWxpXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1MXCJ9LHtcIm5hbWVcIjpcIk1hbHRhXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1UXCJ9LHtcIm5hbWVcIjpcIk1hcnNoYWxsIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiTUhcIn0se1wibmFtZVwiOlwiTWFydGluaXF1ZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNUVwifSx7XCJuYW1lXCI6XCJNYXVyaXRhbmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1SXCJ9LHtcIm5hbWVcIjpcIk1hdXJpdGl1c1wiLFwiYWJicmV2aWF0aW9uXCI6XCJNVVwifSx7XCJuYW1lXCI6XCJNYXlvdHRlXCIsXCJhYmJyZXZpYXRpb25cIjpcIllUXCJ9LHtcIm5hbWVcIjpcIk1ldHJvcG9saXRhbiBGcmFuY2VcIixcImFiYnJldmlhdGlvblwiOlwiRlhcIn0se1wibmFtZVwiOlwiTWV4aWNvXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1YXCJ9LHtcIm5hbWVcIjpcIk1pY3JvbmVzaWFcIixcImFiYnJldmlhdGlvblwiOlwiRk1cIn0se1wibmFtZVwiOlwiTWlkd2F5IElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiTUlcIn0se1wibmFtZVwiOlwiTW9sZG92YVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNRFwifSx7XCJuYW1lXCI6XCJNb25hY29cIixcImFiYnJldmlhdGlvblwiOlwiTUNcIn0se1wibmFtZVwiOlwiTW9uZ29saWFcIixcImFiYnJldmlhdGlvblwiOlwiTU5cIn0se1wibmFtZVwiOlwiTW9udGVuZWdyb1wiLFwiYWJicmV2aWF0aW9uXCI6XCJNRVwifSx7XCJuYW1lXCI6XCJNb250c2VycmF0XCIsXCJhYmJyZXZpYXRpb25cIjpcIk1TXCJ9LHtcIm5hbWVcIjpcIk1vcm9jY29cIixcImFiYnJldmlhdGlvblwiOlwiTUFcIn0se1wibmFtZVwiOlwiTW96YW1iaXF1ZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNWlwifSx7XCJuYW1lXCI6XCJNeWFubWFyIFtCdXJtYV1cIixcImFiYnJldmlhdGlvblwiOlwiTU1cIn0se1wibmFtZVwiOlwiTmFtaWJpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJOQVwifSx7XCJuYW1lXCI6XCJOYXVydVwiLFwiYWJicmV2aWF0aW9uXCI6XCJOUlwifSx7XCJuYW1lXCI6XCJOZXBhbFwiLFwiYWJicmV2aWF0aW9uXCI6XCJOUFwifSx7XCJuYW1lXCI6XCJOZXRoZXJsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJOTFwifSx7XCJuYW1lXCI6XCJOZXRoZXJsYW5kcyBBbnRpbGxlc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJBTlwifSx7XCJuYW1lXCI6XCJOZXV0cmFsIFpvbmVcIixcImFiYnJldmlhdGlvblwiOlwiTlRcIn0se1wibmFtZVwiOlwiTmV3IENhbGVkb25pYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJOQ1wifSx7XCJuYW1lXCI6XCJOZXcgWmVhbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJOWlwifSx7XCJuYW1lXCI6XCJOaWNhcmFndWFcIixcImFiYnJldmlhdGlvblwiOlwiTklcIn0se1wibmFtZVwiOlwiTmlnZXJcIixcImFiYnJldmlhdGlvblwiOlwiTkVcIn0se1wibmFtZVwiOlwiTmlnZXJpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJOR1wifSx7XCJuYW1lXCI6XCJOaXVlXCIsXCJhYmJyZXZpYXRpb25cIjpcIk5VXCJ9LHtcIm5hbWVcIjpcIk5vcmZvbGsgSXNsYW5kXCIsXCJhYmJyZXZpYXRpb25cIjpcIk5GXCJ9LHtcIm5hbWVcIjpcIk5vcnRoIEtvcmVhXCIsXCJhYmJyZXZpYXRpb25cIjpcIktQXCJ9LHtcIm5hbWVcIjpcIk5vcnRoIFZpZXRuYW1cIixcImFiYnJldmlhdGlvblwiOlwiVkRcIn0se1wibmFtZVwiOlwiTm9ydGhlcm4gTWFyaWFuYSBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1QXCJ9LHtcIm5hbWVcIjpcIk5vcndheVwiLFwiYWJicmV2aWF0aW9uXCI6XCJOT1wifSx7XCJuYW1lXCI6XCJPbWFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIk9NXCJ9LHtcIm5hbWVcIjpcIlBhY2lmaWMgSXNsYW5kcyBUcnVzdCBUZXJyaXRvcnlcIixcImFiYnJldmlhdGlvblwiOlwiUENcIn0se1wibmFtZVwiOlwiUGFraXN0YW5cIixcImFiYnJldmlhdGlvblwiOlwiUEtcIn0se1wibmFtZVwiOlwiUGFsYXVcIixcImFiYnJldmlhdGlvblwiOlwiUFdcIn0se1wibmFtZVwiOlwiUGFsZXN0aW5pYW4gVGVycml0b3JpZXNcIixcImFiYnJldmlhdGlvblwiOlwiUFNcIn0se1wibmFtZVwiOlwiUGFuYW1hXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBBXCJ9LHtcIm5hbWVcIjpcIlBhbmFtYSBDYW5hbCBab25lXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBaXCJ9LHtcIm5hbWVcIjpcIlBhcHVhIE5ldyBHdWluZWFcIixcImFiYnJldmlhdGlvblwiOlwiUEdcIn0se1wibmFtZVwiOlwiUGFyYWd1YXlcIixcImFiYnJldmlhdGlvblwiOlwiUFlcIn0se1wibmFtZVwiOlwiUGVvcGxlJ3MgRGVtb2NyYXRpYyBSZXB1YmxpYyBvZiBZZW1lblwiLFwiYWJicmV2aWF0aW9uXCI6XCJZRFwifSx7XCJuYW1lXCI6XCJQZXJ1XCIsXCJhYmJyZXZpYXRpb25cIjpcIlBFXCJ9LHtcIm5hbWVcIjpcIlBoaWxpcHBpbmVzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBIXCJ9LHtcIm5hbWVcIjpcIlBpdGNhaXJuIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiUE5cIn0se1wibmFtZVwiOlwiUG9sYW5kXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBMXCJ9LHtcIm5hbWVcIjpcIlBvcnR1Z2FsXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBUXCJ9LHtcIm5hbWVcIjpcIlB1ZXJ0byBSaWNvXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBSXCJ9LHtcIm5hbWVcIjpcIlFhdGFyXCIsXCJhYmJyZXZpYXRpb25cIjpcIlFBXCJ9LHtcIm5hbWVcIjpcIlJvbWFuaWFcIixcImFiYnJldmlhdGlvblwiOlwiUk9cIn0se1wibmFtZVwiOlwiUnVzc2lhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlJVXCJ9LHtcIm5hbWVcIjpcIlJ3YW5kYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJSV1wifSx7XCJuYW1lXCI6XCJSw6l1bmlvblwiLFwiYWJicmV2aWF0aW9uXCI6XCJSRVwifSx7XCJuYW1lXCI6XCJTYWludCBCYXJ0aMOpbGVteVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCTFwifSx7XCJuYW1lXCI6XCJTYWludCBIZWxlbmFcIixcImFiYnJldmlhdGlvblwiOlwiU0hcIn0se1wibmFtZVwiOlwiU2FpbnQgS2l0dHMgYW5kIE5ldmlzXCIsXCJhYmJyZXZpYXRpb25cIjpcIktOXCJ9LHtcIm5hbWVcIjpcIlNhaW50IEx1Y2lhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxDXCJ9LHtcIm5hbWVcIjpcIlNhaW50IE1hcnRpblwiLFwiYWJicmV2aWF0aW9uXCI6XCJNRlwifSx7XCJuYW1lXCI6XCJTYWludCBQaWVycmUgYW5kIE1pcXVlbG9uXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBNXCJ9LHtcIm5hbWVcIjpcIlNhaW50IFZpbmNlbnQgYW5kIHRoZSBHcmVuYWRpbmVzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlZDXCJ9LHtcIm5hbWVcIjpcIlNhbW9hXCIsXCJhYmJyZXZpYXRpb25cIjpcIldTXCJ9LHtcIm5hbWVcIjpcIlNhbiBNYXJpbm9cIixcImFiYnJldmlhdGlvblwiOlwiU01cIn0se1wibmFtZVwiOlwiU2F1ZGkgQXJhYmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNBXCJ9LHtcIm5hbWVcIjpcIlNlbmVnYWxcIixcImFiYnJldmlhdGlvblwiOlwiU05cIn0se1wibmFtZVwiOlwiU2VyYmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlJTXCJ9LHtcIm5hbWVcIjpcIlNlcmJpYSBhbmQgTW9udGVuZWdyb1wiLFwiYWJicmV2aWF0aW9uXCI6XCJDU1wifSx7XCJuYW1lXCI6XCJTZXljaGVsbGVzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNDXCJ9LHtcIm5hbWVcIjpcIlNpZXJyYSBMZW9uZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJTTFwifSx7XCJuYW1lXCI6XCJTaW5nYXBvcmVcIixcImFiYnJldmlhdGlvblwiOlwiU0dcIn0se1wibmFtZVwiOlwiU2xvdmFraWFcIixcImFiYnJldmlhdGlvblwiOlwiU0tcIn0se1wibmFtZVwiOlwiU2xvdmVuaWFcIixcImFiYnJldmlhdGlvblwiOlwiU0lcIn0se1wibmFtZVwiOlwiU29sb21vbiBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNCXCJ9LHtcIm5hbWVcIjpcIlNvbWFsaWFcIixcImFiYnJldmlhdGlvblwiOlwiU09cIn0se1wibmFtZVwiOlwiU291dGggQWZyaWNhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlpBXCJ9LHtcIm5hbWVcIjpcIlNvdXRoIEdlb3JnaWEgYW5kIHRoZSBTb3V0aCBTYW5kd2ljaCBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdTXCJ9LHtcIm5hbWVcIjpcIlNvdXRoIEtvcmVhXCIsXCJhYmJyZXZpYXRpb25cIjpcIktSXCJ9LHtcIm5hbWVcIjpcIlNwYWluXCIsXCJhYmJyZXZpYXRpb25cIjpcIkVTXCJ9LHtcIm5hbWVcIjpcIlNyaSBMYW5rYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJMS1wifSx7XCJuYW1lXCI6XCJTdWRhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJTRFwifSx7XCJuYW1lXCI6XCJTdXJpbmFtZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJTUlwifSx7XCJuYW1lXCI6XCJTdmFsYmFyZCBhbmQgSmFuIE1heWVuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNKXCJ9LHtcIm5hbWVcIjpcIlN3YXppbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJTWlwifSx7XCJuYW1lXCI6XCJTd2VkZW5cIixcImFiYnJldmlhdGlvblwiOlwiU0VcIn0se1wibmFtZVwiOlwiU3dpdHplcmxhbmRcIixcImFiYnJldmlhdGlvblwiOlwiQ0hcIn0se1wibmFtZVwiOlwiU3lyaWFcIixcImFiYnJldmlhdGlvblwiOlwiU1lcIn0se1wibmFtZVwiOlwiU8OjbyBUb23DqSBhbmQgUHLDrW5jaXBlXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNUXCJ9LHtcIm5hbWVcIjpcIlRhaXdhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJUV1wifSx7XCJuYW1lXCI6XCJUYWppa2lzdGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRKXCJ9LHtcIm5hbWVcIjpcIlRhbnphbmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRaXCJ9LHtcIm5hbWVcIjpcIlRoYWlsYW5kXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRIXCJ9LHtcIm5hbWVcIjpcIlRpbW9yLUxlc3RlXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRMXCJ9LHtcIm5hbWVcIjpcIlRvZ29cIixcImFiYnJldmlhdGlvblwiOlwiVEdcIn0se1wibmFtZVwiOlwiVG9rZWxhdVwiLFwiYWJicmV2aWF0aW9uXCI6XCJUS1wifSx7XCJuYW1lXCI6XCJUb25nYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJUT1wifSx7XCJuYW1lXCI6XCJUcmluaWRhZCBhbmQgVG9iYWdvXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRUXCJ9LHtcIm5hbWVcIjpcIlR1bmlzaWFcIixcImFiYnJldmlhdGlvblwiOlwiVE5cIn0se1wibmFtZVwiOlwiVHVya2V5XCIsXCJhYmJyZXZpYXRpb25cIjpcIlRSXCJ9LHtcIm5hbWVcIjpcIlR1cmttZW5pc3RhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJUTVwifSx7XCJuYW1lXCI6XCJUdXJrcyBhbmQgQ2FpY29zIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiVENcIn0se1wibmFtZVwiOlwiVHV2YWx1XCIsXCJhYmJyZXZpYXRpb25cIjpcIlRWXCJ9LHtcIm5hbWVcIjpcIlUuUy4gTWlub3IgT3V0bHlpbmcgSXNsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJVTVwifSx7XCJuYW1lXCI6XCJVLlMuIE1pc2NlbGxhbmVvdXMgUGFjaWZpYyBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBVXCJ9LHtcIm5hbWVcIjpcIlUuUy4gVmlyZ2luIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiVklcIn0se1wibmFtZVwiOlwiVWdhbmRhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlVHXCJ9LHtcIm5hbWVcIjpcIlVrcmFpbmVcIixcImFiYnJldmlhdGlvblwiOlwiVUFcIn0se1wibmFtZVwiOlwiVW5pb24gb2YgU292aWV0IFNvY2lhbGlzdCBSZXB1YmxpY3NcIixcImFiYnJldmlhdGlvblwiOlwiU1VcIn0se1wibmFtZVwiOlwiVW5pdGVkIEFyYWIgRW1pcmF0ZXNcIixcImFiYnJldmlhdGlvblwiOlwiQUVcIn0se1wibmFtZVwiOlwiVW5pdGVkIEtpbmdkb21cIixcImFiYnJldmlhdGlvblwiOlwiR0JcIn0se1wibmFtZVwiOlwiVW5pdGVkIFN0YXRlc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJVU1wifSx7XCJuYW1lXCI6XCJVbmtub3duIG9yIEludmFsaWQgUmVnaW9uXCIsXCJhYmJyZXZpYXRpb25cIjpcIlpaXCJ9LHtcIm5hbWVcIjpcIlVydWd1YXlcIixcImFiYnJldmlhdGlvblwiOlwiVVlcIn0se1wibmFtZVwiOlwiVXpiZWtpc3RhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJVWlwifSx7XCJuYW1lXCI6XCJWYW51YXR1XCIsXCJhYmJyZXZpYXRpb25cIjpcIlZVXCJ9LHtcIm5hbWVcIjpcIlZhdGljYW4gQ2l0eVwiLFwiYWJicmV2aWF0aW9uXCI6XCJWQVwifSx7XCJuYW1lXCI6XCJWZW5lenVlbGFcIixcImFiYnJldmlhdGlvblwiOlwiVkVcIn0se1wibmFtZVwiOlwiVmlldG5hbVwiLFwiYWJicmV2aWF0aW9uXCI6XCJWTlwifSx7XCJuYW1lXCI6XCJXYWtlIElzbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJXS1wifSx7XCJuYW1lXCI6XCJXYWxsaXMgYW5kIEZ1dHVuYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJXRlwifSx7XCJuYW1lXCI6XCJXZXN0ZXJuIFNhaGFyYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJFSFwifSx7XCJuYW1lXCI6XCJZZW1lblwiLFwiYWJicmV2aWF0aW9uXCI6XCJZRVwifSx7XCJuYW1lXCI6XCJaYW1iaWFcIixcImFiYnJldmlhdGlvblwiOlwiWk1cIn0se1wibmFtZVwiOlwiWmltYmFid2VcIixcImFiYnJldmlhdGlvblwiOlwiWldcIn0se1wibmFtZVwiOlwiw4VsYW5kIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiQVhcIn1dLFxuXG4gICAgICAgIHByb3ZpbmNlczoge1xuICAgICAgICAgICAgXCJjYVwiOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdBbGJlcnRhJywgYWJicmV2aWF0aW9uOiAnQUInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0JyaXRpc2ggQ29sdW1iaWEnLCBhYmJyZXZpYXRpb246ICdCQyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTWFuaXRvYmEnLCBhYmJyZXZpYXRpb246ICdNQid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTmV3IEJydW5zd2ljaycsIGFiYnJldmlhdGlvbjogJ05CJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdOZXdmb3VuZGxhbmQgYW5kIExhYnJhZG9yJywgYWJicmV2aWF0aW9uOiAnTkwnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ05vdmEgU2NvdGlhJywgYWJicmV2aWF0aW9uOiAnTlMnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ09udGFyaW8nLCBhYmJyZXZpYXRpb246ICdPTid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUHJpbmNlIEVkd2FyZCBJc2xhbmQnLCBhYmJyZXZpYXRpb246ICdQRSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUXVlYmVjJywgYWJicmV2aWF0aW9uOiAnUUMnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1Nhc2thdGNoZXdhbicsIGFiYnJldmlhdGlvbjogJ1NLJ30sXG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FzZSBjb3VsZCBiZSBtYWRlIHRoYXQgdGhlIGZvbGxvd2luZyBhcmUgbm90IGFjdHVhbGx5IHByb3ZpbmNlc1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHRlY2huaWNhbGx5IGNvbnNpZGVyZWQgXCJ0ZXJyaXRvcmllc1wiIGhvd2V2ZXIgdGhleSBhbGxcbiAgICAgICAgICAgICAgICAvLyBsb29rIHRoZSBzYW1lIG9uIGFuIGVudmVsb3BlIVxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTm9ydGh3ZXN0IFRlcnJpdG9yaWVzJywgYWJicmV2aWF0aW9uOiAnTlQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ051bmF2dXQnLCBhYmJyZXZpYXRpb246ICdOVSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnWXVrb24nLCBhYmJyZXZpYXRpb246ICdZVCd9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJpdFwiOiBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkFncmlnZW50b1wiLCBhYmJyZXZpYXRpb246IFwiQUdcIiwgY29kZTogODQgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQWxlc3NhbmRyaWFcIiwgYWJicmV2aWF0aW9uOiBcIkFMXCIsIGNvZGU6IDYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQW5jb25hXCIsIGFiYnJldmlhdGlvbjogXCJBTlwiLCBjb2RlOiA0MiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJBb3N0YVwiLCBhYmJyZXZpYXRpb246IFwiQU9cIiwgY29kZTogNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJMJ0FxdWlsYVwiLCBhYmJyZXZpYXRpb246IFwiQVFcIiwgY29kZTogNjYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQXJlenpvXCIsIGFiYnJldmlhdGlvbjogXCJBUlwiLCBjb2RlOiA1MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJBc2NvbGktUGljZW5vXCIsIGFiYnJldmlhdGlvbjogXCJBUFwiLCBjb2RlOiA0NCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJBc3RpXCIsIGFiYnJldmlhdGlvbjogXCJBVFwiLCBjb2RlOiA1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkF2ZWxsaW5vXCIsIGFiYnJldmlhdGlvbjogXCJBVlwiLCBjb2RlOiA2NCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCYXJpXCIsIGFiYnJldmlhdGlvbjogXCJCQVwiLCBjb2RlOiA3MiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCYXJsZXR0YS1BbmRyaWEtVHJhbmlcIiwgYWJicmV2aWF0aW9uOiBcIkJUXCIsIGNvZGU6IDcyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkJlbGx1bm9cIiwgYWJicmV2aWF0aW9uOiBcIkJMXCIsIGNvZGU6IDI1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkJlbmV2ZW50b1wiLCBhYmJyZXZpYXRpb246IFwiQk5cIiwgY29kZTogNjIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQmVyZ2Ftb1wiLCBhYmJyZXZpYXRpb246IFwiQkdcIiwgY29kZTogMTYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQmllbGxhXCIsIGFiYnJldmlhdGlvbjogXCJCSVwiLCBjb2RlOiA5NiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCb2xvZ25hXCIsIGFiYnJldmlhdGlvbjogXCJCT1wiLCBjb2RlOiAzNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCb2x6YW5vXCIsIGFiYnJldmlhdGlvbjogXCJCWlwiLCBjb2RlOiAyMSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCcmVzY2lhXCIsIGFiYnJldmlhdGlvbjogXCJCU1wiLCBjb2RlOiAxNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCcmluZGlzaVwiLCBhYmJyZXZpYXRpb246IFwiQlJcIiwgY29kZTogNzQgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ2FnbGlhcmlcIiwgYWJicmV2aWF0aW9uOiBcIkNBXCIsIGNvZGU6IDkyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNhbHRhbmlzc2V0dGFcIiwgYWJicmV2aWF0aW9uOiBcIkNMXCIsIGNvZGU6IDg1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNhbXBvYmFzc29cIiwgYWJicmV2aWF0aW9uOiBcIkNCXCIsIGNvZGU6IDcwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNhcmJvbmlhIElnbGVzaWFzXCIsIGFiYnJldmlhdGlvbjogXCJDSVwiLCBjb2RlOiA3MCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYXNlcnRhXCIsIGFiYnJldmlhdGlvbjogXCJDRVwiLCBjb2RlOiA2MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYXRhbmlhXCIsIGFiYnJldmlhdGlvbjogXCJDVFwiLCBjb2RlOiA4NyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYXRhbnphcm9cIiwgYWJicmV2aWF0aW9uOiBcIkNaXCIsIGNvZGU6IDc5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNoaWV0aVwiLCBhYmJyZXZpYXRpb246IFwiQ0hcIiwgY29kZTogNjkgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ29tb1wiLCBhYmJyZXZpYXRpb246IFwiQ09cIiwgY29kZTogMTMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ29zZW56YVwiLCBhYmJyZXZpYXRpb246IFwiQ1NcIiwgY29kZTogNzggfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ3JlbW9uYVwiLCBhYmJyZXZpYXRpb246IFwiQ1JcIiwgY29kZTogMTkgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ3JvdG9uZVwiLCBhYmJyZXZpYXRpb246IFwiS1JcIiwgY29kZTogMTAxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkN1bmVvXCIsIGFiYnJldmlhdGlvbjogXCJDTlwiLCBjb2RlOiA0IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkVubmFcIiwgYWJicmV2aWF0aW9uOiBcIkVOXCIsIGNvZGU6IDg2IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkZlcm1vXCIsIGFiYnJldmlhdGlvbjogXCJGTVwiLCBjb2RlOiA4NiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJGZXJyYXJhXCIsIGFiYnJldmlhdGlvbjogXCJGRVwiLCBjb2RlOiAzOCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJGaXJlbnplXCIsIGFiYnJldmlhdGlvbjogXCJGSVwiLCBjb2RlOiA0OCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJGb2dnaWFcIiwgYWJicmV2aWF0aW9uOiBcIkZHXCIsIGNvZGU6IDcxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkZvcmxpLUNlc2VuYVwiLCBhYmJyZXZpYXRpb246IFwiRkNcIiwgY29kZTogNzEgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiRnJvc2lub25lXCIsIGFiYnJldmlhdGlvbjogXCJGUlwiLCBjb2RlOiA2MCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJHZW5vdmFcIiwgYWJicmV2aWF0aW9uOiBcIkdFXCIsIGNvZGU6IDEwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkdvcml6aWFcIiwgYWJicmV2aWF0aW9uOiBcIkdPXCIsIGNvZGU6IDMxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkdyb3NzZXRvXCIsIGFiYnJldmlhdGlvbjogXCJHUlwiLCBjb2RlOiA1MyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJJbXBlcmlhXCIsIGFiYnJldmlhdGlvbjogXCJJTVwiLCBjb2RlOiA4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIklzZXJuaWFcIiwgYWJicmV2aWF0aW9uOiBcIklTXCIsIGNvZGU6IDk0IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkxhLVNwZXppYVwiLCBhYmJyZXZpYXRpb246IFwiU1BcIiwgY29kZTogNjYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTGF0aW5hXCIsIGFiYnJldmlhdGlvbjogXCJMVFwiLCBjb2RlOiA1OSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJMZWNjZVwiLCBhYmJyZXZpYXRpb246IFwiTEVcIiwgY29kZTogNzUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTGVjY29cIiwgYWJicmV2aWF0aW9uOiBcIkxDXCIsIGNvZGU6IDk3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkxpdm9ybm9cIiwgYWJicmV2aWF0aW9uOiBcIkxJXCIsIGNvZGU6IDQ5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkxvZGlcIiwgYWJicmV2aWF0aW9uOiBcIkxPXCIsIGNvZGU6IDk4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkx1Y2NhXCIsIGFiYnJldmlhdGlvbjogXCJMVVwiLCBjb2RlOiA0NiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNYWNlcmF0YVwiLCBhYmJyZXZpYXRpb246IFwiTUNcIiwgY29kZTogNDMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTWFudG92YVwiLCBhYmJyZXZpYXRpb246IFwiTU5cIiwgY29kZTogMjAgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTWFzc2EtQ2FycmFyYVwiLCBhYmJyZXZpYXRpb246IFwiTVNcIiwgY29kZTogNDUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTWF0ZXJhXCIsIGFiYnJldmlhdGlvbjogXCJNVFwiLCBjb2RlOiA3NyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNZWRpbyBDYW1waWRhbm9cIiwgYWJicmV2aWF0aW9uOiBcIlZTXCIsIGNvZGU6IDc3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk1lc3NpbmFcIiwgYWJicmV2aWF0aW9uOiBcIk1FXCIsIGNvZGU6IDgzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk1pbGFub1wiLCBhYmJyZXZpYXRpb246IFwiTUlcIiwgY29kZTogMTUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTW9kZW5hXCIsIGFiYnJldmlhdGlvbjogXCJNT1wiLCBjb2RlOiAzNiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNb256YS1CcmlhbnphXCIsIGFiYnJldmlhdGlvbjogXCJNQlwiLCBjb2RlOiAzNiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJOYXBvbGlcIiwgYWJicmV2aWF0aW9uOiBcIk5BXCIsIGNvZGU6IDYzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk5vdmFyYVwiLCBhYmJyZXZpYXRpb246IFwiTk9cIiwgY29kZTogMyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJOdW9yb1wiLCBhYmJyZXZpYXRpb246IFwiTlVcIiwgY29kZTogOTEgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiT2dsaWFzdHJhXCIsIGFiYnJldmlhdGlvbjogXCJPR1wiLCBjb2RlOiA5MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJPbGJpYSBUZW1waW9cIiwgYWJicmV2aWF0aW9uOiBcIk9UXCIsIGNvZGU6IDkxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk9yaXN0YW5vXCIsIGFiYnJldmlhdGlvbjogXCJPUlwiLCBjb2RlOiA5NSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJQYWRvdmFcIiwgYWJicmV2aWF0aW9uOiBcIlBEXCIsIGNvZGU6IDI4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBhbGVybW9cIiwgYWJicmV2aWF0aW9uOiBcIlBBXCIsIGNvZGU6IDgyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBhcm1hXCIsIGFiYnJldmlhdGlvbjogXCJQUlwiLCBjb2RlOiAzNCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJQYXZpYVwiLCBhYmJyZXZpYXRpb246IFwiUFZcIiwgY29kZTogMTggfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGVydWdpYVwiLCBhYmJyZXZpYXRpb246IFwiUEdcIiwgY29kZTogNTQgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGVzYXJvLVVyYmlub1wiLCBhYmJyZXZpYXRpb246IFwiUFVcIiwgY29kZTogNDEgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGVzY2FyYVwiLCBhYmJyZXZpYXRpb246IFwiUEVcIiwgY29kZTogNjggfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGlhY2VuemFcIiwgYWJicmV2aWF0aW9uOiBcIlBDXCIsIGNvZGU6IDMzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBpc2FcIiwgYWJicmV2aWF0aW9uOiBcIlBJXCIsIGNvZGU6IDUwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBpc3RvaWFcIiwgYWJicmV2aWF0aW9uOiBcIlBUXCIsIGNvZGU6IDQ3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBvcmRlbm9uZVwiLCBhYmJyZXZpYXRpb246IFwiUE5cIiwgY29kZTogOTMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUG90ZW56YVwiLCBhYmJyZXZpYXRpb246IFwiUFpcIiwgY29kZTogNzYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUHJhdG9cIiwgYWJicmV2aWF0aW9uOiBcIlBPXCIsIGNvZGU6IDEwMCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSYWd1c2FcIiwgYWJicmV2aWF0aW9uOiBcIlJHXCIsIGNvZGU6IDg4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJhdmVubmFcIiwgYWJicmV2aWF0aW9uOiBcIlJBXCIsIGNvZGU6IDM5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJlZ2dpby1DYWxhYnJpYVwiLCBhYmJyZXZpYXRpb246IFwiUkNcIiwgY29kZTogMzUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUmVnZ2lvLUVtaWxpYVwiLCBhYmJyZXZpYXRpb246IFwiUkVcIiwgY29kZTogMzUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUmlldGlcIiwgYWJicmV2aWF0aW9uOiBcIlJJXCIsIGNvZGU6IDU3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJpbWluaVwiLCBhYmJyZXZpYXRpb246IFwiUk5cIiwgY29kZTogOTkgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUm9tYVwiLCBhYmJyZXZpYXRpb246IFwiUm9tYVwiLCBjb2RlOiA1OCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSb3ZpZ29cIiwgYWJicmV2aWF0aW9uOiBcIlJPXCIsIGNvZGU6IDI5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNhbGVybm9cIiwgYWJicmV2aWF0aW9uOiBcIlNBXCIsIGNvZGU6IDY1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNhc3NhcmlcIiwgYWJicmV2aWF0aW9uOiBcIlNTXCIsIGNvZGU6IDkwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNhdm9uYVwiLCBhYmJyZXZpYXRpb246IFwiU1ZcIiwgY29kZTogOSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJTaWVuYVwiLCBhYmJyZXZpYXRpb246IFwiU0lcIiwgY29kZTogNTIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiU2lyYWN1c2FcIiwgYWJicmV2aWF0aW9uOiBcIlNSXCIsIGNvZGU6IDg5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNvbmRyaW9cIiwgYWJicmV2aWF0aW9uOiBcIlNPXCIsIGNvZGU6IDE0IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRhcmFudG9cIiwgYWJicmV2aWF0aW9uOiBcIlRBXCIsIGNvZGU6IDczIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRlcmFtb1wiLCBhYmJyZXZpYXRpb246IFwiVEVcIiwgY29kZTogNjcgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiVGVybmlcIiwgYWJicmV2aWF0aW9uOiBcIlRSXCIsIGNvZGU6IDU1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRvcmlub1wiLCBhYmJyZXZpYXRpb246IFwiVE9cIiwgY29kZTogMSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJUcmFwYW5pXCIsIGFiYnJldmlhdGlvbjogXCJUUFwiLCBjb2RlOiA4MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJUcmVudG9cIiwgYWJicmV2aWF0aW9uOiBcIlROXCIsIGNvZGU6IDIyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRyZXZpc29cIiwgYWJicmV2aWF0aW9uOiBcIlRWXCIsIGNvZGU6IDI2IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRyaWVzdGVcIiwgYWJicmV2aWF0aW9uOiBcIlRTXCIsIGNvZGU6IDMyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlVkaW5lXCIsIGFiYnJldmlhdGlvbjogXCJVRFwiLCBjb2RlOiAzMCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWYXJlc2VcIiwgYWJicmV2aWF0aW9uOiBcIlZBXCIsIGNvZGU6IDEyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZlbmV6aWFcIiwgYWJicmV2aWF0aW9uOiBcIlZFXCIsIGNvZGU6IDI3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZlcmJhbmlhXCIsIGFiYnJldmlhdGlvbjogXCJWQlwiLCBjb2RlOiAyNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWZXJjZWxsaVwiLCBhYmJyZXZpYXRpb246IFwiVkNcIiwgY29kZTogMiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWZXJvbmFcIiwgYWJicmV2aWF0aW9uOiBcIlZSXCIsIGNvZGU6IDIzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZpYm8tVmFsZW50aWFcIiwgYWJicmV2aWF0aW9uOiBcIlZWXCIsIGNvZGU6IDEwMiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWaWNlbnphXCIsIGFiYnJldmlhdGlvbjogXCJWSVwiLCBjb2RlOiAyNCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWaXRlcmJvXCIsIGFiYnJldmlhdGlvbjogXCJWVFwiLCBjb2RlOiA1NiB9ICAgXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1zYXJnZW50L1VzZWZ1bC1BdXRvY29tcGxldGUtRGF0YS9ibG9iL21hc3Rlci9kYXRhL25hdGlvbmFsaXRpZXMuanNvblxuICAgICAgICBuYXRpb25hbGl0aWVzOiBbXG4gICAgICAgICAgIHtuYW1lOiAnQWZnaGFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQWxiYW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBbGdlcmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0FtZXJpY2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQW5kb3JyYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBbmdvbGFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQW50aWd1YW5zJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQXJnZW50aW5lYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBcm1lbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0F1c3RyYWxpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBdXN0cmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0F6ZXJiYWlqYW5pJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmFoYW1pJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmFocmFpbmknfSxcbiAgICAgICAgICAge25hbWU6ICdCYW5nbGFkZXNoaSd9LFxuICAgICAgICAgICB7bmFtZTogJ0JhcmJhZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0JhcmJ1ZGFucyd9LFxuICAgICAgICAgICB7bmFtZTogJ0JhdHN3YW5hJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmVsYXJ1c2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0JlbGdpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdCZWxpemVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0JlbmluZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmh1dGFuZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQm9saXZpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdCb3NuaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnJhemlsaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnJpdGlzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0JydW5laWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnVsZ2FyaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnVya2luYWJlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnVybWVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ0J1cnVuZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0NhbWJvZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0NhbWVyb29uaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ2FuYWRpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDYXBlIFZlcmRlYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDZW50cmFsIEFmcmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDaGFkaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ2hpbGVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0NoaW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdDb2xvbWJpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDb21vcmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ29uZ29sZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ29zdGEgUmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDcm9hdGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0N1YmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ3lwcmlvdCd9LFxuICAgICAgICAgICB7bmFtZTogJ0N6ZWNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRGFuaXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRGppYm91dGknfSxcbiAgICAgICAgICAge25hbWU6ICdEb21pbmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdEdXRjaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0Vhc3QgVGltb3Jlc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdFY3VhZG9yZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRWd5cHRpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdFbWlyaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRXF1YXRvcmlhbCBHdWluZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRXJpdHJlYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdFc3Rvbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0V0aGlvcGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0Zpamlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0ZpbGlwaW5vJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRmlubmlzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0ZyZW5jaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0dhYm9uZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR2FtYmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0dlb3JnaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR2VybWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR2hhbmFpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdHcmVlayd9LFxuICAgICAgICAgICB7bmFtZTogJ0dyZW5hZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0d1YXRlbWFsYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdHdWluZWEtQmlzc2F1YW4nfSxcbiAgICAgICAgICAge25hbWU6ICdHdWluZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR3V5YW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdIYWl0aWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSGVyemVnb3Zpbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0hvbmR1cmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSHVuZ2FyaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSS1LaXJpYmF0aSd9LFxuICAgICAgICAgICB7bmFtZTogJ0ljZWxhbmRlcid9LFxuICAgICAgICAgICB7bmFtZTogJ0luZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0luZG9uZXNpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdJcmFuaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSXJhcWknfSxcbiAgICAgICAgICAge25hbWU6ICdJcmlzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0lzcmFlbGknfSxcbiAgICAgICAgICAge25hbWU6ICdJdGFsaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSXZvcmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0phbWFpY2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSmFwYW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdKb3JkYW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdLYXpha2hzdGFuaSd9LFxuICAgICAgICAgICB7bmFtZTogJ0tlbnlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0tpdHRpYW4gYW5kIE5ldmlzaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnS3V3YWl0aSd9LFxuICAgICAgICAgICB7bmFtZTogJ0t5cmd5eid9LFxuICAgICAgICAgICB7bmFtZTogJ0xhb3RpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdMYXR2aWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTGViYW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdMaWJlcmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0xpYnlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0xpZWNodGVuc3RlaW5lcid9LFxuICAgICAgICAgICB7bmFtZTogJ0xpdGh1YW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdMdXhlbWJvdXJnZXInfSxcbiAgICAgICAgICAge25hbWU6ICdNYWNlZG9uaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWFsYWdhc3knfSxcbiAgICAgICAgICAge25hbWU6ICdNYWxhd2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01hbGF5c2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01hbGRpdmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWFsaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWFsdGVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ01hcnNoYWxsZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWF1cml0YW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNYXVyaXRpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNZXhpY2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWljcm9uZXNpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNb2xkb3Zhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01vbmFjYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNb25nb2xpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNb3JvY2Nhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01vc290aG8nfSxcbiAgICAgICAgICAge25hbWU6ICdNb3Rzd2FuYSd9LFxuICAgICAgICAgICB7bmFtZTogJ01vemFtYmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdOYW1pYmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ05hdXJ1YW4nfSxcbiAgICAgICAgICAge25hbWU6ICdOZXBhbGVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ05ldyBaZWFsYW5kZXInfSxcbiAgICAgICAgICAge25hbWU6ICdOaWNhcmFndWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTmlnZXJpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdOaWdlcmllbid9LFxuICAgICAgICAgICB7bmFtZTogJ05vcnRoIEtvcmVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ05vcnRoZXJuIElyaXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTm9yd2VnaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnT21hbmknfSxcbiAgICAgICAgICAge25hbWU6ICdQYWtpc3RhbmknfSxcbiAgICAgICAgICAge25hbWU6ICdQYWxhdWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUGFuYW1hbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1BhcHVhIE5ldyBHdWluZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUGFyYWd1YXlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1BlcnV2aWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUG9saXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUG9ydHVndWVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ1FhdGFyaSd9LFxuICAgICAgICAgICB7bmFtZTogJ1JvbWFuaSd9LCAgICAgICAgICBcbiAgICAgICAgICAge25hbWU6ICdSdXNzaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUndhbmRhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1NhaW50IEx1Y2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1NhbHZhZG9yYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTYW1vYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTYW4gTWFyaW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdTYW8gVG9tZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2F1ZGknfSxcbiAgICAgICAgICAge25hbWU6ICdTY290dGlzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ1NlbmVnYWxlc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdTZXJiaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2V5Y2hlbGxvaXMnfSxcbiAgICAgICAgICAge25hbWU6ICdTaWVycmEgTGVvbmVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1NpbmdhcG9yZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2xvdmFraWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2xvdmVuaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU29sb21vbiBJc2xhbmRlcid9LFxuICAgICAgICAgICB7bmFtZTogJ1NvbWFsaSd9LFxuICAgICAgICAgICB7bmFtZTogJ1NvdXRoIEFmcmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTb3V0aCBLb3JlYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTcGFuaXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU3JpIExhbmthbid9LFxuICAgICAgICAgICB7bmFtZTogJ1N1ZGFuZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU3VyaW5hbWVyJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU3dhemknfSxcbiAgICAgICAgICAge25hbWU6ICdTd2VkaXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU3dpc3MnfSxcbiAgICAgICAgICAge25hbWU6ICdTeXJpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdUYWl3YW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdUYWppayd9LFxuICAgICAgICAgICB7bmFtZTogJ1Rhbnphbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1RoYWknfSxcbiAgICAgICAgICAge25hbWU6ICdUb2dvbGVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ1Rvbmdhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1RyaW5pZGFkaWFuIG9yIFRvYmFnb25pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdUdW5pc2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1R1cmtpc2gnfSxcbiAgICAgICAgICAge25hbWU6ICdUdXZhbHVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1VnYW5kYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdVa3JhaW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdVcnVndWF5YSd9LFxuICAgICAgICAgICB7bmFtZTogJ1V6YmVraXN0YW5pJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVmVuZXp1ZWxhJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVmlldG5hbWVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ1dlbHMnfSxcbiAgICAgICAgICAge25hbWU6ICdZZW1lbml0J30sXG4gICAgICAgICAgIHtuYW1lOiAnWmFtYmlhJ30sXG4gICAgICAgICAgIHtuYW1lOiAnWmltYmFid2UnfSxcbiAgICAgICAgXSxcblxuICAgICAgICB1c19zdGF0ZXNfYW5kX2RjOiBbXG4gICAgICAgICAgICB7bmFtZTogJ0FsYWJhbWEnLCBhYmJyZXZpYXRpb246ICdBTCd9LFxuICAgICAgICAgICAge25hbWU6ICdBbGFza2EnLCBhYmJyZXZpYXRpb246ICdBSyd9LFxuICAgICAgICAgICAge25hbWU6ICdBcml6b25hJywgYWJicmV2aWF0aW9uOiAnQVonfSxcbiAgICAgICAgICAgIHtuYW1lOiAnQXJrYW5zYXMnLCBhYmJyZXZpYXRpb246ICdBUid9LFxuICAgICAgICAgICAge25hbWU6ICdDYWxpZm9ybmlhJywgYWJicmV2aWF0aW9uOiAnQ0EnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnQ29sb3JhZG8nLCBhYmJyZXZpYXRpb246ICdDTyd9LFxuICAgICAgICAgICAge25hbWU6ICdDb25uZWN0aWN1dCcsIGFiYnJldmlhdGlvbjogJ0NUJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0RlbGF3YXJlJywgYWJicmV2aWF0aW9uOiAnREUnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnRGlzdHJpY3Qgb2YgQ29sdW1iaWEnLCBhYmJyZXZpYXRpb246ICdEQyd9LFxuICAgICAgICAgICAge25hbWU6ICdGbG9yaWRhJywgYWJicmV2aWF0aW9uOiAnRkwnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnR2VvcmdpYScsIGFiYnJldmlhdGlvbjogJ0dBJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0hhd2FpaScsIGFiYnJldmlhdGlvbjogJ0hJJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0lkYWhvJywgYWJicmV2aWF0aW9uOiAnSUQnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnSWxsaW5vaXMnLCBhYmJyZXZpYXRpb246ICdJTCd9LFxuICAgICAgICAgICAge25hbWU6ICdJbmRpYW5hJywgYWJicmV2aWF0aW9uOiAnSU4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnSW93YScsIGFiYnJldmlhdGlvbjogJ0lBJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0thbnNhcycsIGFiYnJldmlhdGlvbjogJ0tTJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0tlbnR1Y2t5JywgYWJicmV2aWF0aW9uOiAnS1knfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTG91aXNpYW5hJywgYWJicmV2aWF0aW9uOiAnTEEnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTWFpbmUnLCBhYmJyZXZpYXRpb246ICdNRSd9LFxuICAgICAgICAgICAge25hbWU6ICdNYXJ5bGFuZCcsIGFiYnJldmlhdGlvbjogJ01EJ30sXG4gICAgICAgICAgICB7bmFtZTogJ01hc3NhY2h1c2V0dHMnLCBhYmJyZXZpYXRpb246ICdNQSd9LFxuICAgICAgICAgICAge25hbWU6ICdNaWNoaWdhbicsIGFiYnJldmlhdGlvbjogJ01JJ30sXG4gICAgICAgICAgICB7bmFtZTogJ01pbm5lc290YScsIGFiYnJldmlhdGlvbjogJ01OJ30sXG4gICAgICAgICAgICB7bmFtZTogJ01pc3Npc3NpcHBpJywgYWJicmV2aWF0aW9uOiAnTVMnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTWlzc291cmknLCBhYmJyZXZpYXRpb246ICdNTyd9LFxuICAgICAgICAgICAge25hbWU6ICdNb250YW5hJywgYWJicmV2aWF0aW9uOiAnTVQnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTmVicmFza2EnLCBhYmJyZXZpYXRpb246ICdORSd9LFxuICAgICAgICAgICAge25hbWU6ICdOZXZhZGEnLCBhYmJyZXZpYXRpb246ICdOVid9LFxuICAgICAgICAgICAge25hbWU6ICdOZXcgSGFtcHNoaXJlJywgYWJicmV2aWF0aW9uOiAnTkgnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTmV3IEplcnNleScsIGFiYnJldmlhdGlvbjogJ05KJ30sXG4gICAgICAgICAgICB7bmFtZTogJ05ldyBNZXhpY28nLCBhYmJyZXZpYXRpb246ICdOTSd9LFxuICAgICAgICAgICAge25hbWU6ICdOZXcgWW9yaycsIGFiYnJldmlhdGlvbjogJ05ZJ30sXG4gICAgICAgICAgICB7bmFtZTogJ05vcnRoIENhcm9saW5hJywgYWJicmV2aWF0aW9uOiAnTkMnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTm9ydGggRGFrb3RhJywgYWJicmV2aWF0aW9uOiAnTkQnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnT2hpbycsIGFiYnJldmlhdGlvbjogJ09IJ30sXG4gICAgICAgICAgICB7bmFtZTogJ09rbGFob21hJywgYWJicmV2aWF0aW9uOiAnT0snfSxcbiAgICAgICAgICAgIHtuYW1lOiAnT3JlZ29uJywgYWJicmV2aWF0aW9uOiAnT1InfSxcbiAgICAgICAgICAgIHtuYW1lOiAnUGVubnN5bHZhbmlhJywgYWJicmV2aWF0aW9uOiAnUEEnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnUmhvZGUgSXNsYW5kJywgYWJicmV2aWF0aW9uOiAnUkknfSxcbiAgICAgICAgICAgIHtuYW1lOiAnU291dGggQ2Fyb2xpbmEnLCBhYmJyZXZpYXRpb246ICdTQyd9LFxuICAgICAgICAgICAge25hbWU6ICdTb3V0aCBEYWtvdGEnLCBhYmJyZXZpYXRpb246ICdTRCd9LFxuICAgICAgICAgICAge25hbWU6ICdUZW5uZXNzZWUnLCBhYmJyZXZpYXRpb246ICdUTid9LFxuICAgICAgICAgICAge25hbWU6ICdUZXhhcycsIGFiYnJldmlhdGlvbjogJ1RYJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1V0YWgnLCBhYmJyZXZpYXRpb246ICdVVCd9LFxuICAgICAgICAgICAge25hbWU6ICdWZXJtb250JywgYWJicmV2aWF0aW9uOiAnVlQnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnVmlyZ2luaWEnLCBhYmJyZXZpYXRpb246ICdWQSd9LFxuICAgICAgICAgICAge25hbWU6ICdXYXNoaW5ndG9uJywgYWJicmV2aWF0aW9uOiAnV0EnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnV2VzdCBWaXJnaW5pYScsIGFiYnJldmlhdGlvbjogJ1dWJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1dpc2NvbnNpbicsIGFiYnJldmlhdGlvbjogJ1dJJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1d5b21pbmcnLCBhYmJyZXZpYXRpb246ICdXWSd9XG4gICAgICAgIF0sXG5cbiAgICAgICAgdGVycml0b3JpZXM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnQW1lcmljYW4gU2Ftb2EnLCBhYmJyZXZpYXRpb246ICdBUyd9LFxuICAgICAgICAgICAge25hbWU6ICdGZWRlcmF0ZWQgU3RhdGVzIG9mIE1pY3JvbmVzaWEnLCBhYmJyZXZpYXRpb246ICdGTSd9LFxuICAgICAgICAgICAge25hbWU6ICdHdWFtJywgYWJicmV2aWF0aW9uOiAnR1UnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTWFyc2hhbGwgSXNsYW5kcycsIGFiYnJldmlhdGlvbjogJ01IJ30sXG4gICAgICAgICAgICB7bmFtZTogJ05vcnRoZXJuIE1hcmlhbmEgSXNsYW5kcycsIGFiYnJldmlhdGlvbjogJ01QJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1B1ZXJ0byBSaWNvJywgYWJicmV2aWF0aW9uOiAnUFInfSxcbiAgICAgICAgICAgIHtuYW1lOiAnVmlyZ2luIElzbGFuZHMsIFUuUy4nLCBhYmJyZXZpYXRpb246ICdWSSd9XG4gICAgICAgIF0sXG5cbiAgICAgICAgYXJtZWRfZm9yY2VzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ0FybWVkIEZvcmNlcyBFdXJvcGUnLCBhYmJyZXZpYXRpb246ICdBRSd9LFxuICAgICAgICAgICAge25hbWU6ICdBcm1lZCBGb3JjZXMgUGFjaWZpYycsIGFiYnJldmlhdGlvbjogJ0FQJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0FybWVkIEZvcmNlcyB0aGUgQW1lcmljYXMnLCBhYmJyZXZpYXRpb246ICdBQSd9XG4gICAgICAgIF0sXG5cbiAgICAgICAgY291bnRyeV9yZWdpb25zOiB7XG4gICAgICAgICAgICBpdDogW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWYWxsZSBkJ0Fvc3RhXCIsIGFiYnJldmlhdGlvbjogXCJWREFcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJQaWVtb250ZVwiLCBhYmJyZXZpYXRpb246IFwiUElFXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTG9tYmFyZGlhXCIsIGFiYnJldmlhdGlvbjogXCJMT01cIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWZW5ldG9cIiwgYWJicmV2aWF0aW9uOiBcIlZFTlwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRyZW50aW5vIEFsdG8gQWRpZ2VcIiwgYWJicmV2aWF0aW9uOiBcIlRBQVwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkZyaXVsaSBWZW5lemlhIEdpdWxpYVwiLCBhYmJyZXZpYXRpb246IFwiRlZHXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTGlndXJpYVwiLCBhYmJyZXZpYXRpb246IFwiTElHXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiRW1pbGlhIFJvbWFnbmFcIiwgYWJicmV2aWF0aW9uOiBcIkVNUlwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRvc2NhbmFcIiwgYWJicmV2aWF0aW9uOiBcIlRPU1wiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlVtYnJpYVwiLCBhYmJyZXZpYXRpb246IFwiVU1CXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTWFyY2hlXCIsIGFiYnJldmlhdGlvbjogXCJNQVJcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJBYnJ1enpvXCIsIGFiYnJldmlhdGlvbjogXCJBQlJcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJMYXppb1wiLCBhYmJyZXZpYXRpb246IFwiTEFaXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ2FtcGFuaWFcIiwgYWJicmV2aWF0aW9uOiBcIkNBTVwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlB1Z2xpYVwiLCBhYmJyZXZpYXRpb246IFwiUFVHXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQmFzaWxpY2F0YVwiLCBhYmJyZXZpYXRpb246IFwiQkFTXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTW9saXNlXCIsIGFiYnJldmlhdGlvbjogXCJNT0xcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYWxhYnJpYVwiLCBhYmJyZXZpYXRpb246IFwiQ0FMXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiU2ljaWxpYVwiLCBhYmJyZXZpYXRpb246IFwiU0lDXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiU2FyZGVnbmFcIiwgYWJicmV2aWF0aW9uOiBcIlNBUlwiIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJlZXRfc3VmZml4ZXM6IHtcbiAgICAgICAgICAgICd1cyc6IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0F2ZW51ZScsIGFiYnJldmlhdGlvbjogJ0F2ZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQm91bGV2YXJkJywgYWJicmV2aWF0aW9uOiAnQmx2ZCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQ2VudGVyJywgYWJicmV2aWF0aW9uOiAnQ3RyJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdDaXJjbGUnLCBhYmJyZXZpYXRpb246ICdDaXInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0NvdXJ0JywgYWJicmV2aWF0aW9uOiAnQ3QnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0RyaXZlJywgYWJicmV2aWF0aW9uOiAnRHInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0V4dGVuc2lvbicsIGFiYnJldmlhdGlvbjogJ0V4dCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnR2xlbicsIGFiYnJldmlhdGlvbjogJ0dsbid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnR3JvdmUnLCBhYmJyZXZpYXRpb246ICdHcnYnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0hlaWdodHMnLCBhYmJyZXZpYXRpb246ICdIdHMnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0hpZ2h3YXknLCBhYmJyZXZpYXRpb246ICdId3knfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0p1bmN0aW9uJywgYWJicmV2aWF0aW9uOiAnSmN0J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdLZXknLCBhYmJyZXZpYXRpb246ICdLZXknfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0xhbmUnLCBhYmJyZXZpYXRpb246ICdMbid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTG9vcCcsIGFiYnJldmlhdGlvbjogJ0xvb3AnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ01hbm9yJywgYWJicmV2aWF0aW9uOiAnTW5yJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdNaWxsJywgYWJicmV2aWF0aW9uOiAnTWlsbCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUGFyaycsIGFiYnJldmlhdGlvbjogJ1BhcmsnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1Bhcmt3YXknLCBhYmJyZXZpYXRpb246ICdQa3d5J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQYXNzJywgYWJicmV2aWF0aW9uOiAnUGFzcyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUGF0aCcsIGFiYnJldmlhdGlvbjogJ1BhdGgnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1Bpa2UnLCBhYmJyZXZpYXRpb246ICdQaWtlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQbGFjZScsIGFiYnJldmlhdGlvbjogJ1BsJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQbGF6YScsIGFiYnJldmlhdGlvbjogJ1Bseid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUG9pbnQnLCBhYmJyZXZpYXRpb246ICdQdCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUmlkZ2UnLCBhYmJyZXZpYXRpb246ICdSZGcnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1JpdmVyJywgYWJicmV2aWF0aW9uOiAnUml2J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdSb2FkJywgYWJicmV2aWF0aW9uOiAnUmQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1NxdWFyZScsIGFiYnJldmlhdGlvbjogJ1NxJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdTdHJlZXQnLCBhYmJyZXZpYXRpb246ICdTdCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnVGVycmFjZScsIGFiYnJldmlhdGlvbjogJ1Rlcid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnVHJhaWwnLCBhYmJyZXZpYXRpb246ICdUcmwnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1R1cm5waWtlJywgYWJicmV2aWF0aW9uOiAnVHBrZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnVmlldycsIGFiYnJldmlhdGlvbjogJ1Z3J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdXYXknLCBhYmJyZXZpYXRpb246ICdXYXknfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdpdCc6IFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdBY2Nlc3NvJywgYWJicmV2aWF0aW9uOiAnQWNjLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdBbHphaWEnLCBhYmJyZXZpYXRpb246ICdBbHouJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0FyY28nLCBhYmJyZXZpYXRpb246ICdBcmNvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0FyY2hpdm9sdG8nLCBhYmJyZXZpYXRpb246ICdBY3YuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0FyZW5hJywgYWJicmV2aWF0aW9uOiAnQXJlbmEnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQXJnaW5lJywgYWJicmV2aWF0aW9uOiAnQXJnaW5lJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0JhY2lubycsIGFiYnJldmlhdGlvbjogJ0JhY2lubycgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdCYW5jaGknLCBhYmJyZXZpYXRpb246ICdCYW5jaGknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQmFuY2hpbmEnLCBhYmJyZXZpYXRpb246ICdCYW4uJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0Jhc3Rpb25pJywgYWJicmV2aWF0aW9uOiAnQmFzLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdCZWx2ZWRlcmUnLCBhYmJyZXZpYXRpb246ICdCZWx2LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdCb3JnYXRhJywgYWJicmV2aWF0aW9uOiAnQi50YScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdCb3JnbycsIGFiYnJldmlhdGlvbjogJ0IuZ28nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2FsYXRhJywgYWJicmV2aWF0aW9uOiAnQ2FsLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDYWxsZScsIGFiYnJldmlhdGlvbjogJ0NhbGxlJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NhbXBpZWxsbycsIGFiYnJldmlhdGlvbjogJ0NhbS4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2FtcG8nLCBhYmJyZXZpYXRpb246ICdDYW0uJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NhbmFsZScsIGFiYnJldmlhdGlvbjogJ0Nhbi4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2FycmFpYScsIGFiYnJldmlhdGlvbjogJ0NhcnIuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0Nhc2NpbmEnLCBhYmJyZXZpYXRpb246ICdDYXNjaW5hJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0Nhc2Ugc3BhcnNlJywgYWJicmV2aWF0aW9uOiAnYy5zLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDYXZhbGNhdmlhJywgYWJicmV2aWF0aW9uOiAnQ3YuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NpcmNvbnZhbGxhemlvbmUnLCBhYmJyZXZpYXRpb246ICdDdi4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ29tcGxhbmFyZScsIGFiYnJldmlhdGlvbjogJ0MucmUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ29udHJhZGEnLCBhYmJyZXZpYXRpb246ICdDLmRhJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NvcnNvJywgYWJicmV2aWF0aW9uOiAnQy5zbycgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDb3J0ZScsIGFiYnJldmlhdGlvbjogJ0MudGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ29ydGlsZScsIGFiYnJldmlhdGlvbjogJ0MubGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnRGlyYW1hemlvbmUnLCBhYmJyZXZpYXRpb246ICdEaXIuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0ZvbmRhY28nLCBhYmJyZXZpYXRpb246ICdGLmNvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0ZvbmRhbWVudGEnLCBhYmJyZXZpYXRpb246ICdGLnRhJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0ZvbmRvJywgYWJicmV2aWF0aW9uOiAnRi5kbycgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdGcmF6aW9uZScsIGFiYnJldmlhdGlvbjogJ0ZyLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdJc29sYScsIGFiYnJldmlhdGlvbjogJ0lzLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdMYXJnbycsIGFiYnJldmlhdGlvbjogJ0wuZ28nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnTGl0b3JhbmVhJywgYWJicmV2aWF0aW9uOiAnTGl0LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdMdW5nb2xhZ28nLCBhYmJyZXZpYXRpb246ICdMLmdvIGxhZ28nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnTHVuZ28gUG8nLCBhYmJyZXZpYXRpb246ICdsLmdvIFBvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ01vbG8nLCBhYmJyZXZpYXRpb246ICdNb2xvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ011cmEnLCBhYmJyZXZpYXRpb246ICdNdXJhJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1Bhc3NhZ2dpbyBwcml2YXRvJywgYWJicmV2aWF0aW9uOiAncGFzcy4gcHJpdi4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUGFzc2VnZ2lhdGEnLCBhYmJyZXZpYXRpb246ICdQYXNzLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdQaWF6emEnLCBhYmJyZXZpYXRpb246ICdQLnp6YScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdQaWF6emFsZScsIGFiYnJldmlhdGlvbjogJ1AubGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUG9udGUnLCBhYmJyZXZpYXRpb246ICdQLnRlJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1BvcnRpY28nLCBhYmJyZXZpYXRpb246ICdQLmNvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1JhbXBhJywgYWJicmV2aWF0aW9uOiAnUmFtcGEnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUmVnaW9uZScsIGFiYnJldmlhdGlvbjogJ1JlZy4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUmlvbmUnLCBhYmJyZXZpYXRpb246ICdSLm5lJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1JpbycsIGFiYnJldmlhdGlvbjogJ1JpbycgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSaXBhJywgYWJicmV2aWF0aW9uOiAnUmlwYScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSaXZhJywgYWJicmV2aWF0aW9uOiAnUml2YScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSb25kw7InLCBhYmJyZXZpYXRpb246ICdSb25kw7InIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUm90b25kYScsIGFiYnJldmlhdGlvbjogJ1JvdC4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU2FncmF0bycsIGFiYnJldmlhdGlvbjogJ1NhZ3IuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1NhbGl0YScsIGFiYnJldmlhdGlvbjogJ1NhbC4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU2NhbGluYXRhJywgYWJicmV2aWF0aW9uOiAnU2NhbC4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU2NhbG9uZScsIGFiYnJldmlhdGlvbjogJ1NjYWwuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1NsYXJnbycsIGFiYnJldmlhdGlvbjogJ1NsLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdTb3R0b3BvcnRpY28nLCBhYmJyZXZpYXRpb246ICdTb3R0LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdTdHJhZGEnLCBhYmJyZXZpYXRpb246ICdTdHIuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1N0cmFkYWxlJywgYWJicmV2aWF0aW9uOiAnU3RyLmxlJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1N0cmV0dG9pYScsIGFiYnJldmlhdGlvbjogJ1N0cmV0dC4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnVHJhdmVyc2EnLCBhYmJyZXZpYXRpb246ICdUcmF2LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdWaWEnLCBhYmJyZXZpYXRpb246ICdWLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdWaWFsZScsIGFiYnJldmlhdGlvbjogJ1YubGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnVmljaW5hbGUnLCBhYmJyZXZpYXRpb246ICdWaWMubGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnVmljb2xvJywgYWJicmV2aWF0aW9uOiAnVmljLicgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vbnRoczogW1xuICAgICAgICAgICAge25hbWU6ICdKYW51YXJ5Jywgc2hvcnRfbmFtZTogJ0phbicsIG51bWVyaWM6ICcwMScsIGRheXM6IDMxfSxcbiAgICAgICAgICAgIC8vIE5vdCBtZXNzaW5nIHdpdGggbGVhcCB5ZWFycy4uLlxuICAgICAgICAgICAge25hbWU6ICdGZWJydWFyeScsIHNob3J0X25hbWU6ICdGZWInLCBudW1lcmljOiAnMDInLCBkYXlzOiAyOH0sXG4gICAgICAgICAgICB7bmFtZTogJ01hcmNoJywgc2hvcnRfbmFtZTogJ01hcicsIG51bWVyaWM6ICcwMycsIGRheXM6IDMxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnQXByaWwnLCBzaG9ydF9uYW1lOiAnQXByJywgbnVtZXJpYzogJzA0JywgZGF5czogMzB9LFxuICAgICAgICAgICAge25hbWU6ICdNYXknLCBzaG9ydF9uYW1lOiAnTWF5JywgbnVtZXJpYzogJzA1JywgZGF5czogMzF9LFxuICAgICAgICAgICAge25hbWU6ICdKdW5lJywgc2hvcnRfbmFtZTogJ0p1bicsIG51bWVyaWM6ICcwNicsIGRheXM6IDMwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnSnVseScsIHNob3J0X25hbWU6ICdKdWwnLCBudW1lcmljOiAnMDcnLCBkYXlzOiAzMX0sXG4gICAgICAgICAgICB7bmFtZTogJ0F1Z3VzdCcsIHNob3J0X25hbWU6ICdBdWcnLCBudW1lcmljOiAnMDgnLCBkYXlzOiAzMX0sXG4gICAgICAgICAgICB7bmFtZTogJ1NlcHRlbWJlcicsIHNob3J0X25hbWU6ICdTZXAnLCBudW1lcmljOiAnMDknLCBkYXlzOiAzMH0sXG4gICAgICAgICAgICB7bmFtZTogJ09jdG9iZXInLCBzaG9ydF9uYW1lOiAnT2N0JywgbnVtZXJpYzogJzEwJywgZGF5czogMzF9LFxuICAgICAgICAgICAge25hbWU6ICdOb3ZlbWJlcicsIHNob3J0X25hbWU6ICdOb3YnLCBudW1lcmljOiAnMTEnLCBkYXlzOiAzMH0sXG4gICAgICAgICAgICB7bmFtZTogJ0RlY2VtYmVyJywgc2hvcnRfbmFtZTogJ0RlYycsIG51bWVyaWM6ICcxMicsIGRheXM6IDMxfVxuICAgICAgICBdLFxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFua19jYXJkX251bWJlciNJc3N1ZXJfaWRlbnRpZmljYXRpb25fbnVtYmVyXy4yOElJTi4yOVxuICAgICAgICBjY190eXBlczogW1xuICAgICAgICAgICAge25hbWU6IFwiQW1lcmljYW4gRXhwcmVzc1wiLCBzaG9ydF9uYW1lOiAnYW1leCcsIHByZWZpeDogJzM0JywgbGVuZ3RoOiAxNX0sXG4gICAgICAgICAgICB7bmFtZTogXCJCYW5rY2FyZFwiLCBzaG9ydF9uYW1lOiAnYmFua2NhcmQnLCBwcmVmaXg6ICc1NjEwJywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJDaGluYSBVbmlvblBheVwiLCBzaG9ydF9uYW1lOiAnY2hpbmF1bmlvbicsIHByZWZpeDogJzYyJywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJEaW5lcnMgQ2x1YiBDYXJ0ZSBCbGFuY2hlXCIsIHNob3J0X25hbWU6ICdkY2NhcnRlJywgcHJlZml4OiAnMzAwJywgbGVuZ3RoOiAxNH0sXG4gICAgICAgICAgICB7bmFtZTogXCJEaW5lcnMgQ2x1YiBlblJvdXRlXCIsIHNob3J0X25hbWU6ICdkY2Vucm91dGUnLCBwcmVmaXg6ICcyMDE0JywgbGVuZ3RoOiAxNX0sXG4gICAgICAgICAgICB7bmFtZTogXCJEaW5lcnMgQ2x1YiBJbnRlcm5hdGlvbmFsXCIsIHNob3J0X25hbWU6ICdkY2ludGwnLCBwcmVmaXg6ICczNicsIGxlbmd0aDogMTR9LFxuICAgICAgICAgICAge25hbWU6IFwiRGluZXJzIENsdWIgVW5pdGVkIFN0YXRlcyAmIENhbmFkYVwiLCBzaG9ydF9uYW1lOiAnZGN1c2MnLCBwcmVmaXg6ICc1NCcsIGxlbmd0aDogMTZ9LFxuICAgICAgICAgICAge25hbWU6IFwiRGlzY292ZXIgQ2FyZFwiLCBzaG9ydF9uYW1lOiAnZGlzY292ZXInLCBwcmVmaXg6ICc2MDExJywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJJbnN0YVBheW1lbnRcIiwgc2hvcnRfbmFtZTogJ2luc3RhcGF5JywgcHJlZml4OiAnNjM3JywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJKQ0JcIiwgc2hvcnRfbmFtZTogJ2pjYicsIHByZWZpeDogJzM1MjgnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkxhc2VyXCIsIHNob3J0X25hbWU6ICdsYXNlcicsIHByZWZpeDogJzYzMDQnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIk1hZXN0cm9cIiwgc2hvcnRfbmFtZTogJ21hZXN0cm8nLCBwcmVmaXg6ICc1MDE4JywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJNYXN0ZXJjYXJkXCIsIHNob3J0X25hbWU6ICdtYycsIHByZWZpeDogJzUxJywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJTb2xvXCIsIHNob3J0X25hbWU6ICdzb2xvJywgcHJlZml4OiAnNjMzNCcsIGxlbmd0aDogMTZ9LFxuICAgICAgICAgICAge25hbWU6IFwiU3dpdGNoXCIsIHNob3J0X25hbWU6ICdzd2l0Y2gnLCBwcmVmaXg6ICc0OTAzJywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJWaXNhXCIsIHNob3J0X25hbWU6ICd2aXNhJywgcHJlZml4OiAnNCcsIGxlbmd0aDogMTZ9LFxuICAgICAgICAgICAge25hbWU6IFwiVmlzYSBFbGVjdHJvblwiLCBzaG9ydF9uYW1lOiAnZWxlY3Ryb24nLCBwcmVmaXg6ICc0MDI2JywgbGVuZ3RoOiAxNn1cbiAgICAgICAgXSxcblxuICAgICAgICAvL3JldHVybiBhbGwgd29ybGQgY3VycmVuY3kgYnkgSVNPIDQyMTdcbiAgICAgICAgY3VycmVuY3lfdHlwZXM6IFtcbiAgICAgICAgICAgIHsnY29kZScgOiAnQUVEJywgJ25hbWUnIDogJ1VuaXRlZCBBcmFiIEVtaXJhdGVzIERpcmhhbSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBRk4nLCAnbmFtZScgOiAnQWZnaGFuaXN0YW4gQWZnaGFuaSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBTEwnLCAnbmFtZScgOiAnQWxiYW5pYSBMZWsnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQU1EJywgJ25hbWUnIDogJ0FybWVuaWEgRHJhbSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBTkcnLCAnbmFtZScgOiAnTmV0aGVybGFuZHMgQW50aWxsZXMgR3VpbGRlcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBT0EnLCAnbmFtZScgOiAnQW5nb2xhIEt3YW56YSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBUlMnLCAnbmFtZScgOiAnQXJnZW50aW5hIFBlc28nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQVVEJywgJ25hbWUnIDogJ0F1c3RyYWxpYSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQVdHJywgJ25hbWUnIDogJ0FydWJhIEd1aWxkZXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQVpOJywgJ25hbWUnIDogJ0F6ZXJiYWlqYW4gTmV3IE1hbmF0J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JBTScsICduYW1lJyA6ICdCb3NuaWEgYW5kIEhlcnplZ292aW5hIENvbnZlcnRpYmxlIE1hcmthJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JCRCcsICduYW1lJyA6ICdCYXJiYWRvcyBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQkRUJywgJ25hbWUnIDogJ0JhbmdsYWRlc2ggVGFrYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCR04nLCAnbmFtZScgOiAnQnVsZ2FyaWEgTGV2J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JIRCcsICduYW1lJyA6ICdCYWhyYWluIERpbmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JJRicsICduYW1lJyA6ICdCdXJ1bmRpIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JNRCcsICduYW1lJyA6ICdCZXJtdWRhIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCTkQnLCAnbmFtZScgOiAnQnJ1bmVpIERhcnVzc2FsYW0gRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JPQicsICduYW1lJyA6ICdCb2xpdmlhIEJvbGl2aWFubyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCUkwnLCAnbmFtZScgOiAnQnJhemlsIFJlYWwnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQlNEJywgJ25hbWUnIDogJ0JhaGFtYXMgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JUTicsICduYW1lJyA6ICdCaHV0YW4gTmd1bHRydW0nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQldQJywgJ25hbWUnIDogJ0JvdHN3YW5hIFB1bGEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQllSJywgJ25hbWUnIDogJ0JlbGFydXMgUnVibGUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQlpEJywgJ25hbWUnIDogJ0JlbGl6ZSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQ0FEJywgJ25hbWUnIDogJ0NhbmFkYSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQ0RGJywgJ25hbWUnIDogJ0NvbmdvL0tpbnNoYXNhIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NIRicsICduYW1lJyA6ICdTd2l0emVybGFuZCBGcmFuYyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDTFAnLCAnbmFtZScgOiAnQ2hpbGUgUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDTlknLCAnbmFtZScgOiAnQ2hpbmEgWXVhbiBSZW5taW5iaSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDT1AnLCAnbmFtZScgOiAnQ29sb21iaWEgUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDUkMnLCAnbmFtZScgOiAnQ29zdGEgUmljYSBDb2xvbid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDVUMnLCAnbmFtZScgOiAnQ3ViYSBDb252ZXJ0aWJsZSBQZXNvJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NVUCcsICduYW1lJyA6ICdDdWJhIFBlc28nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQ1ZFJywgJ25hbWUnIDogJ0NhcGUgVmVyZGUgRXNjdWRvJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NaSycsICduYW1lJyA6ICdDemVjaCBSZXB1YmxpYyBLb3J1bmEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnREpGJywgJ25hbWUnIDogJ0RqaWJvdXRpIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0RLSycsICduYW1lJyA6ICdEZW5tYXJrIEtyb25lJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0RPUCcsICduYW1lJyA6ICdEb21pbmljYW4gUmVwdWJsaWMgUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdEWkQnLCAnbmFtZScgOiAnQWxnZXJpYSBEaW5hcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdFR1AnLCAnbmFtZScgOiAnRWd5cHQgUG91bmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnRVJOJywgJ25hbWUnIDogJ0VyaXRyZWEgTmFrZmEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnRVRCJywgJ25hbWUnIDogJ0V0aGlvcGlhIEJpcnInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnRVVSJywgJ25hbWUnIDogJ0V1cm8gTWVtYmVyIENvdW50cmllcyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdGSkQnLCAnbmFtZScgOiAnRmlqaSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnRktQJywgJ25hbWUnIDogJ0ZhbGtsYW5kIElzbGFuZHMgKE1hbHZpbmFzKSBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHQlAnLCAnbmFtZScgOiAnVW5pdGVkIEtpbmdkb20gUG91bmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnR0VMJywgJ25hbWUnIDogJ0dlb3JnaWEgTGFyaSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHR1AnLCAnbmFtZScgOiAnR3Vlcm5zZXkgUG91bmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnR0hTJywgJ25hbWUnIDogJ0doYW5hIENlZGknfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnR0lQJywgJ25hbWUnIDogJ0dpYnJhbHRhciBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHTUQnLCAnbmFtZScgOiAnR2FtYmlhIERhbGFzaSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHTkYnLCAnbmFtZScgOiAnR3VpbmVhIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0dUUScsICduYW1lJyA6ICdHdWF0ZW1hbGEgUXVldHphbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHWUQnLCAnbmFtZScgOiAnR3V5YW5hIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdIS0QnLCAnbmFtZScgOiAnSG9uZyBLb25nIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdITkwnLCAnbmFtZScgOiAnSG9uZHVyYXMgTGVtcGlyYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdIUksnLCAnbmFtZScgOiAnQ3JvYXRpYSBLdW5hJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0hURycsICduYW1lJyA6ICdIYWl0aSBHb3VyZGUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSFVGJywgJ25hbWUnIDogJ0h1bmdhcnkgRm9yaW50J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0lEUicsICduYW1lJyA6ICdJbmRvbmVzaWEgUnVwaWFoJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0lMUycsICduYW1lJyA6ICdJc3JhZWwgU2hla2VsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0lNUCcsICduYW1lJyA6ICdJc2xlIG9mIE1hbiBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdJTlInLCAnbmFtZScgOiAnSW5kaWEgUnVwZWUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSVFEJywgJ25hbWUnIDogJ0lyYXEgRGluYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSVJSJywgJ25hbWUnIDogJ0lyYW4gUmlhbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdJU0snLCAnbmFtZScgOiAnSWNlbGFuZCBLcm9uYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdKRVAnLCAnbmFtZScgOiAnSmVyc2V5IFBvdW5kJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0pNRCcsICduYW1lJyA6ICdKYW1haWNhIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdKT0QnLCAnbmFtZScgOiAnSm9yZGFuIERpbmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0pQWScsICduYW1lJyA6ICdKYXBhbiBZZW4nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnS0VTJywgJ25hbWUnIDogJ0tlbnlhIFNoaWxsaW5nJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0tHUycsICduYW1lJyA6ICdLeXJneXpzdGFuIFNvbSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdLSFInLCAnbmFtZScgOiAnQ2FtYm9kaWEgUmllbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdLTUYnLCAnbmFtZScgOiAnQ29tb3JvcyBGcmFuYyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdLUFcnLCAnbmFtZScgOiAnS29yZWEgKE5vcnRoKSBXb24nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnS1JXJywgJ25hbWUnIDogJ0tvcmVhIChTb3V0aCkgV29uJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0tXRCcsICduYW1lJyA6ICdLdXdhaXQgRGluYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnS1lEJywgJ25hbWUnIDogJ0NheW1hbiBJc2xhbmRzIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdLWlQnLCAnbmFtZScgOiAnS2F6YWtoc3RhbiBUZW5nZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdMQUsnLCAnbmFtZScgOiAnTGFvcyBLaXAnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTEJQJywgJ25hbWUnIDogJ0xlYmFub24gUG91bmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTEtSJywgJ25hbWUnIDogJ1NyaSBMYW5rYSBSdXBlZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdMUkQnLCAnbmFtZScgOiAnTGliZXJpYSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTFNMJywgJ25hbWUnIDogJ0xlc290aG8gTG90aSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdMVEwnLCAnbmFtZScgOiAnTGl0aHVhbmlhIExpdGFzJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0xZRCcsICduYW1lJyA6ICdMaWJ5YSBEaW5hcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNQUQnLCAnbmFtZScgOiAnTW9yb2NjbyBEaXJoYW0nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTURMJywgJ25hbWUnIDogJ01vbGRvdmEgTGV1J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01HQScsICduYW1lJyA6ICdNYWRhZ2FzY2FyIEFyaWFyeSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNS0QnLCAnbmFtZScgOiAnTWFjZWRvbmlhIERlbmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01NSycsICduYW1lJyA6ICdNeWFubWFyIChCdXJtYSkgS3lhdCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNTlQnLCAnbmFtZScgOiAnTW9uZ29saWEgVHVnaHJpayd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNT1AnLCAnbmFtZScgOiAnTWFjYXUgUGF0YWNhJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01STycsICduYW1lJyA6ICdNYXVyaXRhbmlhIE91Z3VpeWEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTVVSJywgJ25hbWUnIDogJ01hdXJpdGl1cyBSdXBlZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNVlInLCAnbmFtZScgOiAnTWFsZGl2ZXMgKE1hbGRpdmUgSXNsYW5kcykgUnVmaXlhYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNV0snLCAnbmFtZScgOiAnTWFsYXdpIEt3YWNoYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNWE4nLCAnbmFtZScgOiAnTWV4aWNvIFBlc28nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTVlSJywgJ25hbWUnIDogJ01hbGF5c2lhIFJpbmdnaXQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTVpOJywgJ25hbWUnIDogJ01vemFtYmlxdWUgTWV0aWNhbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdOQUQnLCAnbmFtZScgOiAnTmFtaWJpYSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTkdOJywgJ25hbWUnIDogJ05pZ2VyaWEgTmFpcmEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTklPJywgJ25hbWUnIDogJ05pY2FyYWd1YSBDb3Jkb2JhJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ05PSycsICduYW1lJyA6ICdOb3J3YXkgS3JvbmUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTlBSJywgJ25hbWUnIDogJ05lcGFsIFJ1cGVlJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ05aRCcsICduYW1lJyA6ICdOZXcgWmVhbGFuZCBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnT01SJywgJ25hbWUnIDogJ09tYW4gUmlhbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdQQUInLCAnbmFtZScgOiAnUGFuYW1hIEJhbGJvYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdQRU4nLCAnbmFtZScgOiAnUGVydSBOdWV2byBTb2wnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnUEdLJywgJ25hbWUnIDogJ1BhcHVhIE5ldyBHdWluZWEgS2luYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdQSFAnLCAnbmFtZScgOiAnUGhpbGlwcGluZXMgUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdQS1InLCAnbmFtZScgOiAnUGFraXN0YW4gUnVwZWUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnUExOJywgJ25hbWUnIDogJ1BvbGFuZCBabG90eSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdQWUcnLCAnbmFtZScgOiAnUGFyYWd1YXkgR3VhcmFuaSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdRQVInLCAnbmFtZScgOiAnUWF0YXIgUml5YWwnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnUk9OJywgJ25hbWUnIDogJ1JvbWFuaWEgTmV3IExldSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdSU0QnLCAnbmFtZScgOiAnU2VyYmlhIERpbmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1JVQicsICduYW1lJyA6ICdSdXNzaWEgUnVibGUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnUldGJywgJ25hbWUnIDogJ1J3YW5kYSBGcmFuYyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTQVInLCAnbmFtZScgOiAnU2F1ZGkgQXJhYmlhIFJpeWFsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NCRCcsICduYW1lJyA6ICdTb2xvbW9uIElzbGFuZHMgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NDUicsICduYW1lJyA6ICdTZXljaGVsbGVzIFJ1cGVlJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NERycsICduYW1lJyA6ICdTdWRhbiBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTRUsnLCAnbmFtZScgOiAnU3dlZGVuIEtyb25hJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NHRCcsICduYW1lJyA6ICdTaW5nYXBvcmUgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NIUCcsICduYW1lJyA6ICdTYWludCBIZWxlbmEgUG91bmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU0xMJywgJ25hbWUnIDogJ1NpZXJyYSBMZW9uZSBMZW9uZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTT1MnLCAnbmFtZScgOiAnU29tYWxpYSBTaGlsbGluZyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTUEwnLCAnbmFtZScgOiAnU2Vib3JnYSBMdWlnaW5vJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NSRCcsICduYW1lJyA6ICdTdXJpbmFtZSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU1REJywgJ25hbWUnIDogJ1PDo28gVG9tw6kgYW5kIFByw61uY2lwZSBEb2JyYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTVkMnLCAnbmFtZScgOiAnRWwgU2FsdmFkb3IgQ29sb24nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU1lQJywgJ25hbWUnIDogJ1N5cmlhIFBvdW5kJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NaTCcsICduYW1lJyA6ICdTd2F6aWxhbmQgTGlsYW5nZW5pJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RIQicsICduYW1lJyA6ICdUaGFpbGFuZCBCYWh0J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RKUycsICduYW1lJyA6ICdUYWppa2lzdGFuIFNvbW9uaSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdUTVQnLCAnbmFtZScgOiAnVHVya21lbmlzdGFuIE1hbmF0J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RORCcsICduYW1lJyA6ICdUdW5pc2lhIERpbmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RPUCcsICduYW1lJyA6ICdUb25nYSBQYVxcJ2FuZ2EnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVFJZJywgJ25hbWUnIDogJ1R1cmtleSBMaXJhJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RURCcsICduYW1lJyA6ICdUcmluaWRhZCBhbmQgVG9iYWdvIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdUVkQnLCAnbmFtZScgOiAnVHV2YWx1IERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdUV0QnLCAnbmFtZScgOiAnVGFpd2FuIE5ldyBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVFpTJywgJ25hbWUnIDogJ1RhbnphbmlhIFNoaWxsaW5nJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1VBSCcsICduYW1lJyA6ICdVa3JhaW5lIEhyeXZuaWEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVUdYJywgJ25hbWUnIDogJ1VnYW5kYSBTaGlsbGluZyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdVU0QnLCAnbmFtZScgOiAnVW5pdGVkIFN0YXRlcyBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVVlVJywgJ25hbWUnIDogJ1VydWd1YXkgUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdVWlMnLCAnbmFtZScgOiAnVXpiZWtpc3RhbiBTb20nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVkVGJywgJ25hbWUnIDogJ1ZlbmV6dWVsYSBCb2xpdmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1ZORCcsICduYW1lJyA6ICdWaWV0IE5hbSBEb25nJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1ZVVicsICduYW1lJyA6ICdWYW51YXR1IFZhdHUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnV1NUJywgJ25hbWUnIDogJ1NhbW9hIFRhbGEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnWEFGJywgJ25hbWUnIDogJ0NvbW11bmF1dMOpIEZpbmFuY2nDqHJlIEFmcmljYWluZSAoQkVBQykgQ0ZBIEZyYW5jIEJFQUMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnWENEJywgJ25hbWUnIDogJ0Vhc3QgQ2FyaWJiZWFuIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdYRFInLCAnbmFtZScgOiAnSW50ZXJuYXRpb25hbCBNb25ldGFyeSBGdW5kIChJTUYpIFNwZWNpYWwgRHJhd2luZyBSaWdodHMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnWE9GJywgJ25hbWUnIDogJ0NvbW11bmF1dMOpIEZpbmFuY2nDqHJlIEFmcmljYWluZSAoQkNFQU8pIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1hQRicsICduYW1lJyA6ICdDb21wdG9pcnMgRnJhbsOnYWlzIGR1IFBhY2lmaXF1ZSAoQ0ZQKSBGcmFuYyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdZRVInLCAnbmFtZScgOiAnWWVtZW4gUmlhbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdaQVInLCAnbmFtZScgOiAnU291dGggQWZyaWNhIFJhbmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnWk1XJywgJ25hbWUnIDogJ1phbWJpYSBLd2FjaGEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnWldEJywgJ25hbWUnIDogJ1ppbWJhYndlIERvbGxhcid9XG4gICAgICAgIF0sXG4gICAgICAgIFxuICAgICAgICAvLyByZXR1cm4gdGhlIG5hbWVzIG9mIGFsbCB2YWxpZGUgY29sb3JzXG4gICAgICAgIGNvbG9yTmFtZXMgOiBbICBcIkFsaWNlQmx1ZVwiLCBcIkJsYWNrXCIsIFwiTmF2eVwiLCBcIkRhcmtCbHVlXCIsIFwiTWVkaXVtQmx1ZVwiLCBcIkJsdWVcIiwgXCJEYXJrR3JlZW5cIiwgXCJHcmVlblwiLCBcIlRlYWxcIiwgXCJEYXJrQ3lhblwiLCBcIkRlZXBTa3lCbHVlXCIsIFwiRGFya1R1cnF1b2lzZVwiLCBcIk1lZGl1bVNwcmluZ0dyZWVuXCIsIFwiTGltZVwiLCBcIlNwcmluZ0dyZWVuXCIsXG4gICAgICAgICAgICBcIkFxdWFcIiwgXCJDeWFuXCIsIFwiTWlkbmlnaHRCbHVlXCIsIFwiRG9kZ2VyQmx1ZVwiLCBcIkxpZ2h0U2VhR3JlZW5cIiwgXCJGb3Jlc3RHcmVlblwiLCBcIlNlYUdyZWVuXCIsIFwiRGFya1NsYXRlR3JheVwiLCBcIkxpbWVHcmVlblwiLCBcIk1lZGl1bVNlYUdyZWVuXCIsIFwiVHVycXVvaXNlXCIsIFwiUm95YWxCbHVlXCIsIFwiU3RlZWxCbHVlXCIsIFwiRGFya1NsYXRlQmx1ZVwiLCBcIk1lZGl1bVR1cnF1b2lzZVwiLFxuICAgICAgICAgICAgXCJJbmRpZ29cIiwgXCJEYXJrT2xpdmVHcmVlblwiLCBcIkNhZGV0Qmx1ZVwiLCBcIkNvcm5mbG93ZXJCbHVlXCIsIFwiUmViZWNjYVB1cnBsZVwiLCBcIk1lZGl1bUFxdWFNYXJpbmVcIiwgXCJEaW1HcmF5XCIsIFwiU2xhdGVCbHVlXCIsIFwiT2xpdmVEcmFiXCIsIFwiU2xhdGVHcmF5XCIsIFwiTGlnaHRTbGF0ZUdyYXlcIiwgXCJNZWRpdW1TbGF0ZUJsdWVcIiwgXCJMYXduR3JlZW5cIiwgXCJDaGFydHJldXNlXCIsXG4gICAgICAgICAgICBcIkFxdWFtYXJpbmVcIiwgXCJNYXJvb25cIiwgXCJQdXJwbGVcIiwgXCJPbGl2ZVwiLCBcIkdyYXlcIiwgXCJTa3lCbHVlXCIsIFwiTGlnaHRTa3lCbHVlXCIsIFwiQmx1ZVZpb2xldFwiLCBcIkRhcmtSZWRcIiwgXCJEYXJrTWFnZW50YVwiLCBcIlNhZGRsZUJyb3duXCIsIFwiSXZvcnlcIiwgXCJXaGl0ZVwiLFxuICAgICAgICAgICAgXCJEYXJrU2VhR3JlZW5cIiwgXCJMaWdodEdyZWVuXCIsIFwiTWVkaXVtUHVycGxlXCIsIFwiRGFya1Zpb2xldFwiLCBcIlBhbGVHcmVlblwiLCBcIkRhcmtPcmNoaWRcIiwgXCJZZWxsb3dHcmVlblwiLCBcIlNpZW5uYVwiLCBcIkJyb3duXCIsIFwiRGFya0dyYXlcIiwgXCJMaWdodEJsdWVcIiwgXCJHcmVlblllbGxvd1wiLCBcIlBhbGVUdXJxdW9pc2VcIiwgXCJMaWdodFN0ZWVsQmx1ZVwiLCBcIlBvd2RlckJsdWVcIixcbiAgICAgICAgICAgIFwiRmlyZUJyaWNrXCIsIFwiRGFya0dvbGRlblJvZFwiLCBcIk1lZGl1bU9yY2hpZFwiLCBcIlJvc3lCcm93blwiLCBcIkRhcmtLaGFraVwiLCBcIlNpbHZlclwiLCBcIk1lZGl1bVZpb2xldFJlZFwiLCBcIkluZGlhblJlZFwiLCBcIlBlcnVcIiwgXCJDaG9jb2xhdGVcIiwgXCJUYW5cIiwgXCJMaWdodEdyYXlcIiwgXCJUaGlzdGxlXCIsIFwiT3JjaGlkXCIsIFwiR29sZGVuUm9kXCIsIFwiUGFsZVZpb2xldFJlZFwiLFxuICAgICAgICAgICAgXCJDcmltc29uXCIsIFwiR2FpbnNib3JvXCIsIFwiUGx1bVwiLCBcIkJ1cmx5V29vZFwiLCBcIkxpZ2h0Q3lhblwiLCBcIkxhdmVuZGVyXCIsIFwiRGFya1NhbG1vblwiLCBcIlZpb2xldFwiLCBcIlBhbGVHb2xkZW5Sb2RcIiwgXCJMaWdodENvcmFsXCIsIFwiS2hha2lcIiwgXCJBbGljZUJsdWVcIiwgXCJIb25leURld1wiLCBcIkF6dXJlXCIsIFwiU2FuZHlCcm93blwiLCBcIldoZWF0XCIsIFwiQmVpZ2VcIiwgXCJXaGl0ZVNtb2tlXCIsXG4gICAgICAgICAgICBcIk1pbnRDcmVhbVwiLCBcIkdob3N0V2hpdGVcIiwgXCJTYWxtb25cIiwgXCJBbnRpcXVlV2hpdGVcIiwgXCJMaW5lblwiLCBcIkxpZ2h0R29sZGVuUm9kWWVsbG93XCIsIFwiT2xkTGFjZVwiLCBcIlJlZFwiLCBcIkZ1Y2hzaWFcIiwgXCJNYWdlbnRhXCIsIFwiRGVlcFBpbmtcIiwgXCJPcmFuZ2VSZWRcIiwgXCJUb21hdG9cIiwgXCJIb3RQaW5rXCIsIFwiQ29yYWxcIiwgXCJEYXJrT3JhbmdlXCIsIFwiTGlnaHRTYWxtb25cIiwgXCJPcmFuZ2VcIixcbiAgICAgICAgICAgIFwiTGlnaHRQaW5rXCIsIFwiUGlua1wiLCBcIkdvbGRcIiwgXCJQZWFjaFB1ZmZcIiwgXCJOYXZham9XaGl0ZVwiLCBcIk1vY2Nhc2luXCIsIFwiQmlzcXVlXCIsIFwiTWlzdHlSb3NlXCIsIFwiQmxhbmNoZWRBbG1vbmRcIiwgXCJQYXBheWFXaGlwXCIsIFwiTGF2ZW5kZXJCbHVzaFwiLCBcIlNlYVNoZWxsXCIsIFwiQ29ybnNpbGtcIiwgXCJMZW1vbkNoaWZmb25cIiwgXCJGbG9yYWxXaGl0ZVwiLCBcIlNub3dcIiwgXCJZZWxsb3dcIiwgXCJMaWdodFllbGxvd1wiXG4gICAgICAgIF0sICAgICAgICBcblxuICAgICAgICBmaWxlRXh0ZW5zaW9uIDoge1xuICAgICAgICAgICAgXCJyYXN0ZXJcIiAgICA6IFtcImJtcFwiLCBcImdpZlwiLCBcImdwbFwiLCBcImljb1wiLCBcImpwZWdcIiwgXCJwc2RcIiwgXCJwbmdcIiwgXCJwc3BcIiwgXCJyYXdcIiwgXCJ0aWZmXCJdLFxuICAgICAgICAgICAgXCJ2ZWN0b3JcIiAgICA6IFtcIjNkdlwiLCBcImFtZlwiLCBcImF3Z1wiLCBcImFpXCIsIFwiY2dtXCIsIFwiY2RyXCIsIFwiY214XCIsIFwiZHhmXCIsIFwiZTJkXCIsIFwiZWd0XCIsIFwiZXBzXCIsIFwiZnNcIiwgXCJvZGdcIiwgXCJzdmdcIiwgXCJ4YXJcIl0sXG4gICAgICAgICAgICBcIjNkXCIgICAgICAgIDogW1wiM2RtZlwiLCBcIjNkbVwiLCBcIjNtZlwiLCBcIjNkc1wiLCBcImFuOFwiLCBcImFvaVwiLCBcImJsZW5kXCIsIFwiY2FsM2RcIiwgXCJjb2JcIiwgXCJjdG1cIiwgXCJpb2JcIiwgXCJqYXNcIiwgXCJtYXhcIiwgXCJtYlwiLCBcIm1keFwiLCBcIm9ialwiLCBcInhcIiwgXCJ4M2RcIl0sXG4gICAgICAgICAgICBcImRvY3VtZW50XCIgIDogW1wiZG9jXCIsIFwiZG9jeFwiLCBcImRvdFwiLCBcImh0bWxcIiwgXCJ4bWxcIiwgXCJvZHRcIiwgXCJvZG1cIiwgXCJvdHRcIiwgXCJjc3ZcIiwgXCJydGZcIiwgXCJ0ZXhcIiwgXCJ4aHRtbFwiLCBcInhwc1wiXVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgb19rZXlzID0gKE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob19oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIF9jb3B5T2JqZWN0KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIga2V5cyA9IG9fa2V5cyhzb3VyY2UpO1xuICAgICAgdmFyIGtleTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldIHx8IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jb3B5QXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIF90YXJnZXQpIHtcbiAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBfdGFyZ2V0IHx8IChpc0FycmF5ID8gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpIDoge30pO1xuXG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgX2NvcHlBcnJheShzb3VyY2UsIHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2NvcHlPYmplY3Qoc291cmNlLCB0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBkYXRhIGJhc2VkIG9uIGtleSoqL1xuICAgIENoYW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNvcHlPYmplY3QoZGF0YVtuYW1lXSk7XG4gICAgfTtcblxuICAgIC8vIE1hYyBBZGRyZXNzXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5tYWNfYWRkcmVzcyA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgICAvLyB0eXBpY2FsbHkgbWFjIGFkZHJlc3NlcyBhcmUgc2VwYXJhdGVkIGJ5IFwiOlwiXG4gICAgICAgIC8vIGhvd2V2ZXIgdGhleSBjYW4gYWxzbyBiZSBzZXBhcmF0ZWQgYnkgXCItXCJcbiAgICAgICAgLy8gdGhlIG5ldHdvcmsgdmFyaWFudCB1c2VzIGEgZG90IGV2ZXJ5IGZvdXJ0aCBieXRlXG5cbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZighb3B0aW9ucy5zZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VwYXJhdG9yID0gIG9wdGlvbnMubmV0d29ya1ZlcnNpb24gPyBcIi5cIiA6IFwiOlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hY19wb29sPVwiQUJDREVGMTIzNDU2Nzg5MFwiLFxuICAgICAgICAgICAgbWFjID0gXCJcIjtcbiAgICAgICAgaWYoIW9wdGlvbnMubmV0d29ya1ZlcnNpb24pIHtcbiAgICAgICAgICAgIG1hYyA9IHRoaXMubih0aGlzLnN0cmluZywgNiwgeyBwb29sOiBtYWNfcG9vbCwgbGVuZ3RoOjIgfSkuam9pbihvcHRpb25zLnNlcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYWMgPSB0aGlzLm4odGhpcy5zdHJpbmcsIDMsIHsgcG9vbDogbWFjX3Bvb2wsIGxlbmd0aDo0IH0pLmpvaW4ob3B0aW9ucy5zZXBhcmF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hYztcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5ub3JtYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge21lYW4gOiAwLCBkZXYgOiAxLCBwb29sIDogW119KTtcblxuICAgICAgICB0ZXN0UmFuZ2UoXG4gICAgICAgICAgICBvcHRpb25zLnBvb2wuY29uc3RydWN0b3IgIT09IEFycmF5LFxuICAgICAgICAgICAgXCJDaGFuY2U6IFRoZSBwb29sIG9wdGlvbiBtdXN0IGJlIGEgdmFsaWQgYXJyYXkuXCJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiBhIHBvb2wgaGFzIGJlZW4gcGFzc2VkLCB0aGVuIHdlIGFyZSByZXR1cm5pbmcgYW4gaXRlbSBmcm9tIHRoYXQgcG9vbCxcbiAgICAgICAgLy8gdXNpbmcgdGhlIG5vcm1hbCBkaXN0cmlidXRpb24gc2V0dGluZ3MgdGhhdCB3ZXJlIHBhc3NlZCBpblxuICAgICAgICBpZiAob3B0aW9ucy5wb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbF9wb29sKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIE1hcnNhZ2xpYSBQb2xhciBtZXRob2RcbiAgICAgICAgdmFyIHMsIHUsIHYsIG5vcm0sXG4gICAgICAgICAgICBtZWFuID0gb3B0aW9ucy5tZWFuLFxuICAgICAgICAgICAgZGV2ID0gb3B0aW9ucy5kZXY7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVSBhbmQgViBhcmUgZnJvbSB0aGUgdW5pZm9ybSBkaXN0cmlidXRpb24gb24gKC0xLCAxKVxuICAgICAgICAgICAgdSA9IHRoaXMucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICAgIHYgPSB0aGlzLnJhbmRvbSgpICogMiAtIDE7XG5cbiAgICAgICAgICAgIHMgPSB1ICogdSArIHYgKiB2O1xuICAgICAgICB9IHdoaWxlIChzID49IDEpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHN0YW5kYXJkIG5vcm1hbCB2YXJpYXRlXG4gICAgICAgIG5vcm0gPSB1ICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocykgLyBzKTtcblxuICAgICAgICAvLyBTaGFwZSBhbmQgc2NhbGVcbiAgICAgICAgcmV0dXJuIGRldiAqIG5vcm0gKyBtZWFuO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm5vcm1hbF9wb29sID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgcGVyZm9ybWFuY2VDb3VudGVyID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGgucm91bmQodGhpcy5ub3JtYWwoeyBtZWFuOiBvcHRpb25zLm1lYW4sIGRldjogb3B0aW9ucy5kZXYgfSkpO1xuICAgICAgICAgICAgaWYgKGlkeCA8IG9wdGlvbnMucG9vbC5sZW5ndGggJiYgaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5wb29sW2lkeF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlQ291bnRlcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlKHBlcmZvcm1hbmNlQ291bnRlciA8IDEwMCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDaGFuY2U6IFlvdXIgcG9vbCBpcyB0b28gc21hbGwgZm9yIHRoZSBnaXZlbiBtZWFuIGFuZCBzdGFuZGFyZCBkZXZpYXRpb24uIFBsZWFzZSBhZGp1c3QuXCIpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnJhZGlvID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSW5pdGlhbCBMZXR0ZXIgKFR5cGljYWxseSBEZXNpZ25hdGVkIGJ5IFNpZGUgb2YgTWlzc2lzc2lwcGkgUml2ZXIpXG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7c2lkZSA6IFwiP1wifSk7XG4gICAgICAgIHZhciBmbCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5zaWRlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSBcImVhc3RcIjpcbiAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICAgIGZsID0gXCJXXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndlc3RcIjpcbiAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgIGZsID0gXCJLXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGZsID0gdGhpcy5jaGFyYWN0ZXIoe3Bvb2w6IFwiS1dcIn0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmwgKyB0aGlzLmNoYXJhY3Rlcih7YWxwaGE6IHRydWUsIGNhc2luZzogXCJ1cHBlclwifSkgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhcmFjdGVyKHthbHBoYTogdHJ1ZSwgY2FzaW5nOiBcInVwcGVyXCJ9KSArXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXIoe2FscGhhOiB0cnVlLCBjYXNpbmc6IFwidXBwZXJcIn0pO1xuICAgIH07XG5cbiAgICAvLyBTZXQgdGhlIGRhdGEgYXMga2V5IGFuZCBkYXRhIG9yIHRoZSBkYXRhIG1hcFxuICAgIENoYW5jZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRhdGFbbmFtZV0gPSB2YWx1ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gY29weU9iamVjdChuYW1lLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnR2ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFkaW8ob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8vIElEIG51bWJlciBmb3IgQnJhemlsIGNvbXBhbmllc1xuICAgIENoYW5jZS5wcm90b3R5cGUuY25waiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLm4odGhpcy5uYXR1cmFsLCA4LCB7IG1heDogOSB9KTtcbiAgICAgICAgdmFyIGQxID0gMituWzddKjYrbls2XSo3K25bNV0qOCtuWzRdKjkrblszXSoyK25bMl0qMytuWzFdKjQrblswXSo1O1xuICAgICAgICBkMSA9IDExIC0gKGQxICUgMTEpO1xuICAgICAgICBpZiAoZDE+PTEwKXtcbiAgICAgICAgICAgIGQxID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZDIgPSBkMSoyKzMrbls3XSo3K25bNl0qOCtuWzVdKjkrbls0XSoyK25bM10qMytuWzJdKjQrblsxXSo1K25bMF0qNjtcbiAgICAgICAgZDIgPSAxMSAtIChkMiAlIDExKTtcbiAgICAgICAgaWYgKGQyPj0xMCl7XG4gICAgICAgICAgICBkMiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnK25bMF0rblsxXSsnLicrblsyXStuWzNdK25bNF0rJy4nK25bNV0rbls2XStuWzddKycvMDAwMS0nK2QxK2QyO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgTWlzY2VsbGFuZW91cyAtLVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5tZXJzZW5uZV90d2lzdGVyID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXJzZW5uZVR3aXN0ZXIoc2VlZCk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuYmx1ZWltcF9tZDUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmx1ZUltcE1ENSgpO1xuICAgIH07XG5cbiAgICAvLyBNZXJzZW5uZSBUd2lzdGVyIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFua3NlYW4vMzAwNDk0XG4gICAgdmFyIE1lcnNlbm5lVHdpc3RlciA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIGlmIChzZWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGtlcHQgcmFuZG9tIG51bWJlciBzYW1lIHNpemUgYXMgdGltZSB1c2VkIHByZXZpb3VzbHkgdG8gZW5zdXJlIG5vIHVuZXhwZWN0ZWQgcmVzdWx0cyBkb3duc3RyZWFtXG4gICAgICAgICAgICBzZWVkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk1hdGgucG93KDEwLDEzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cbiAgICAgICAgdGhpcy5OID0gNjI0O1xuICAgICAgICB0aGlzLk0gPSAzOTc7XG4gICAgICAgIHRoaXMuTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXG4gICAgICAgIHRoaXMuVVBQRVJfTUFTSyA9IDB4ODAwMDAwMDA7IC8qIG1vc3Qgc2lnbmlmaWNhbnQgdy1yIGJpdHMgKi9cbiAgICAgICAgdGhpcy5MT1dFUl9NQVNLID0gMHg3ZmZmZmZmZjsgLyogbGVhc3Qgc2lnbmlmaWNhbnQgciBiaXRzICovXG5cbiAgICAgICAgdGhpcy5tdCA9IG5ldyBBcnJheSh0aGlzLk4pOyAvKiB0aGUgYXJyYXkgZm9yIHRoZSBzdGF0ZSB2ZWN0b3IgKi9cbiAgICAgICAgdGhpcy5tdGkgPSB0aGlzLk4gKyAxOyAvKiBtdGk9PU4gKyAxIG1lYW5zIG10W05dIGlzIG5vdCBpbml0aWFsaXplZCAqL1xuXG4gICAgICAgIHRoaXMuaW5pdF9nZW5yYW5kKHNlZWQpO1xuICAgIH07XG5cbiAgICAvKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUuaW5pdF9nZW5yYW5kID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdGhpcy5tdFswXSA9IHMgPj4+IDA7XG4gICAgICAgIGZvciAodGhpcy5tdGkgPSAxOyB0aGlzLm10aSA8IHRoaXMuTjsgdGhpcy5tdGkrKykge1xuICAgICAgICAgICAgcyA9IHRoaXMubXRbdGhpcy5tdGkgLSAxXSBeICh0aGlzLm10W3RoaXMubXRpIC0gMV0gPj4+IDMwKTtcbiAgICAgICAgICAgIHRoaXMubXRbdGhpcy5tdGldID0gKCgoKChzICYgMHhmZmZmMDAwMCkgPj4+IDE2KSAqIDE4MTI0MzMyNTMpIDw8IDE2KSArIChzICYgMHgwMDAwZmZmZikgKiAxODEyNDMzMjUzKSArIHRoaXMubXRpO1xuICAgICAgICAgICAgLyogU2VlIEtudXRoIFRBT0NQIFZvbDIuIDNyZCBFZC4gUC4xMDYgZm9yIG11bHRpcGxpZXIuICovXG4gICAgICAgICAgICAvKiBJbiB0aGUgcHJldmlvdXMgdmVyc2lvbnMsIE1TQnMgb2YgdGhlIHNlZWQgYWZmZWN0ICAgKi9cbiAgICAgICAgICAgIC8qIG9ubHkgTVNCcyBvZiB0aGUgYXJyYXkgbXRbXS4gICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyogMjAwMi8wMS8wOSBtb2RpZmllZCBieSBNYWtvdG8gTWF0c3Vtb3RvICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm10W3RoaXMubXRpXSA+Pj49IDA7XG4gICAgICAgICAgICAvKiBmb3IgPjMyIGJpdCBtYWNoaW5lcyAqL1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIGluaXRpYWxpemUgYnkgYW4gYXJyYXkgd2l0aCBhcnJheS1sZW5ndGggKi9cbiAgICAvKiBpbml0X2tleSBpcyB0aGUgYXJyYXkgZm9yIGluaXRpYWxpemluZyBrZXlzICovXG4gICAgLyoga2V5X2xlbmd0aCBpcyBpdHMgbGVuZ3RoICovXG4gICAgLyogc2xpZ2h0IGNoYW5nZSBmb3IgQysrLCAyMDA0LzIvMjYgKi9cbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmluaXRfYnlfYXJyYXkgPSBmdW5jdGlvbiAoaW5pdF9rZXksIGtleV9sZW5ndGgpIHtcbiAgICAgICAgdmFyIGkgPSAxLCBqID0gMCwgaywgcztcbiAgICAgICAgdGhpcy5pbml0X2dlbnJhbmQoMTk2NTAyMTgpO1xuICAgICAgICBrID0gKHRoaXMuTiA+IGtleV9sZW5ndGggPyB0aGlzLk4gOiBrZXlfbGVuZ3RoKTtcbiAgICAgICAgZm9yICg7IGs7IGstLSkge1xuICAgICAgICAgICAgcyA9IHRoaXMubXRbaSAtIDFdIF4gKHRoaXMubXRbaSAtIDFdID4+PiAzMCk7XG4gICAgICAgICAgICB0aGlzLm10W2ldID0gKHRoaXMubXRbaV0gXiAoKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTY2NDUyNSkgPDwgMTYpICsgKChzICYgMHgwMDAwZmZmZikgKiAxNjY0NTI1KSkpICsgaW5pdF9rZXlbal0gKyBqOyAvKiBub24gbGluZWFyICovXG4gICAgICAgICAgICB0aGlzLm10W2ldID4+Pj0gMDsgLyogZm9yIFdPUkRTSVpFID4gMzIgbWFjaGluZXMgKi9cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIGlmIChpID49IHRoaXMuTikgeyB0aGlzLm10WzBdID0gdGhpcy5tdFt0aGlzLk4gLSAxXTsgaSA9IDE7IH1cbiAgICAgICAgICAgIGlmIChqID49IGtleV9sZW5ndGgpIHsgaiA9IDA7IH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgPSB0aGlzLk4gLSAxOyBrOyBrLS0pIHtcbiAgICAgICAgICAgIHMgPSB0aGlzLm10W2kgLSAxXSBeICh0aGlzLm10W2kgLSAxXSA+Pj4gMzApO1xuICAgICAgICAgICAgdGhpcy5tdFtpXSA9ICh0aGlzLm10W2ldIF4gKCgoKChzICYgMHhmZmZmMDAwMCkgPj4+IDE2KSAqIDE1NjYwODM5NDEpIDw8IDE2KSArIChzICYgMHgwMDAwZmZmZikgKiAxNTY2MDgzOTQxKSkgLSBpOyAvKiBub24gbGluZWFyICovXG4gICAgICAgICAgICB0aGlzLm10W2ldID4+Pj0gMDsgLyogZm9yIFdPUkRTSVpFID4gMzIgbWFjaGluZXMgKi9cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChpID49IHRoaXMuTikgeyB0aGlzLm10WzBdID0gdGhpcy5tdFt0aGlzLk4gLSAxXTsgaSA9IDE7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubXRbMF0gPSAweDgwMDAwMDAwOyAvKiBNU0IgaXMgMTsgYXNzdXJpbmcgbm9uLXplcm8gaW5pdGlhbCBhcnJheSAqL1xuICAgIH07XG5cbiAgICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDB4ZmZmZmZmZmZdLWludGVydmFsICovXG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5nZW5yYW5kX2ludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgdmFyIG1hZzAxID0gbmV3IEFycmF5KDB4MCwgdGhpcy5NQVRSSVhfQSk7XG4gICAgICAgIC8qIG1hZzAxW3hdID0geCAqIE1BVFJJWF9BICBmb3IgeD0wLDEgKi9cblxuICAgICAgICBpZiAodGhpcy5tdGkgPj0gdGhpcy5OKSB7IC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cbiAgICAgICAgICAgIHZhciBraztcblxuICAgICAgICAgICAgaWYgKHRoaXMubXRpID09PSB0aGlzLk4gKyAxKSB7ICAgLyogaWYgaW5pdF9nZW5yYW5kKCkgaGFzIG5vdCBiZWVuIGNhbGxlZCwgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmluaXRfZ2VucmFuZCg1NDg5KTsgLyogYSBkZWZhdWx0IGluaXRpYWwgc2VlZCBpcyB1c2VkICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGtrID0gMDsga2sgPCB0aGlzLk4gLSB0aGlzLk07IGtrKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gKHRoaXMubXRba2tdJnRoaXMuVVBQRVJfTUFTSyl8KHRoaXMubXRba2sgKyAxXSZ0aGlzLkxPV0VSX01BU0spO1xuICAgICAgICAgICAgICAgIHRoaXMubXRba2tdID0gdGhpcy5tdFtrayArIHRoaXMuTV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoO2trIDwgdGhpcy5OIC0gMTsga2srKykge1xuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5tdFtra10mdGhpcy5VUFBFUl9NQVNLKXwodGhpcy5tdFtrayArIDFdJnRoaXMuTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tdFtra10gPSB0aGlzLm10W2trICsgKHRoaXMuTSAtIHRoaXMuTildIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gKHRoaXMubXRbdGhpcy5OIC0gMV0mdGhpcy5VUFBFUl9NQVNLKXwodGhpcy5tdFswXSZ0aGlzLkxPV0VSX01BU0spO1xuICAgICAgICAgICAgdGhpcy5tdFt0aGlzLk4gLSAxXSA9IHRoaXMubXRbdGhpcy5NIC0gMV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcblxuICAgICAgICAgICAgdGhpcy5tdGkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHRoaXMubXRbdGhpcy5tdGkrK107XG5cbiAgICAgICAgLyogVGVtcGVyaW5nICovXG4gICAgICAgIHkgXj0gKHkgPj4+IDExKTtcbiAgICAgICAgeSBePSAoeSA8PCA3KSAmIDB4OWQyYzU2ODA7XG4gICAgICAgIHkgXj0gKHkgPDwgMTUpICYgMHhlZmM2MDAwMDtcbiAgICAgICAgeSBePSAoeSA+Pj4gMTgpO1xuXG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH07XG5cbiAgICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDB4N2ZmZmZmZmZdLWludGVydmFsICovXG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5nZW5yYW5kX2ludDMxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2VucmFuZF9pbnQzMigpID4+PiAxKTtcbiAgICB9O1xuXG4gICAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxXS1yZWFsLWludGVydmFsICovXG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5nZW5yYW5kX3JlYWwxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5yYW5kX2ludDMyKCkgKiAoMS4wIC8gNDI5NDk2NzI5NS4wKTtcbiAgICAgICAgLyogZGl2aWRlZCBieSAyXjMyLTEgKi9cbiAgICB9O1xuXG4gICAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKS1yZWFsLWludGVydmFsICovXG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbnJhbmRfaW50MzIoKSAqICgxLjAgLyA0Mjk0OTY3Mjk2LjApO1xuICAgICAgICAvKiBkaXZpZGVkIGJ5IDJeMzIgKi9cbiAgICB9O1xuXG4gICAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiAoMCwxKS1yZWFsLWludGVydmFsICovXG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5nZW5yYW5kX3JlYWwzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2VucmFuZF9pbnQzMigpICsgMC41KSAqICgxLjAgLyA0Mjk0OTY3Mjk2LjApO1xuICAgICAgICAvKiBkaXZpZGVkIGJ5IDJeMzIgKi9cbiAgICB9O1xuXG4gICAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uKi9cbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVzNTMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZW5yYW5kX2ludDMyKCk+Pj41LCBiID0gdGhpcy5nZW5yYW5kX2ludDMyKCk+Pj42O1xuICAgICAgICByZXR1cm4gKGEgKiA2NzEwODg2NC4wICsgYikgKiAoMS4wIC8gOTAwNzE5OTI1NDc0MDk5Mi4wKTtcbiAgICB9O1xuXG4gICAgLy8gQmx1ZUltcCBNRDUgaGFzaGluZyBhbGdvcml0aG0gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICAgIHZhciBCbHVlSW1wTUQ1ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5WRVJTSU9OID0gJzEuMC4xJztcblxuICAgIC8qXG4gICAgKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gICAgKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICAgICovXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUuc2FmZV9hZGQgPSBmdW5jdGlvbiBzYWZlX2FkZCh4LCB5KSB7XG4gICAgICAgIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRiksXG4gICAgICAgICAgICBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgICAgICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5iaXRfcm9sbCA9IGZ1bmN0aW9uIChudW0sIGNudCkge1xuICAgICAgICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmaXZlIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICAgICovXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUubWQ1X2NtbiA9IGZ1bmN0aW9uIChxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVfYWRkKHRoaXMuYml0X3JvbGwodGhpcy5zYWZlX2FkZCh0aGlzLnNhZmVfYWRkKGEsIHEpLCB0aGlzLnNhZmVfYWRkKHgsIHQpKSwgcyksIGIpO1xuICAgIH07XG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUubWQ1X2ZmID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgfTtcbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5tZDVfZ2cgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9O1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLm1kNV9oaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9O1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLm1kNV9paSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAgICAqL1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLmJpbmxfbWQ1ID0gZnVuY3Rpb24gKHgsIGxlbikge1xuICAgICAgICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICAgICAgICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IChsZW4gJSAzMik7XG4gICAgICAgIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICAgICAgICB2YXIgaSwgb2xkYSwgb2xkYiwgb2xkYywgb2xkZCxcbiAgICAgICAgICAgIGEgPSAgMTczMjU4NDE5MyxcbiAgICAgICAgICAgIGIgPSAtMjcxNzMzODc5LFxuICAgICAgICAgICAgYyA9IC0xNzMyNTg0MTk0LFxuICAgICAgICAgICAgZCA9ICAyNzE3MzM4Nzg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBvbGRhID0gYTtcbiAgICAgICAgICAgIG9sZGIgPSBiO1xuICAgICAgICAgICAgb2xkYyA9IGM7XG4gICAgICAgICAgICBvbGRkID0gZDtcblxuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaV0sICAgICAgIDcsIC02ODA4NzY5MzYpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArICAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSArICAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArICAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAgNF0sICA3LCAtMTc2NDE4ODk3KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9mZihkLCBhLCBiLCBjLCB4W2kgKyAgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArICA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfZmYoYSwgYiwgYywgZCwgeFtpICsgIDhdLCAgNywgIDE3NzAwMzU0MTYpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArICA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sICA3LCAgMTgwNDYwMzY4Mik7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgIDFdLCAgNSwgLTE2NTc5NjUxMCk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgIDZdLCAgOSwgLTEwNjk1MDE2MzIpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2dnKGIsIGMsIGQsIGEsIHhbaV0sICAgICAgMjAsIC0zNzM4OTczMDIpO1xuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSArICA1XSwgIDUsIC03MDE1NTg2OTEpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgIDksICAzODAxNjA4Myk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgIDldLCAgNSwgIDU2ODQ0NjQzOCk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCAgOSwgLTEwMTk4MDM2OTApO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArICAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSArICA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9nZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sICA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgIDJdLCAgOSwgLTUxNDAzNzg0KTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9nZyhjLCBkLCBhLCBiLCB4W2kgKyAgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgIDVdLCAgNCwgLTM3ODU1OCk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfaGgoZCwgYSwgYiwgYywgeFtpICsgIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9oaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArICAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgIDQsICA2ODEyNzkxNzQpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2hoKGQsIGEsIGIsIGMsIHhbaV0sICAgICAgMTEsIC0zNTg1MzcyMjIpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArICAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArICA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgIDldLCAgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfaGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9paShhLCBiLCBjLCBkLCB4W2ldLCAgICAgICA2LCAtMTk4NjMwODQ0KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfaWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArICA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCAgNiwgIDE3MDA0ODU1NzEpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSArICAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSArICA4XSwgIDYsICAxODczMzEzMzU5KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArICA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9paShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgIDRdLCAgNiwgLTE0NTUyMzA3MCk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArICAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArICA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgICAgICAgICBhID0gdGhpcy5zYWZlX2FkZChhLCBvbGRhKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLnNhZmVfYWRkKGIsIG9sZGIpO1xuICAgICAgICAgICAgYyA9IHRoaXMuc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgICAgICAgICBkID0gdGhpcy5zYWZlX2FkZChkLCBvbGRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2EsIGIsIGMsIGRdO1xuICAgIH07XG5cbiAgICAvKlxuICAgICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5iaW5sMnJzdHIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvdXRwdXQgPSAnJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDMyOyBpICs9IDgpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpID4+IDVdID4+PiAoaSAlIDMyKSkgJiAweEZGKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICAgICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5yc3RyMmJpbmwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvdXRwdXQgPSBbXTtcbiAgICAgICAgb3V0cHV0WyhpbnB1dC5sZW5ndGggPj4gMikgLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogODsgaSArPSA4KSB7XG4gICAgICAgICAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXQuY2hhckNvZGVBdChpIC8gOCkgJiAweEZGKSA8PCAoaSAlIDMyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYSByYXcgc3RyaW5nXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5yc3RyX21kNSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmwycnN0cih0aGlzLmJpbmxfbWQ1KHRoaXMucnN0cjJiaW5sKHMpLCBzLmxlbmd0aCAqIDgpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuICAgICovXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUucnN0cl9obWFjX21kNSA9IGZ1bmN0aW9uIChrZXksIGRhdGEpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBia2V5ID0gdGhpcy5yc3RyMmJpbmwoa2V5KSxcbiAgICAgICAgICAgIGlwYWQgPSBbXSxcbiAgICAgICAgICAgIG9wYWQgPSBbXSxcbiAgICAgICAgICAgIGhhc2g7XG4gICAgICAgIGlwYWRbMTVdID0gb3BhZFsxNV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChia2V5Lmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICBia2V5ID0gdGhpcy5iaW5sX21kNShia2V5LCBrZXkubGVuZ3RoICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICAgICAgICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgICAgICAgfVxuICAgICAgICBoYXNoID0gdGhpcy5iaW5sX21kNShpcGFkLmNvbmNhdCh0aGlzLnJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmwycnN0cih0aGlzLmJpbmxfbWQ1KG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxMjgpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgaGV4IHN0cmluZ1xuICAgICovXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUucnN0cjJoZXggPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGhleF90YWIgPSAnMDEyMzQ1Njc4OWFiY2RlZicsXG4gICAgICAgICAgICBvdXRwdXQgPSAnJyxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgb3V0cHV0ICs9IGhleF90YWIuY2hhckF0KCh4ID4+PiA0KSAmIDB4MEYpICtcbiAgICAgICAgICAgICAgICBoZXhfdGFiLmNoYXJBdCh4ICYgMHgwRik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqIEVuY29kZSBhIHN0cmluZyBhcyB1dGYtOFxuICAgICovXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUuc3RyMnJzdHJfdXRmOCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBUYWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgcmF3IG9yIGhleCBlbmNvZGVkIHN0cmluZ3NcbiAgICAqL1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLnJhd19tZDUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5yc3RyX21kNSh0aGlzLnN0cjJyc3RyX3V0ZjgocykpO1xuICAgIH07XG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUuaGV4X21kNSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJzdHIyaGV4KHRoaXMucmF3X21kNShzKSk7XG4gICAgfTtcbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5yYXdfaG1hY19tZDUgPSBmdW5jdGlvbiAoaywgZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yc3RyX2htYWNfbWQ1KHRoaXMuc3RyMnJzdHJfdXRmOChrKSwgdGhpcy5zdHIycnN0cl91dGY4KGQpKTtcbiAgICB9O1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLmhleF9obWFjX21kNSA9IGZ1bmN0aW9uIChrLCBkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJzdHIyaGV4KHRoaXMucmF3X2htYWNfbWQ1KGssIGQpKTtcbiAgICB9O1xuXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUubWQ1ID0gZnVuY3Rpb24gKHN0cmluZywga2V5LCByYXcpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGV4X21kNShzdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXdfbWQ1KHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGV4X2htYWNfbWQ1KGtleSwgc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJhd19obWFjX21kNShrZXksIHN0cmluZyk7XG4gICAgfTtcblxuICAgIC8vIENvbW1vbkpTIG1vZHVsZVxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBDaGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5DaGFuY2UgPSBDaGFuY2U7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGVcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENoYW5jZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBpbXBvcnRzU2NyaXBzIG9iamVjdCBkZWZpbmUgY2hhbmNlIGZvciB3b3JrZXJcbiAgICBpZiAodHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoYW5jZSA9IG5ldyBDaGFuY2UoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHdpbmRvdyBvYmplY3QsIHRoYXQgYXQgbGVhc3QgaGFzIGEgZG9jdW1lbnQgcHJvcGVydHksXG4gICAgLy8gaW5zdGFudGlhdGUgYW5kIGRlZmluZSBjaGFuY2Ugb24gdGhlIHdpbmRvd1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd2luZG93LkNoYW5jZSA9IENoYW5jZTtcbiAgICAgICAgd2luZG93LmNoYW5jZSA9IG5ldyBDaGFuY2UoKTtcbiAgICB9XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY2hhbmNlL2NoYW5jZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgZnVuY3Rpb24gQmFyICgpIHt9XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICBhcnIuY29uc3RydWN0b3IgPT09IEJhciAmJiAvLyBjb25zdHJ1Y3RvciBjYW4gYmUgc2V0XG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59IGVsc2Uge1xuICAvLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuICBCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuICBCdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9idWZmZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYXNlNjQtanMvbGliL2I2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2llZWU3NTQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImNvbnN0IHtSZWNvcmR9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbmNvbnN0IFJFQURZID0gJ3JlYWR5JztcbmNvbnN0IFJVTk5JTkcgPSAncnVubmluZyc7XG5jb25zdCBXT04gPSAnd29uJztcbmNvbnN0IExPU1QgPSAnbG9zdCc7XG5cbmNvbnN0IEdhbWVTdGF0dXNSZWNvcmQgPSBSZWNvcmQoe1xuICBzdGF0dXM6IFJFQURZLFxuICBtZXNzYWdlOiAnJyxcbn0pO1xuXG5jbGFzcyBHYW1lU3RhdHVzIGV4dGVuZHMgR2FtZVN0YXR1c1JlY29yZCB7XG4gIHNldFJlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLnNldCgnc3RhdHVzJywgUkVBRFkpLnNldCgnbWVzc2FnZScsICcnKTtcbiAgfVxuXG4gIHNldFJ1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KCdzdGF0dXMnLCBSVU5OSU5HKS5zZXQoJ21lc3NhZ2UnLCAnJyk7XG4gIH1cblxuICBzZXRXb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KCdzdGF0dXMnLCBXT04pLnNldCgnbWVzc2FnZScsICcnKTtcbiAgfVxuXG4gIHNldExvc3QobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldCgnc3RhdHVzJywgTE9TVCkuc2V0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gIH1cblxuICBnZXQgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFJFQURZO1xuICB9XG5cbiAgZ2V0IGlzUnVubmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFJVTk5JTkc7XG4gIH1cblxuICBnZXQgaXNXb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBXT047XG4gIH1cblxuICBnZXQgaXNMb3N0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gTE9TVDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVTdGF0dXM7XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVscy9nYW1lU3RhdHVzLmpzeFxuICoqLyIsImNvbnN0IHtSZWNvcmQsIExpc3R9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbmNvbnN0IFZlY3RvciA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG5cbi8vIEJvZHkgcGFydHMgYWRkZWQgZm9yIGVhY2ggZm9vZCBpdGVtXG5jb25zdCBHUk9XVEhfUkFURSA9IDU7IC8vIHBhcnRzIHBlciBnb2FsXG5cbmNvbnN0IExpbmVSZWNvcmQgPSBSZWNvcmQoe1xuICBmcm9udDogdW5kZWZpbmVkLFxuICBiYWNrOiB1bmRlZmluZWQsXG59KTtcblxuY2xhc3MgTGluZSBleHRlbmRzIExpbmVSZWNvcmQge1xuICBzdGF0aWMgZnJvbVBvaW50KHt4LCB5fSkge1xuICAgIHJldHVybiBuZXcgTGluZSh7XG4gICAgICBmcm9udDogbmV3IFZlY3Rvcih7eCwgeX0pLFxuICAgICAgYmFjazogbmV3IFZlY3Rvcih7eCwgeX0pLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHRvdGFsU2l6ZSgpIHtcbiAgICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgbGluZXMgYXJlIGFsd2F5cyBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHNvIG9uZVxuICAgIC8vIG9mIHRoZXNlIGRpZmZlcmVuY2VzIHdpbGwgYmUgemVyb1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmZyb250LnggLSB0aGlzLmJhY2sueCkgKyBNYXRoLmFicyh0aGlzLmZyb250LnkgLSB0aGlzLmJhY2sueSkgKyAxO1xuICB9XG5cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9udC5zdWIodGhpcy5iYWNrKS5ub3JtYWxpemUoKTtcbiAgfVxuXG4gIGNvbnRhaW5zKHt4LCB5fSkge1xuICAgIGNvbnN0IHt4OiBmX3gsIHk6IGZfeX0gPSB0aGlzLmZyb250O1xuICAgIGNvbnN0IHt4OiBiX3gsIHk6IGJfeX0gPSB0aGlzLmJhY2s7XG5cbiAgICAvLyBHaXZlbiB2ZXJ0ZXggbXVzdCBiZSBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseSB3aXRoaW4gdGhlIGxpbmVcbiAgICByZXR1cm4gKFxuICAgICAgZl94ID09PSB4ICYmIGJfeCA9PT0geCAmJlxuICAgICAgeSA+PSBNYXRoLm1pbihmX3ksIGJfeSkgJiYgeSA8PSBNYXRoLm1heChmX3ksIGJfeSlcbiAgICApIHx8IChcbiAgICAgIGZfeSA9PT0geSAmJiBiX3kgPT09IHkgJiZcbiAgICAgIHggPj0gTWF0aC5taW4oZl94LCBiX3gpICYmIHggPD0gTWF0aC5tYXgoZl94LCBiX3gpXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBTbmFrZVJlY29yZCA9IFJlY29yZCh7XG4gIGJvZHk6IExpc3Qub2YoKSxcbiAgZGlyZWN0aW9uOiB1bmRlZmluZWQsXG4gIHBlbmRpbmdHcm93dGg6IDAsXG59KTtcblxuY2xhc3MgU25ha2UgZXh0ZW5kcyBTbmFrZVJlY29yZCB7XG4gIHN0YXRpYyBmcm9tU3RhcnRQb3NpdGlvbih7eCwgeX0pIHtcbiAgICByZXR1cm4gbmV3IFNuYWtlKHtcbiAgICAgIC8vIEZpcnN0IGVsZW1lbnQgaXMgdGhlIGhlYWRcbiAgICAgIGJvZHk6IExpc3Qub2YoTGluZS5mcm9tUG9pbnQoe3gsIHl9KSksXG4gICAgICAvLyBDYW4gYmUgdXNlZCB0byBzZXQgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgc25ha2VcbiAgICAgIHBlbmRpbmdHcm93dGg6IDAsXG4gICAgfSk7XG4gIH1cblxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmJvZHkucmVkdWNlKCh0LCBMKSA9PiB0ICsgTC50b3RhbFNpemUsIDApO1xuICB9XG5cbiAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGlmICghdGhpcy5jYW5UcmF2ZWxJbkRpcmVjdGlvbihkaXJlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24pO1xuICB9XG5cbiAgY2FuVHJhdmVsSW5EaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgLy8gT25seSBhbGxvdyB0cmF2ZWwgaW4gYSBnaXZlbiBkaXJlY3Rpb25cbiAgICAvLyBpZiBpdCB3b3VsZCBub3QgZGlyZWN0bHkgY29sbGlkZSB3aXRoIHRoZVxuICAgIC8vIHNlZ21lbnQganVzdCBhZnRlciB0aGUgaGVhZFxuICAgIC8vIEluIGdlbmVyYWwsIGNvbGxpZGluZyB3aXRoIGFueSBvdGhlciBwYXJ0IGlzIGFsbG93ZWRcbiAgICAvLyBUaGlzIGFsc28gYWxsb3dzIHRoZSB1c2VyIHRvIGNoYW5nZSB0aGVpciBtaW5kXG4gICAgLy8gRXhhbXBsZTogaWYgaGVhZGluZyBkb3dud2FyZHMgYWZ0ZXIgZ29pbmcgbGVmdCxcbiAgICAvLyB0aGUgdXNlciBjb3VsZCBoaXQgcmlnaHQgYW5kIHRoZW4gbGVmdCBpbW1lZGlhdGVseVxuICAgIC8vIFRoYXQncyBva2F5IHdpdGggdGhpcyBtZXRob2QsIHNpbmNlIGl0IGRvZXNuJ3QgdXNlXG4gICAgLy8gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBidXQgaW5zdGVhZCB1c2VzIGEgcG9zc2libGVcbiAgICAvLyBjb2xsaXNpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBkaXJlY3Rpb24gaXMgb2theVxuICAgIGlmICh0aGlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGZyb250TGluZSA9IHRoaXMuYm9keS5maXJzdCgpO1xuXG4gICAgbGV0IGRlbHRhO1xuICAgIGlmIChmcm9udExpbmUudG90YWxTaXplID09PSAxKSB7XG4gICAgICAvLyBpZiB0aGUgZnJvbnQgbGluZSBpcyBvbmx5IHNpemUgMSwgdXNlIHRoZSBzZWNvbmQgbGluZSBmcm9udCBhcyB3ZWxsXG4gICAgICBkZWx0YSA9IHRoaXMuYm9keS5nZXQoMSkuZnJvbnQuc3ViKGZyb250TGluZS5mcm9udCkubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGVsdGEgPSBmcm9udExpbmUuZGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiAhZGVsdGEuZXF1YWxzKGRpcmVjdGlvbik7XG4gIH1cblxuICBjb250YWlucyh2ZWMpIHtcbiAgICB2ZWMgPSBuZXcgVmVjdG9yKHZlYyk7XG4gICAgcmV0dXJuIHRoaXMuYm9keS5zb21lKChiKSA9PiBiLmNvbnRhaW5zKHZlYykpO1xuICB9XG5cbiAgaXNXaXRoaW5TZWxmKCkge1xuICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWQoKTtcbiAgICByZXR1cm4gdGhpcy5ib2R5LnNsaWNlKDEpLnNvbWUoKGIpID0+IGIuY29udGFpbnMoaGVhZCkpO1xuICB9XG5cbiAgaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5LmZpcnN0KCkuZnJvbnQ7XG4gIH1cblxuICB0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLmJvZHkubGFzdCgpLmJhY2s7XG4gIH1cblxuICBncm93KCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZSgncGVuZGluZ0dyb3d0aCcsIChnKSA9PiBnICsgR1JPV1RIX1JBVEUpO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgbGV0IGJvZHkgPSB0aGlzLmJvZHk7XG5cbiAgICAvLyBhcHBlbmQgb25lIHRvIHRoZSBmcm9udFxuICAgIGNvbnN0IGZyb250TGluZSA9IGJvZHkuZmlyc3QoKTtcbiAgICBpZiAoZnJvbnRMaW5lLnRvdGFsU2l6ZSA9PT0gMSB8fCBmcm9udExpbmUuZGlyZWN0aW9uLmVxdWFscyh0aGlzLmRpcmVjdGlvbikpIHtcbiAgICAgIGJvZHkgPSBib2R5LnNldCgwLCBmcm9udExpbmUudXBkYXRlKCdmcm9udCcsXG4gICAgICAgIChmcm9udCkgPT4gZnJvbnQuYWRkKHRoaXMuZGlyZWN0aW9uKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJvZHkgPSBib2R5LnVuc2hpZnQoTGluZS5mcm9tUG9pbnQoZnJvbnRMaW5lLmZyb250LmFkZCh0aGlzLmRpcmVjdGlvbikpKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYWNrTGluZSA9IGJvZHkubGFzdCgpO1xuXG4gICAgbGV0IHBlbmRpbmdHcm93dGggPSB0aGlzLnBlbmRpbmdHcm93dGg7XG4gICAgaWYgKHBlbmRpbmdHcm93dGgpIHtcbiAgICAgIC8vIGp1c3QgZG9uJ3QgdGFrZSBvbmUgb2ZmIGZyb20gdGhlIGJhY2tcbiAgICAgIHBlbmRpbmdHcm93dGgtLTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIG9uZSBmcm9tIHRoZSBiYWNrIG9yIHJlbW92ZSB0aGUgbGluZSBpZiBpdCB3aWxsIGJlIGVtcHR5XG4gICAgZWxzZSBpZiAoYmFja0xpbmUudG90YWxTaXplID09PSAxKSB7XG4gICAgICBib2R5ID0gYm9keS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBib2R5ID0gYm9keS5zZXQoYm9keS5zaXplIC0gMSwgYmFja0xpbmUudXBkYXRlKCdiYWNrJyxcbiAgICAgICAgKGJhY2spID0+IGJhY2suYWRkKGJhY2tMaW5lLmRpcmVjdGlvbikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoJ2JvZHknLCBib2R5KS5zZXQoJ3BlbmRpbmdHcm93dGgnLCBwZW5kaW5nR3Jvd3RoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNuYWtlO1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbHMvc25ha2UuanN4XG4gKiovIiwiZXhwb3J0IGNvbnN0IEFDVElPTl9SRVNFVCA9ICdyZXNldCc7XG5leHBvcnQgY29uc3QgQUNUSU9OX1VQREFURSA9ICd1cGRhdGUnO1xuZXhwb3J0IGNvbnN0IEFDVElPTl9ESVJFQ1RJT04gPSAnZGlyZWN0aW9uJztcbmV4cG9ydCBjb25zdCBBQ1RJT05fRU5BQkxFX0FJID0gJ2FpLWVuYWJsZWQnO1xuZXhwb3J0IGNvbnN0IEFDVElPTl9FTkFCTEVfREVCVUdfQUlfUEFUSCA9ICdhaS1wYXRoLWRlYnVnLWVuYWJsZWQnO1xuZXhwb3J0IGNvbnN0IEFDVElPTl9VUERBVEVfUExBTk5FRF9QQVRIID0gJ3VwZGF0ZS1wbGFubmVkLXBhdGgnO1xuZXhwb3J0IGNvbnN0IEFDVElPTl9TSElGVF9QTEFOTkVEX1BBVEggPSAnc2hpZnQtcGxhbm5lZC1wYXRoJztcbmV4cG9ydCBjb25zdCBBQ1RJT05fQ0xFQVJfUExBTk5FRF9QQVRIID0gJ2NsZWFyLXBsYW5uZWQtcGF0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEdhbWUoKSB7XG4gIHJldHVybiBjcmVhdGVBY3Rpb24oQUNUSU9OX1JFU0VUKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUdhbWUoZ29hbCA9IHt9KSB7XG4gIC8vIHRoZSBnb2FsIHBhcmFtZXRlciBtYW51YWxseSBvdmVyd3JpdGVzIHRoZSBnb2FsIGFuZCBpcyB0eXBpY2FsbHlcbiAgLy8gdXNlZCB0byB0ZWxsIHRoZSBBSSBwcm9jZXNzIHdoYXQgdGhlIGdvYWwgc2hvdWxkIGJlIHdoZW5ldmVyIGFuIHVwZGF0ZVxuICAvLyBpcyBzZW50LiBUaGlzIGlzIGEgZm9yY2VkIGNoYW5nZSB0aGF0IGlzIGFwcGxpZWQgQUZURVIgdGhlIGFjdHVhbCB1cGRhdGVcbiAgLy8gaXRzZWxmXG4gIC8vIE5PVEU6IHNpbmNlIG51bGwgaXMgYSB2YWxpZCB2YWx1ZSBmb3IgYSBnb2FsLCBvbmx5IGFuIGVtcHR5IG9iamVjdFxuICAvLyBwcmV2ZW50cyB0aGUgZ29hbCBmcm9tIGJlaW5nIHNldFxuICByZXR1cm4gY3JlYXRlQWN0aW9uKEFDVElPTl9VUERBVEUsIHtnb2FsfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbmFrZURpcmVjdGlvbihkaXJlY3Rpb25OYW1lKSB7XG4gIHJldHVybiBjcmVhdGVBY3Rpb24oQUNUSU9OX0RJUkVDVElPTiwge25hbWU6IGRpcmVjdGlvbk5hbWV9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUFJKGVuYWJsZWQgPSB0cnVlKSB7XG4gIHJldHVybiBjcmVhdGVBY3Rpb24oQUNUSU9OX0VOQUJMRV9BSSwge2VuYWJsZWR9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZURlYnVnQUlQYXRoKGVuYWJsZWQgPSB0cnVlKSB7XG4gIHJldHVybiBjcmVhdGVBY3Rpb24oQUNUSU9OX0VOQUJMRV9ERUJVR19BSV9QQVRILCB7ZW5hYmxlZH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUGxhbm5lZFBhdGgocGF0aCwgdGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVBY3Rpb24oQUNUSU9OX1VQREFURV9QTEFOTkVEX1BBVEgsIHtwYXRoLCB0YXJnZXR9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaWZ0UGxhbm5lZFBhdGgoKSB7XG4gIHJldHVybiBjcmVhdGVBY3Rpb24oQUNUSU9OX1NISUZUX1BMQU5ORURfUEFUSCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclBsYW5uZWRQYXRoKCkge1xuICByZXR1cm4gY3JlYXRlQWN0aW9uKEFDVElPTl9DTEVBUl9QTEFOTkVEX1BBVEgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcGF5bG9hZCA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICAuLi5wYXlsb2FkLFxuICB9O1xufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hY3Rpb25zL2FjdGlvbnMuanN4XG4gKiovIiwiY29uc3Qge2NyZWF0ZVJlZHVjZXJ9ID0gcmVxdWlyZSgnLi9yZWR1Y2VyJyk7XG5cbmNvbnN0IEFJID0gcmVxdWlyZSgnLi4vbW9kZWxzL2FpJyk7XG5jb25zdCBQYXRoUGxhbiA9IHJlcXVpcmUoJy4uL21vZGVscy9wYXRoUGxhbicpO1xuXG5jb25zdCB7XG4gIEFDVElPTl9SRVNFVCxcbiAgQUNUSU9OX1VQREFURV9QTEFOTkVEX1BBVEgsXG4gIEFDVElPTl9TSElGVF9QTEFOTkVEX1BBVEgsXG4gIEFDVElPTl9DTEVBUl9QTEFOTkVEX1BBVEgsXG59ID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9hY3Rpb25zJyk7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IG5ldyBBSSh7cGxhbjogbmV3IFBhdGhQbGFuKCl9KTtcbmNvbnN0IGdhbWUgPSBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwge1xuICBbQUNUSU9OX1JFU0VUXSgpIHtcbiAgICByZXR1cm4gaW5pdGlhbFN0YXRlO1xuICB9LFxuICBbQUNUSU9OX0NMRUFSX1BMQU5ORURfUEFUSF0oc3RhdGUpIHtcbiAgICByZXR1cm4gaW5pdGlhbFN0YXRlO1xuICB9LFxuICBbQUNUSU9OX1VQREFURV9QTEFOTkVEX1BBVEhdKHN0YXRlLCB7cGF0aCwgdGFyZ2V0fSkge1xuICAgIHJldHVybiBzdGF0ZS5zZXRQbGFuKFBhdGhQbGFuLmZyb21KU09OKHBhdGgpKS5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgfSxcbiAgW0FDVElPTl9TSElGVF9QTEFOTkVEX1BBVEhdKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSgncGxhbicsIChwbGFuKSA9PiBwbGFuLnNoaWZ0KCkpO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2FtZTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVkdWNlcnMvYWkuanN4XG4gKiovIiwiY29uc3Qge1JlY29yZH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcblxuY29uc3QgQUlSZWNvcmQgPSBSZWNvcmQoe1xuICBwbGFuOiB1bmRlZmluZWQsXG4gIC8vIHRoZSB0YXJnZXQgdGhpcyBwbGFuIHdhcyBtYWRlIGZvclxuICB0YXJnZXQ6IHt9LFxufSk7XG5cbmNsYXNzIEFJIGV4dGVuZHMgQUlSZWNvcmQge1xuICBzZXRQbGFuKHBsYW4pIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJ3BsYW4nLCBwbGFuKTtcbiAgfVxuXG4gIHNldFRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJ3RhcmdldCcsIHRhcmdldCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBSTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWxzL2FpLmpzeFxuICoqLyIsImNvbnN0IHtSZWNvcmQsIExpc3R9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbmNvbnN0IFR1cm4gPSBSZWNvcmQoe1xuICAvLyB4IGFuZCB5IHRvIG1ha2UgdGhpcyB0dXJuIGF0XG4gIHg6IHVuZGVmaW5lZCxcbiAgeTogdW5kZWZpbmVkLFxuICAvLyBkaXJlY3Rpb24gdG8gdHVybiBpblxuICBkaXJlY3Rpb246IHVuZGVmaW5lZCxcbn0pO1xuXG5jb25zdCBQYXRoUGxhblJlY29yZCA9IFJlY29yZCh7XG4gIC8vIExpc3Qgb2YgVHVybnNcbiAgbmV4dERpcmVjdGlvbnM6IExpc3Qub2YoKSxcbn0pO1xuXG5jbGFzcyBQYXRoUGxhbiBleHRlbmRzIFBhdGhQbGFuUmVjb3JkIHtcbiAgc3RhdGljIFR1cm4gPSBUdXJuO1xuXG4gIHN0YXRpYyBmcm9tSlNPTihwYXRoSlNPTikge1xuICAgIGxldCBwbGFuID0gbmV3IFBhdGhQbGFuKCk7XG4gICAgZm9yIChsZXQge3gsIHksIGRpcmVjdGlvbn0gb2YgcGF0aEpTT04ubmV4dERpcmVjdGlvbnMpIHtcbiAgICAgIHBsYW4gPSBwbGFuLmFkZFR1cm4oe3gsIHl9LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcGxhbjtcbiAgfVxuXG4gIGhhc1BsYW4oKSB7XG4gICAgcmV0dXJuICF0aGlzLm5leHREaXJlY3Rpb25zLmlzRW1wdHkoKTtcbiAgfVxuXG4gIC8vIEFkZHMgYSB0dXJuIG9uIHRoZSBwYXRoIHdoZXJlIHRoZSBzbmFrZSBzaG91bGQgdHVybiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgYWRkVHVybih7eCwgeX0sIGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZSgnbmV4dERpcmVjdGlvbnMnLCAobmV4dCkgPT4gbmV4dC5wdXNoKFxuICAgICAgbmV3IFBhdGhQbGFuLlR1cm4oe3gsIHksIGRpcmVjdGlvbn0pXG4gICAgKSk7XG4gIH1cblxuICAvLyBTYW1lIGFzIGFkZFR1cm4gYnV0IGFwcGVuZHMgdG8gdGhlIGZyb250IG9mIHRoZSBwYXRoXG4gIHByZXBlbmRUdXJuKHt4LCB5fSwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlKCduZXh0RGlyZWN0aW9ucycsIChuZXh0KSA9PiBuZXh0LnVuc2hpZnQoXG4gICAgICBuZXcgUGF0aFBsYW4uVHVybih7eCwgeSwgZGlyZWN0aW9ufSlcbiAgICApKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG5leHQgZGlyZWN0aW9uIHRvIHR1cm4gYW5kIHRoZSBwb3NpdGlvbiB0byB0dXJuIGF0XG4gIC8vIGkuZS4gVGhlIGZpcnN0IHR1cm4gaW4gdGhlIHBsYW5uZWQgcGF0aFxuICBmaXJzdFR1cm4oKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dERpcmVjdGlvbnMuZmlyc3QoKTtcbiAgfVxuXG4gIC8vIFJlbW92ZXMgdGhlIGZpcnN0IHR1cm4gaW4gdGhlIHBsYW5uZWQgcGF0aCBhbmRcbiAgLy8gcmV0dXJucyB0aGUgbmV3IHBsYW5uZWQgcGF0aFxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoJ25leHREaXJlY3Rpb25zJywgKG5leHQpID0+IG5leHQuc2hpZnQoKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXRoUGxhbjtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWxzL3BhdGhQbGFuLmpzeFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xuSXRlcmF0b3JzLk5vZGVMaXN0ID0gSXRlcmF0b3JzLkhUTUxDb2xsZWN0aW9uID0gSXRlcmF0b3JzLkFycmF5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLyQuYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItc3RlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vJC5saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90byAgICAgICA9IHJlcXVpcmUoJy4vJCcpLmdldFByb3RvXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCBtZXRob2RzLCBrZXk7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJG5hdGl2ZSl7XG4gICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8oJGRlZmF1bHQuY2FsbChuZXcgQmFzZSkpO1xuICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAvLyBGRiBmaXhcbiAgICBpZighTElCUkFSWSAmJiBoYXMocHJvdG8sIEZGX0lURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICAgIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJylcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLmhpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi8kLnRvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbVEFHXSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY2xhc3NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiY29uc3Qge2NyZWF0ZVJlZHVjZXJ9ID0gcmVxdWlyZSgnLi9yZWR1Y2VyJyk7XG5cbmNvbnN0IFNldHRpbmdzID0gcmVxdWlyZSgnLi4vbW9kZWxzL3NldHRpbmdzJyk7XG5cbmNvbnN0IHtBQ1RJT05fRU5BQkxFX0FJLCBBQ1RJT05fRU5BQkxFX0RFQlVHX0FJX1BBVEh9ID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9hY3Rpb25zJyk7XG5cbmNvbnN0IHNldHRpbmdzID0gY3JlYXRlUmVkdWNlcihuZXcgU2V0dGluZ3MoKSwge1xuICBbQUNUSU9OX0VOQUJMRV9BSV0oc3RhdGUsIHtlbmFibGVkfSkge1xuICAgIHJldHVybiBzdGF0ZS5zZXRBSShlbmFibGVkKTtcbiAgfSxcbiAgW0FDVElPTl9FTkFCTEVfREVCVUdfQUlfUEFUSF0oc3RhdGUsIHtlbmFibGVkfSkge1xuICAgIHJldHVybiBzdGF0ZS5zZXREZWJ1Z0FJUGF0aChlbmFibGVkKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHRpbmdzO1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZWR1Y2Vycy9zZXR0aW5ncy5qc3hcbiAqKi8iLCJjb25zdCB7UmVjb3JkfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG5jb25zdCBTZXR0aW5nc1JlY29yZCA9IFJlY29yZCh7XG4gIHVzZUFJOiBmYWxzZSxcbiAgZGVidWdBSVBhdGg6IGZhbHNlLFxufSk7XG5cbmNsYXNzIFNldHRpbmdzIGV4dGVuZHMgU2V0dGluZ3NSZWNvcmQge1xuICBzZXRBSShlbmFibGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KCd1c2VBSScsIGVuYWJsZWQpO1xuICB9XG5cbiAgc2V0RGVidWdBSVBhdGgoZW5hYmxlZCkge1xuICAgIHJldHVybiB0aGlzLnNldCgnZGVidWdBSVBhdGgnLCBlbmFibGVkKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdzO1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbHMvc2V0dGluZ3MuanN4XG4gKiovIiwiY29uc3QgRGlyZWN0aW9uID0gcmVxdWlyZSgnLi4vbW9kZWxzL2RpcmVjdGlvbicpO1xuY29uc3QgUGF0aFBsYW4gPSByZXF1aXJlKCcuLi9tb2RlbHMvcGF0aFBsYW4nKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUGF0aFBsYW4gdG8gZ2V0IGZyb20gdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBjdXJyZW50IG9uZVxuICogdG8gdGhlIG5leHQgZ29hbFxuICogUmV0dXJucyBhbiBlbXB0eSBwYXRoIGlmIHRoZXJlIGlzIG5vIHBhdGggdG8gdGhlIGdvYWwgKGFib3V0IHRvIGRpZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5QYXRoQVN0YXIoZ2FtZSkge1xuICAvLyBOZWVkIHRvIHN0YXJ0IG9uIHRoZSBwb3NpdGlvbiAqYWZ0ZXIqIHRoZSBjdXJyZW50IG9uZSBiZWNhdXNlXG4gIC8vIGF0IHRoaXMgcG9pbnQgdGhlIHNuYWtlIGlzIGFscmVhZHkgbW92aW5nIHRoZXJlLCB0aGVyZSBpcyBub3RoaW5nXG4gIC8vIHRvIGJlIGdhaW5lZCBieSBzZWFyY2hpbmcgb3RoZXIgZGlyZWN0aW9ucyBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gIGdhbWUgPSBnYW1lLnVwZGF0ZSgnc25ha2UnLCAoc25ha2UpID0+IHNuYWtlLnNoaWZ0KCkpO1xuXG4gIGNvbnN0IGZpbmlzaCA9IGdhbWUuZ29hbDtcblxuICBjb25zdCBvcGVuID0gW2NyZWF0ZUFTdGFyTm9kZShnYW1lLCBudWxsLCBudWxsLCBmaW5pc2gpXTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcblxuICB3aGlsZSAob3Blbi5sZW5ndGgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gb3Blbi5zcGxpY2UoMCwgMSlbMF07XG4gICAgdmlzaXRlZC5hZGQoY3VycmVudC5pZCk7XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnJlbnQuZ2FtZS5zbmFrZS5oZWFkKCk7XG5cbiAgICBpZiAocG9zaXRpb24uZXF1YWxzKGZpbmlzaCkpIHtcbiAgICAgIHJldHVybiBzb2x1dGlvblBhdGhGcm9tQVN0YXIoY3VycmVudCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQge2FkamFjZW50LCBkaXJlY3Rpb259IG9mIGF2YWlsYWJsZUFkamFjZW50cyhjdXJyZW50LmdhbWUpKSB7XG4gICAgICBpZiAodmlzaXRlZC5oYXMoYWRqYWNlbnQuaGFzaCgpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hhbmdlIGRpcmVjdGlvbnMgQU5EIHNoaWZ0IHNvIHRoYXQgdGhlIHNuYWtlIG1vdmVzIGluIHRoaXNcbiAgICAgIC8vIGRpcmVjdGlvblxuICAgICAgY29uc3QgYWRqR2FtZSA9IGN1cnJlbnQuZ2FtZS51cGRhdGUoJ3NuYWtlJyxcbiAgICAgICAgKHNuYWtlKSA9PiBzbmFrZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKS5zaGlmdCgpKTtcbiAgICAgIGNvbnN0IGFkak5vZGUgPSBjcmVhdGVBU3Rhck5vZGUoYWRqR2FtZSwgY3VycmVudCwgZGlyZWN0aW9uLCBmaW5pc2gpO1xuXG4gICAgICAvLyBTa2lwIGEgcG90ZW50aWFsIG5vZGUgd2l0aCBhIGxvd2VyIGNvc3RcbiAgICAgIHZhciBzYW1lT3BlbiA9IG9wZW4uZmluZEluZGV4KChuKSA9PiBuLmlkID09PSBhZGpOb2RlLmlkKTtcbiAgICAgIGlmIChzYW1lT3BlbiA+IC0xKSB7XG4gICAgICAgIGlmIChvcGVuW3NhbWVPcGVuXS5jb3N0IDwgYWRqTm9kZS5jb3N0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHNhbWVPcGVuIHNpbmNlIGl0cyBjb3N0IGlzIGhpZ2hlciB0aGFuIHRoaXMgcGF0aFxuICAgICAgICAgIG9wZW4uc3BsaWNlKHNhbWVPcGVuLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnNlcnRBU3Rhck5vZGVCeUNvc3Qob3BlbiwgYWRqTm9kZSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBleGhhdXN0ZWQgc2VhcmNoXG4gIGNvbnNvbGUuZGVidWcoJ2V4aGF1c3RlZCBzZWFyY2ggZm9yIGdvYWwsIGdpdmluZyB1cCcpO1xuICByZXR1cm4gbmV3IFBhdGhQbGFuKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFTdGFyTm9kZShnYW1lLCBwYXJlbnQsIGRpcmVjdGlvbiwgZmluaXNoKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gZ2FtZS5zbmFrZS5oZWFkKCk7XG5cbiAgbGV0IGV4dHJhID0gMDtcblxuICBsZXQgdG90YWwgPSAwO1xuICBpZiAocGFyZW50KSB7XG4gICAgY29uc3QgcGFyZW50UG9zaXRpb24gPSBwYXJlbnQuZ2FtZS5zbmFrZS5oZWFkKCk7XG4gICAgdG90YWwgPSBwYXJlbnQudG90YWxDb3N0ICsgcGFyZW50UG9zaXRpb24uc3F1YXJlZERpc3RhbmNlVG8ocG9zaXRpb24pO1xuXG4gICAgLy8gQW4gYWRkaXRpb25hbCBleHRyYSBoZXVyaXN0aWMgdG8gZmF2b3Igc3RyYWlnaHRlciBwYXRoc1xuICAgIGlmICghZ2FtZS5zbmFrZS5kaXJlY3Rpb24uZXF1YWxzKHBhcmVudC5nYW1lLnNuYWtlLmRpcmVjdGlvbikpIHtcbiAgICAgIC8vIFRoaXMgd2VpZ2h0IHdpbGwgYmUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHN0ZXBzIHRoZSBzbmFrZVxuICAgICAgLy8gd2lsbCBhdHRlbXB0IHRvIHN0YXkgaW4gYSBzdHJhaWdodCBwYXRoIGZvclxuICAgICAgLy8gSXQgaXMgdXN1YWxseSBzYWZlIHRvIHNldCB0aGlzIGF0IHRoZSB3aWR0aCBvciBoZWlnaHQgb2YgdGhlXG4gICAgICAvLyBzY3JlZW4uIFNldHRpbmcgaXQgdG9vIGhpZ2ggKGhpZ2hlciB0aGFuIG90aGVyIHdlaWdodHMpIHdpbGxcbiAgICAgIC8vIHJlc3VsdCBpbiB0aG9zZSBjb25zaWRlcmF0aW9ucyBiZWluZyBwbGFjZWQgYXQgYSBsb3dlciBwcmlvcml0eVxuICAgICAgZXh0cmEgKz0gMzA7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXN0aW1hdGUgPSBwb3NpdGlvbi5zcXVhcmVkRGlzdGFuY2VUbyhmaW5pc2gpO1xuXG4gIC8vIFZlcnkgYmFzaWMgaGV1cmlzdGljIGZvciBkZXRlcm1pbmluZyBpZiB0aGlzIHBhdGggd2lsbCBsZWFkIHRvIGFcbiAgLy8gZGVhZCBlbmQuIEEgbW9yZSBhZHZhbmNlZCBtZXRob2Qgd291bGQgYmUgdG8gbG9vayBhaGVhZCBmcm9tIHRoZVxuICAvLyBmaW5pc2ggYW5kIHNlZSBpZiB0aGVyZSBhcmUgYWx0ZXJuYXRlIHBhdGhzIGFmdGVyd2FyZHNcbiAgLy8gVGhlIGFkdmFuY2VkIG1ldGhvZCBzaG91bGQgbG9va2FoZWFkIGF0IGxlYXN0IHRoZSBudW1iZXIgb2Ygc3BhY2VzXG4gIC8vIHRoZSBzbmFrZSB3aWxsIGdyb3cgdG8gc2VlIGlmIGl0IGhpdHMgc29tZXRoaW5nXG4gIGlmIChwb3NpdGlvbi5lcXVhbHMoZ2FtZS5nb2FsKSkge1xuICAgIGNvbnN0IGFmdGVyR29hbCA9IHBvc2l0aW9uLmFkZChnYW1lLnNuYWtlLmRpcmVjdGlvbik7XG4gICAgaWYgKCFnYW1lLmlzVHJhdmVyc2FibGUoYWZ0ZXJHb2FsKSkge1xuICAgICAgLy8gdGhpcyBleHRyYSBjb3N0IHdpbGwgaW5mbHVlbmNlIHRoZSBzbmFrZSB0byBhdm9pZCB0aGVzZSBjb25kaXRpb25zXG4gICAgICAvLyBidXQgYWxzbyBzdGlsbCBub3QgZXhoYXVzdCB0aGUgc2VhcmNoIGlmIHRoaXMgaXMgdGhlIG9ubHkgb3B0aW9uXG4gICAgICAvLyBOZWVkcyB0byBiZSBhdCBsZWFzdCB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBmcm9tIGNvcm5lciB0byBjb3JuZXJcbiAgICAgIGV4dHJhICs9IDUwMDA7XG4gICAgfVxuXG4gICAgY29uc3QgdHdvQWZ0ZXJHb2FsID0gYWZ0ZXJHb2FsLmFkZChnYW1lLnNuYWtlLmRpcmVjdGlvbik7XG4gICAgaWYgKCFnYW1lLmlzVHJhdmVyc2FibGUoYWZ0ZXJHb2FsKSkge1xuICAgICAgZXh0cmEgKz0gNDAwMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBwb3NpdGlvbi5oYXNoKCksXG4gICAgZ2FtZTogZ2FtZSxcbiAgICAvLyB0aGUgZGlyZWN0aW9uIGxlYWRpbmcgdG8gdGhpcyBnYW1lXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY29zdDogdG90YWwgKyBlc3RpbWF0ZSArIGV4dHJhLFxuICAgIC8vIHRvdGFsIGRpc3RhbmNlIHVwIHRvIHRoaXMgcG9zaXRpb24gZnJvbSB0aGUgc3RhcnRcbiAgICB0b3RhbENvc3Q6IHRvdGFsLFxuICAgIGVzdGltYXRlZENvc3Q6IGVzdGltYXRlLFxuICB9O1xufVxuXG4vKiBTaW1wbGlmaWVzIHRoZSBwYXRoIHN0YXJ0aW5nIGZyb20gdGhlIGZpbmlzaFxuICogdG8gb25seSBjb250YWluIHRoZSB0dXJucyBuZWNlc3NhcnkgdG8gZ28gdGhyb3VnaFxuICogdGhhdCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHNvbHV0aW9uUGF0aEZyb21BU3RhcihmaW5pc2hOb2RlKSB7XG4gIC8vVE9ETzogU29tZSBidWcgaGVyZSBjYXVzZXMgZmluaXNoTm9kZS5kaXJlY3Rpb24gdG8gYmUgbnVsbCBzb21ldGltZXNcbiAgbGV0IHBhdGggPSBuZXcgUGF0aFBsYW4oKTtcblxuICAvLyBOb3RlIHRoYXQgdGhlIGRpcmVjdGlvbiBwcm9wZXJ0eSBpcyB0aGUgZGlyZWN0aW9uIGxlYWRpbmdcbiAgLy8gKippbnRvKiogdGhlIG5vZGUgXG5cbiAgbGV0IGN1cnJlbnREaXJlY3Rpb24gPSBmaW5pc2hOb2RlLmRpcmVjdGlvbjtcbiAgbGV0IGN1cnJlbnQgPSBmaW5pc2hOb2RlO1xuICB3aGlsZSAoY3VycmVudC5kaXJlY3Rpb24pIHtcbiAgICAvLyBMb29raW5nIGZvciB3aGVyZSB0aGlzIGRpcmVjdGlvbiBzdGFydGVkXG4gICAgLy8gV2hlcmUgZXZlciB0aGUgZGlyZWN0aW9uIGNoYW5nZXMsIHRoYXQncyB3aGVyZSB0aGlzIGRpcmVjdGlvblxuICAgIC8vIHN0YXJ0ZWRcbiAgICBpZiAoIWN1cnJlbnQuZGlyZWN0aW9uLmVxdWFscyhjdXJyZW50RGlyZWN0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBjdXJyZW50LmdhbWUuc25ha2UuaGVhZCgpO1xuICAgICAgcGF0aCA9IHBhdGgucHJlcGVuZFR1cm4ocG9zaXRpb24sIERpcmVjdGlvbi50b05hbWUoY3VycmVudERpcmVjdGlvbikpO1xuXG4gICAgICBjdXJyZW50RGlyZWN0aW9uID0gY3VycmVudC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICB9XG5cbiAgLy8gb25jZSB3ZSByZWFjaCB0aGUgc3RhcnQgbm9kZSwgd2UnbGwgaGF2ZSBhIGN1cnJlbnQgcG9zaXRpb25cbiAgLy8gYnV0IG5vIGN1cnJlbnQgZGlyZWN0aW9uIC0gdGhpcyBuZWVkcyB0byBiZSBwcmVwZW5kZWQgdG9vXG4gIGNvbnN0IHBvc2l0aW9uID0gY3VycmVudC5nYW1lLnNuYWtlLmhlYWQoKTtcbiAgcGF0aCA9IHBhdGgucHJlcGVuZFR1cm4ocG9zaXRpb24sIERpcmVjdGlvbi50b05hbWUoY3VycmVudERpcmVjdGlvbikpO1xuXG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBU3Rhck5vZGVCeUNvc3Qob3Blbiwgbm9kZSkge1xuICAvLyBhdHRlbXB0IHRvIGluc2VydCB0aGUgbm9kZSBiZWZvcmUgYSBub2RlIHdpdGggYSBsYXJnZXIgY29zdFxuICBmb3IgKGxldCBbaSwgb3Blbk5vZGVdIG9mIG9wZW4uZW50cmllcygpKSB7XG4gICAgLy8gU2luY2UgdGhpcyBpcyA+PSBhbmQgbm90ID4sIG5vZGVzIHdpdGggdGhlIHNhbWUgY29zdCBidXRcbiAgICAvLyBjaGVja2VkIGVhcmxpZXIgd2lsbCBiZSBzZWFyY2hlZCBhZnRlcndhcmRzXG4gICAgaWYgKG9wZW5Ob2RlLmNvc3QgPj0gbm9kZS5jb3N0KSB7XG4gICAgICBvcGVuLnNwbGljZShpLCAwLCBub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBuZXZlciBmb3VuZCBhbnkgbm9kZSB3aXRoIGEgc21hbGxlciBjb3N0XG4gIG9wZW4ucHVzaChub2RlKTtcbn1cblxuLyoqXG4gKiBZaWVsZHMgZWFjaCBhZGphY2VudCB0aGF0IGlzIG5vdCBhIHNuYWtlIHRpbGUgb3Igb3V0IG9mIGJvdW5kc1xuICovXG5mdW5jdGlvbiogYXZhaWxhYmxlQWRqYWNlbnRzKGdhbWUpIHtcbiAgY29uc3QgcG9zaXRpb24gPSBnYW1lLnNuYWtlLmhlYWQoKTtcbiAgY29uc3QgYmFja3dhcmRzID0gZ2FtZS5zbmFrZS5kaXJlY3Rpb24ubmVnYXRlKCk7XG5cbiAgZm9yIChsZXQgZGlyZWN0aW9uIG9mIERpcmVjdGlvbi5hbGwoKSkge1xuICAgIC8vIFNpbmNlIGl0IGlzIGltcG9zc2libGUgdG8gbW92ZSBiYWNrd2FyZHNcbiAgICBpZiAoZGlyZWN0aW9uLmVxdWFscyhiYWNrd2FyZHMpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGphY2VudCA9IHBvc2l0aW9uLmFkZChkaXJlY3Rpb24pO1xuXG4gICAgaWYgKCFnYW1lLmlzVHJhdmVyc2FibGUoYWRqYWNlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB5aWVsZCB7YWRqYWNlbnQsIGRpcmVjdGlvbn07XG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYWkvcGxhbm5lci5qc3hcbiAqKi8iLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPVxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXM7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogbW9kdWxlLmV4cG9ydHMsIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9Qcm9taXNlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIpW1wiZGVmYXVsdFwiXTtcblxuIShmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgX1N5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gX1N5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IF9PYmplY3QkY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGlmIChfT2JqZWN0JHNldFByb3RvdHlwZU9mKSB7XG4gICAgICBfT2JqZWN0JHNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBfT2JqZWN0JGNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8IG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbi8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbnR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdW5kZWZpbmVkKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuUHJvbWlzZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIExJQlJBUlkgICAgPSByZXF1aXJlKCcuLyQubGlicmFyeScpXG4gICwgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjbGFzc29mICAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsICRleHBvcnQgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgc3RyaWN0TmV3ICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBmb3JPZiAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc2V0UHJvdG8gICA9IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXRcbiAgLCBzYW1lICAgICAgID0gcmVxdWlyZSgnLi8kLnNhbWUtdmFsdWUnKVxuICAsIFNQRUNJRVMgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCBhc2FwICAgICAgID0gcmVxdWlyZSgnLi8kLm1pY3JvdGFzaycpXG4gICwgUFJPTUlTRSAgICA9ICdQcm9taXNlJ1xuICAsIHByb2Nlc3MgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIFAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBXcmFwcGVyO1xuXG52YXIgdGVzdFJlc29sdmUgPSBmdW5jdGlvbihzdWIpe1xuICB2YXIgdGVzdCA9IG5ldyBQKGZ1bmN0aW9uKCl7fSk7XG4gIGlmKHN1Yil0ZXN0LmNvbnN0cnVjdG9yID0gT2JqZWN0O1xuICByZXR1cm4gUC5yZXNvbHZlKHRlc3QpID09PSB0ZXN0O1xufTtcblxudmFyIFVTRV9OQVRJVkUgPSBmdW5jdGlvbigpe1xuICB2YXIgd29ya3MgPSBmYWxzZTtcbiAgZnVuY3Rpb24gUDIoeCl7XG4gICAgdmFyIHNlbGYgPSBuZXcgUCh4KTtcbiAgICBzZXRQcm90byhzZWxmLCBQMi5wcm90b3R5cGUpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRyeSB7XG4gICAgd29ya3MgPSBQICYmIFAucmVzb2x2ZSAmJiB0ZXN0UmVzb2x2ZSgpO1xuICAgIHNldFByb3RvKFAyLCBQKTtcbiAgICBQMi5wcm90b3R5cGUgPSAkLmNyZWF0ZShQLnByb3RvdHlwZSwge2NvbnN0cnVjdG9yOiB7dmFsdWU6IFAyfX0pO1xuICAgIC8vIGFjdHVhbCBGaXJlZm94IGhhcyBicm9rZW4gc3ViY2xhc3Mgc3VwcG9ydCwgdGVzdCB0aGF0XG4gICAgaWYoIShQMi5yZXNvbHZlKDUpLnRoZW4oZnVuY3Rpb24oKXt9KSBpbnN0YW5jZW9mIFAyKSl7XG4gICAgICB3b3JrcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhY3R1YWwgVjggYnVnLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDE2MlxuICAgIGlmKHdvcmtzICYmIHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpKXtcbiAgICAgIHZhciB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSBmYWxzZTtcbiAgICAgIFAucmVzb2x2ZSgkLnNldERlc2Moe30sICd0aGVuJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHRoZW5hYmxlVGhlbkdvdHRlbiA9IHRydWU7IH1cbiAgICAgIH0pKTtcbiAgICAgIHdvcmtzID0gdGhlbmFibGVUaGVuR290dGVuO1xuICAgIH1cbiAgfSBjYXRjaChlKXsgd29ya3MgPSBmYWxzZTsgfVxuICByZXR1cm4gd29ya3M7XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICBpZihMSUJSQVJZICYmIGEgPT09IFAgJiYgYiA9PT0gV3JhcHBlcilyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHNhbWUoYSwgYik7XG59O1xudmFyIGdldENvbnN0cnVjdG9yID0gZnVuY3Rpb24oQyl7XG4gIHZhciBTID0gYW5PYmplY3QoQylbU1BFQ0lFU107XG4gIHJldHVybiBTICE9IHVuZGVmaW5lZCA/IFMgOiBDO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpLFxuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KVxufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHJlY29yZCwgaXNSZWplY3Qpe1xuICBpZihyZWNvcmQubilyZXR1cm47XG4gIHJlY29yZC5uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcmVjb3JkLmM7XG4gIGFzYXAoZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSByZWNvcmQudlxuICAgICAgLCBvayAgICA9IHJlY29yZC5zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXJlY29yZC5oID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyID09PSB0cnVlID8gdmFsdWUgOiBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgY2hhaW4ubGVuZ3RoID0gMDtcbiAgICByZWNvcmQubiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0KXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwcm9taXNlID0gcmVjb3JkLnBcbiAgICAgICAgLCBoYW5kbGVyLCBjb25zb2xlO1xuICAgICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IHJlY29yZC5hID0gdW5kZWZpbmVkO1xuICAgIH0sIDEpO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdmFyIHJlY29yZCA9IHByb21pc2UuX2RcbiAgICAsIGNoYWluICA9IHJlY29yZC5hIHx8IHJlY29yZC5jXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgaWYocmVjb3JkLmgpcmV0dXJuIGZhbHNlO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpcztcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHJlY29yZC52ID0gdmFsdWU7XG4gIHJlY29yZC5zID0gMjtcbiAgcmVjb3JkLmEgPSByZWNvcmQuYy5zbGljZSgpO1xuICBub3RpZnkocmVjb3JkLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciByZWNvcmQgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihyZWNvcmQuZClyZXR1cm47XG4gIHJlY29yZC5kID0gdHJ1ZTtcbiAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihyZWNvcmQucCA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgICAgIHJlY29yZC5zID0gMTtcbiAgICAgIG5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtyOiByZWNvcmQsIGQ6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgdmFyIHJlY29yZCA9IHRoaXMuX2QgPSB7XG4gICAgICBwOiBzdHJpY3ROZXcodGhpcywgUCwgUFJPTUlTRSksICAgICAgICAgLy8gPC0gcHJvbWlzZVxuICAgICAgYzogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgICAgYTogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgICBzOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICAgIGQ6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBkb25lXG4gICAgICB2OiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgIGg6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBoYW5kbGVkIHJlamVjdGlvblxuICAgICAgbjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KCRyZWplY3QsIHJlY29yZCwgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbChyZWNvcmQsIGVycik7XG4gICAgfVxuICB9O1xuICByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJykoUC5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQKSlcbiAgICAgICAgLCBwcm9taXNlICA9IHJlYWN0aW9uLnByb21pc2VcbiAgICAgICAgLCByZWNvcmQgICA9IHRoaXMuX2Q7XG4gICAgICByZWFjdGlvbi5vayAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVjb3JkLmMucHVzaChyZWFjdGlvbik7XG4gICAgICBpZihyZWNvcmQuYSlyZWNvcmQuYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHJlY29yZC5zKW5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7UHJvbWlzZTogUH0pO1xucmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJykoUCwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuLyQuc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuLyQuY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8IHRlc3RSZXNvbHZlKHRydWUpKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYoeCBpbnN0YW5jZW9mIFAgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVzb2x2ZSAgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgJCRyZXNvbHZlKHgpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gIFAuYWxsKGl0ZXIpWydjYXRjaCddKGZ1bmN0aW9uKCl7fSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IGdldENvbnN0cnVjdG9yKHRoaXMpXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVzb2x2ZSAgICA9IGNhcGFiaWxpdHkucmVzb2x2ZVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3RcbiAgICAgICwgdmFsdWVzICAgICA9IFtdO1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIHZhbHVlcy5wdXNoLCB2YWx1ZXMpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcbiAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xuICAgICAgaWYocmVtYWluaW5nKSQuZWFjaC5jYWxsKHZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZSwgaW5kZXgpe1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICBlbHNlIHJlc29sdmUocmVzdWx0cyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgVHlwZUVycm9yKG5hbWUgKyBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zdHJpY3QtbmV3LmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XG4gIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3I7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmZvci1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1hcnJheS1pdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNhbWUtdmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi8kLnRhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG52YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyZW50LCBkb21haW4sIGZuO1xuICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSl7XG4gICAgcHJvY2Vzcy5kb21haW4gPSBudWxsO1xuICAgIHBhcmVudC5leGl0KCk7XG4gIH1cbiAgd2hpbGUoaGVhZCl7XG4gICAgZG9tYWluID0gaGVhZC5kb21haW47XG4gICAgZm4gICAgID0gaGVhZC5mbjtcbiAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgZm4oKTsgLy8gPC0gY3VycmVudGx5IHdlIHVzZSBpdCBvbmx5IGZvciBQcm9taXNlIC0gdHJ5IC8gY2F0Y2ggbm90IHJlcXVpcmVkXG4gICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG59O1xuXG4vLyBOb2RlLmpzXG5pZihpc05vZGUpe1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xuLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG59IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICB2YXIgdG9nZ2xlID0gMVxuICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAtdG9nZ2xlO1xuICB9O1xuLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2Vcbn0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbHVzaCk7XG4gIH07XG4vLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuLy8gLSBzZXRJbW1lZGlhdGVcbi8vIC0gTWVzc2FnZUNoYW5uZWxcbi8vIC0gd2luZG93LnBvc3RNZXNzYWdcbi8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4vLyAtIHNldFRpbWVvdXRcbn0gZWxzZSB7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCwgZG9tYWluOiBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW59O1xuICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gIGlmKCFoZWFkKXtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0bmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vJC5jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmludm9rZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaHRtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5yZWRlZmluZS1hbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCAkICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsIFNQRUNJRVMgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBjb3JlW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pJC5zZXREZXNjKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgc2FmZSA9IHRydWU7IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRldGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXNJdGVyYWJsZTIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBPW0lURVJBVE9SXSAhPT0gdW5kZWZpbmVkXG4gICAgfHwgJ0BAaXRlcmF0b3InIGluIE9cbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzLyQuY29yZScpLlNldDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGhpZGUgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBzdHJpY3ROZXcgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZGVmaW5lZCAgICAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKVxuICAsIGZvck9mICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lICA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSUQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCdpZCcpXG4gICwgJGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgc2V0U3BlY2llcyAgID0gcmVxdWlyZSgnLi8kLnNldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBTSVpFICAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSdcbiAgLCBpZCAgICAgICAgICAgPSAwO1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoISRoYXMoaXQsIElEKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG9iamVjdCBpZFxuICAgIGhpZGUoaXQsIElELCArK2lkKTtcbiAgLy8gcmV0dXJuIG9iamVjdCBpZCB3aXRoIHByZWZpeFxuICB9IHJldHVybiAnTycgKyBpdFtJRF07XG59O1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIHN0cmljdE5ldyh0aGF0LCBDLCBOQU1FKTtcbiAgICAgIHRoYXQuX2kgPSAkLmNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi1zdHJvbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZS1hbGwnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3RyaWN0TmV3ICAgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgaWYoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICBzdHJpY3ROZXcodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlO1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRhcmdldFtBRERFUl0sIHRhcmdldCk7XG4gICAgfSk7XG4gICAgJC5lYWNoLmNhbGwoJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzJy5zcGxpdCgnLCcpLGZ1bmN0aW9uKEtFWSl7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgaWYoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKXJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoJ3NpemUnIGluIHByb3RvKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGZvck9mICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBjbGFzc29mID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yT2YodGhpcywgZmFsc2UsIGFyci5wdXNoLCBhcnIpO1xuICAgIHJldHVybiBhcnI7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi10by1qc29uLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9